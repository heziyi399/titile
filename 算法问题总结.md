# 细节



## 二分查找详解



二分法中left + (right - left) /2 就和 (left + right) / 2 的结果相同，但是有效防⽌了 left 和right 太⼤直接相加导致溢出。

```c++
int binarySearch(int[] nums, int target) {
int left = 0;
int right = nums.length - 1; // 注意
while(left <= right) {
int mid = left + (right - left) / 2;
if(nums[mid] == target)
return mid;
else if (nums[mid] < target)
left = mid + 1; // 注意
else if (nums[mid] > target)
right = mid - 1; // 注意
}
return -1;
}

```

1、为什么 while 循环的条件中是 <=，⽽不是 <？
答：因为初始化 right 的赋值是 nums.length - 1 ，即最后⼀个元素的索
引，⽽不是 nums.length 。
这⼆者可能出现在不同功能的⼆分查找中，区别是：前者相当于两端都闭区
间 [left, right] ，后者相当于左闭右开区间 [left, right) ，因为索引大小为 nums.length 是越界的。

我们这个算法中使⽤的是前者 [left, right] 两端都闭的区间。这个区间
其实就是每次进⾏搜索的区间。
什么时候应该停⽌搜索呢？当然，找到了⽬标值的时候可以终⽌：
if(nums[mid] == target)
return mid;
但如果没找到，就需要 while 循环终⽌，然后返回 -1。那 while 循环什么时
候应该终⽌？搜索区间为空的时候应该终⽌，意味着你没得找了，就等于没
找到嘛。

while(left <= right) 的终⽌条件是 left == right + 1 ，写成区间的形式
就是 [right + 1, right] ，或者带个具体的数字进去 [3, 2] ，可⻅这时候
区间为空，因为没有数字既⼤于等于 3 ⼜⼩于等于 2 的吧。所以这时候while 循环终⽌是正确的，直接返回 -1 即可。
**while(left < right) 的终⽌条件是 left == right** ，写成区间的形式就是
[left, right] ，或者带个具体的数字进去 [2, 2] ，这时候区间⾮空，还
有⼀个数 2，但此时 while 循环终⽌了。也就是说这区间 [2, 2] 被漏掉
了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你⾮要⽤ while(left < right) 也可以，我们已经知道了出错的
原因，就打个补丁好了：
//...
while(left < right) {
// ...
}
return nums[left] == target ? left : -1;

此算法有什么缺陷？
答：⾄此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但
是，这个算法存在局限性。
⽐如说给你有序数组 nums = [1,2,2,2,3] ， target 为 2，此算法返回的索引是 2，没错。**但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是⽆法处理的**。



## 📣📣寻找左侧边界的⼆分搜索

```c++
int left_bound(int[]nums,int target){
    if(nums.length == 0) return -1;
    int left = 0;
    int right = nums.length;//注意这里
    while(left < right){
        int mid = (left + right)/2;
        if(nums[mid] == target) right = mid;
        else if(nums[mid] < target ) left = mid+1;
        else if(nums[mid] > target) right  = mid;
    }
    return left;//注意return的是什么
}
另一种写法：
     int left_bound(int[]nums,int target){
    int left = 0;
		int right = nums.length - 1;
		while (left <= right) {
			int mid = (right - left) / 2 + left;
			if (nums[mid] == target) {
				right = mid - 1;
			} else if (nums[mid] < target) {
				left = mid + 1;
			} else if (nums[mid] > target) {
				right = mid - 1;
			}
		}
		// 如果退出循环了，也就是left = right + 1
		// 判断下越界了不
		if (left >= nums.length || nums[left] != target) {
			return -1;
		}
		return left;

}
```

1、为什么 while 中是 < ⽽不是 <= ?
答：⽤相同的⽅法分析，因为 right = nums.length ⽽不是 nums.length -1 。因此每次循环的「搜索区间」是 [left, right) 左闭右开。
while(left < right) 终⽌的条件是 left == right ，此时搜索区间 [left,left) 为空，所以可以正确终⽌。

PS：这⾥先要说⼀个搜索左右边界和上⾯这个算法的⼀个区别，也是很多读者问的：刚才的 right 不是 nums.length - 1 吗，为啥这⾥⾮要写成nums.length 使得「搜索区间」变成左闭右开呢？
因为对于搜索左右侧边界的⼆分查找，这种写法⽐较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你⾮要⽤两端都闭的写法反⽽更简单，我会在后⾯写相关的代码，把三种⼆分搜索都⽤⼀种两端都闭的写法统⼀起来，你耐⼼往后看就⾏了

2、为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？
答：因为要⼀步⼀步来，先理解⼀下这个「左侧边界」有什么特殊含义：

![image-20210821135322544](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210821135322544.png)

对于这个数组，算法会返回 1。这个 1 的含义可以这样解读： nums 中⼩于2 的元素有 1 个。
⽐如对于有序数组 nums = [2,3,5,7] , target = 1 ，算法会返回 0，含义是： nums 中⼩于 1 的元素有 0 个。
再⽐如说 nums = [2,3,5,7], target = 8 ，算法会返回 4，含义是： nums中⼩于 8 的元素有 4 个。

综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间[0, nums.length] ，所以我们简单添加两⾏代码就能在正确的时候 return -1：

```c++
while (left < right) {
//...
}
// target ⽐所有数都⼤
if (left == nums.length) return -1;
// 类似之前算法的处理⽅式
return nums[left] == target ? left : -1;
```

3、为什么 left = mid + 1 ， right = mid ？和之前的算法不⼀样？
答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下⼀步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right) 。

如果想改成两端区间都闭，则可以改成：

```java
int left_bound(int[]nums, int target)
{
    // 搜索区间为 [left, right]
int left = 0, right = nums.length - 1;
while (left <= right) {
int mid = left + (right - left) / 2;
// if else ...
}
```

因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 left 和
right 的更新逻辑如下：

```c
if (nums[mid] < target) {
// 搜索区间变为 [mid+1, right]
left = mid + 1;
} else if (nums[mid] > target) {
// 搜索区间变为 [left, mid-1]
right = mid - 1;
} else if (nums[mid] == target) {
// 收缩右侧边界
right = mid - 1;
}
```

上面代码由于 while 的退出条件是 left == right + 1 ，所以当 target ⽐ nums 中
所有元素都⼤时，会存在以下情况使得索引越界：

![image-20210826114425205](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210826114425205.png)

因此，最后返回结果的代码应该检查越界情况：
if (left >= nums.length || nums[left] != target)
return -1;
return left;



4、为什么该算法能够搜索左侧边界？
答：关键在于对于 nums[mid] == target 这种情况的处理：
if (nums[mid] == target)
right = mid;

可⻅，找到 target 时不要⽴即返回，⽽是缩⼩「搜索区间」的上界right ，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的⽬的。

5、为什么返回 left ⽽不是 right ？
答：都是⼀样的，因为 while 终⽌的条件是 left == right 。

📣📣寻找右侧边界的⼆分查找

```java
 int right_bound(int[]nums,int target){
int left = 0;
		int right = nums.length - 1;
		while (left <= right) {
			int mid = (right - left) / 2 + left;
			if (nums[mid] == target) {
				left = mid + 1;
			} else if (nums[mid] < target) {
				left = mid + 1;
			} else if (nums[mid] > target) {
				right = mid - 1;
			}
		}
		// 如果退出循环了，也就是left = right + 1
		// 判断下越界了不
		if (right < 0 || nums[right] != target) {
			return -1;
		}
		return right;
 }
```

或者写成：
![image-20210925020553032](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210925020553032.png)



1、为什么这个算法能够找到右侧边界？
答：类似地，关键点还是这⾥：
if (nums[mid] == target) {
left = mid + 1;当 nums[mid] == target 时，不要⽴即返回，⽽是增⼤「搜索区间」的下界
left ，使得区间不断向右收缩，达到锁定右侧边界的⽬的。
2、为什么最后返回 left - 1 ⽽不像左侧边界的函数，返回 left ？⽽且
我觉得这⾥既然是搜索右侧边界，应该返回 right 才对。
答：⾸先，while 循环的终⽌条件是 left == right ，所以 left 和 right
是⼀样的，你⾮要体现右侧的特点，返回 right - 1 好了。

⾄于为什么要减⼀，这是搜索右侧边界的⼀个特殊点，关键在这个条件判断：
if (nums[mid] == target) {
left = mid + 1;
// 这样想: mid = left - 1

**因为我们对 left 的更新必须是 left = mid + 1 ，就是说 while 循环结束**
**时， nums[left] ⼀定不等于 target 了**，⽽ nums[left-1] 可能是
target 。

3、为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎
么办？
答：类似之前的左侧边界搜索，因为 while 的终⽌条件是 left == right ，
就是说 left 的取值范围是 [0, nums.length] ，所以可以添加两⾏代码，
正确地返回 -1：
while (left < right) {
// ...
}
if (left == 0) return -1;
return nums[left-1] == target ? (left-1) : -1;

4、是否也可以把这个算法的「搜索区间」也统⼀成两端都闭的形式呢？这样这三个写法就完全统⼀了，以后就可以闭着眼睛写出来了。
答：当然可以，类似搜索左侧边界的统⼀写法，其实只要改两个地⽅就⾏
了：

```c++
int right_bound(int[] nums, int target) {
int left = 0, right = nums.length - 1;
while (left <= right) {
int mid = left + (right - left) / 2;
if (nums[mid] < target) {
left = mid + 1;
} else if (nums[mid] > target) {
right = mid - 1;
} else if (nums[mid] == target) {
// 这⾥改成收缩左侧边界即可
left = mid + 1;
}
}
// 这⾥改为检查 right 越界的情况，⻅下图
if (right < 0 || nums[right] != target)
return -1;
return right;
}

```

对于寻找左右边界的⼆分搜索，常⻅的⼿法是使⽤左闭右开的「搜索区
间」





## 有序数组中某个元素出现次数

按照上面的最左侧边界和最右侧边界，加上一个判断函数即可得到该元素出现个数

```java
public static int getAppearTimes(int[] arr, int key) {
int min = BinarySearch.binarySearchMaxPosition(arr, key);
int max = BinarySearch.binarySearchMinPosition(arr, key);
if (min != -1 && max != -1) {
if (min == max) {
return 1;
} else {
return max - min - 1;
}
} else {
    return 0;
}
}
```



## 局部最小的位置

给定一个无序数组arr，已知任意相邻的两个元素值都不重复，返回任意一个局部最小的位置。
局部最小是指：
1）arr[0] < arr[1] ，0 是局部最小的位置
2）arr[N-1] < arr[N-2]，N-1 是局部最小的位置
3）arr[i] < arr[i-1] && arr[i] < arr[i+1]，i 是局部最小的位置
要求时间复杂度为O(logn)
未必一定要求数组有序，只要能在比较时淘汰一半，留下另一半，就可以实现O(logn)

```java
public static int search(int[] arr) {
if (arr.length == 0) {
return -1;
}
    if(arr.length == 1)
        return 0;
    if(arr[0] < arr[1])
        return 0;
    if(arr[arr.length -1] > arr[arr.length - 2])
        return arr.length-1;
    int low = 1,high = arr.length-2;//注意这个部分
    int mid = 0;
    while(low <= high)    //这里是核心
    {
        mid = (low  + high)/2;
        if(arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1])
            return mid;
        if(arr[mid] > arr[mid-1])
            high = mid-1;
        else if(arr[mid] > arr[mid+1])
            low = mid+1;
    }
    return -1;//没找到
```



## 查找第一个大于等于给定值的元素

```java
public static int search(int[] nums, int val) {
int low = 0, high = nums.length - 1;
while (low <= high) {
int mid = (low + high) >>> 1;
if (nums[mid] < val) {
low = mid + 1;
} else {
// 如果nums[mid]是第一个元素，或者nums[mid-1]小于val
// 说明nums[mid]就是第一个大于等于给定值的元素
if (mid == 0 || nums[mid - 1] < val) {
return mid;
}
high = mid - 1;
}
}
return -1;
}
```

或者这样：

```java
public static int search(int[] nums, int val) {
int low = 0, high = nums.length - 1,index=0;
while (low <= high) {
int mid = (low + high) >>> 1;
if (nums[mid] < val) {
low = mid + 1;
} else {
// 如果nums[mid]是第一个元素，或者nums[mid-1]小于val
// 说明nums[mid]就是第一个大于等于给定值的元素
index=mid;
high = mid - 1;
}
}
return index;
}

```



## 二分之向数组插入元素(搜索插入位置)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

 数组为互不重复的升序序列。



```java
  public int searchInsert(int[] nums, int target) {
if(nums.length == 1) {
    if(target >nums[0]) return 1;
    else return 0;
}
int low = 0,high = nums.length-1;
if(nums[nums.length-1] <target) return nums.length;
if(nums[0] >target) return 0;
while(low <=high)
{
    int mid = (low + high)/2;
    if(nums[mid] == target) return mid;
    
  else  if(nums[mid] <target)
    low = mid+1;
    if(nums[mid] > target )
    high = mid-1;
}
return low;
    }
```

## [528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)

难度中等204

给你一个 **下标从 0 开始** 的正整数数组 `w` ，其中 `w[i]` 代表第 `i` 个下标的权重。

请你实现一个函数 `pickIndex` ，它可以 **随机地** 从范围 `[0, w.length - 1]` 内（含 `0` 和 `w.length - 1`）选出并返回一个下标。选取下标 `i` 的 **概率** 为 `w[i] / sum(w)` 。



- 例如，对于 `w = [1, 3]`，挑选下标 `0` 的概率为 `1 / (1 + 3) = 0.25` （即，25%），而选取下标 `1` 的概率为 `3 / (1 + 3) = 0.75`（即，`75%`）。

-----------

![image-20220221122836110](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220221122836110.png)

```java
  public Solution(int[] w) {
arr = new int[w.length];
arr[0] = w[0];
for(int i = 1;i <w.length;i++)
arr[i] = arr[i-1]+w[i];
total = Arrays.stream(w).sum();
    }
    
    public int pickIndex() {
int x = (int)(Math.random() * total)+1;//权重是正整数，从1开始
return binary(x);
    }
    public int binary(int x)
    {
        int low = 0,high = arr.length-1;
        while(low <= high)
        {
int mid = low +(high - low)/2;
if(arr[mid] < x)
low = mid+1;
else{
if (mid == 0 || arr[mid - 1] < x) {
return mid;
}
high = mid - 1;
}

        }
        return low;
    }
```



## 循环有序数组的最小值
循环有序数组是指：有序数组左边任意长度的部分放到右边去，右边的部分拿到左边来、比如数组【1,2,3,4,5】，是有序循环数组，【4,1,2,3,3】也是。
算法：
令low 初值为0，high 初值为N-1.。
1）首先判断arr[low]<arr[high]，如果为true，那么说明low~high 范围内是一个正常的有序数组，没有循环部分，那么最小值即为arr[0]
2）mid 为low 和high 的中间位置。
如果arr[mid] < arr[low]，那么说明最小值一定在low 与mid（包含mid）之间，high = mid ，因为mid 一定处于循环部分。比如【7,8,,9,1,2,3,4,5,6】。进入下次循环。
如果arr[mid] > arr[high]，那么说明最小值一定在mid（不含mid）与high 之间，low = mid+1，因为mid 一定处于循环部分。比如【4,5,6,7,8,9,1,2,3】。进入下次循环。
3）如果都不满足，那么说明arr[low]=arr[high]=arr[mid]。此时无法使用二分查找，只能遍历数组去查找最小值，查找到后返回。



## [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)



![image-20220123140651212](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220123140651212.png)

核心思路：将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。

代码：

```java
 public int search(int[] nums, int target) {
int len = nums.length-1;

int left = 0,right = len;
if(nums.length == 0) return -1;
if(len == 0) return target == nums[0]?0:-1;
while(left <= right){
int mid = (right + left)/2;
if(target == nums[mid]) return mid;
if(nums[0] <= nums[mid])
{
if(target >=nums[left] && target < nums[mid])
{
right = mid-1;

}
else{
left = mid+1;
}
}
else{
if(target > nums[mid] && target <= nums[right])
{
    left = mid+1;
}
else{
    right = mid-1;
}
}
}
return -1;
    }
```

## [ 搜索旋转数组2](https://leetcode-cn.com/problems/search-rotate-array-lcci/)

难度中等83

搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

**示例1:**

```
 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
 输出: 8（元素5在该数组中的索引）
```

---

与上面的相比区别是这个数组中有重复元素。这里要注意，题目中的旋转多次其实并没有影响，旋转多次仍然和一次是一样的。

每次取中间索引判断是否和target相等，如果相等，则继续将target往左遍历，遍历到最小和target相等的索引然后返回

如果不等：则判断midVal和rVal(右边界的值)，此时有三种可能：

1）midVal<rVal,则可以说明mid~right一定是递增的，则判断target是否是大于midVal并且小于等于rVal，即是否在(mid,right]这个区间，如果是，压缩区间left=mid+1,否则说明不在(mid,right]区间，压缩区间 [left,mid)

2)midVal>rVal，则可以说明left~mid是递增的，因为原数组是非递减的，要满足中间数值大于最右边数值，那么最大值一定不在midVal的左侧(假如在左侧，那么有left~k)递增，然后k+1（k<mid）~right递增。处理方式同上

3）midVal==rVal，则有两种可能 right~0~mid 的值都相等，或者 mid~right的值相等，无论是哪种，都可以将right舍去，压缩区间



```java
  public int search(int[] arr, int target) {
int left =0,right=arr.length-1;
while(left <= right)
{
    if(arr[left]== target) return left;
    int mid = (left +right)/2;
    int num = arr[mid];
    if(num == target)
    {
        while(mid > 0 && arr[mid-1]==num)
        mid--;
        return mid;
    }
    else if(arr[mid] < arr[right])//mid-right都是升序
    {
    if(target > num && target<=arr[right]) left = mid+1;//注意，只有同时满足这两个条件才说明target在mid与right之间，否则其他情况均让right=mid-1
    else right = mid-1;
    }
    else if(num > arr[right])
    {
        //left-mid为升序
      if (target < num && arr[left] <= target) 
      right = mid-1;//注意这个判断条件，因为如果target<num.有可能target在num的左边或者右边，如果在Target<arr[mid] && target>arr[left],说明target在mid与left之间
        else left=mid+1;
    }
    else right--;
}
return -1;
    }
```





## 快速幂：[50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

难度中等853

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的 `n` 次幂函数（即，`x的n次方` ）。

----------

![image-20220131164242921](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220131164242921.png)

递归的边界为 n = 0，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 O(\log n)，算法可以在很快的时间内得到结果。



```java
public double myPow(double x, int n) {//主函数
        long N =n;
     if(n>0) return mytwo(x,N);
     else return 1.0/mytwo(x,-N);

       }
       public double mytwo(double x,long N)
       {
           if(N==0) return 1;
           double y = mytwo(x,N/2);
           if(N%2==1) return y*y*x ;
           else return y*y;
       }
```



## [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

示例:

输入: [1,2,3,4,5]
输出: [120,60,40,30,24]

-------

![image-20220201005249978](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220201005249978.png)





```java
 public int[] constructArr(int[] a) {
        if(a==null||a.length==0) return new int[0];
int[]ans =new int[a.length];
int temp=1;
ans[0]=1;
for(int i = 1;i <a.length;i++)
{
ans[i] = ans[i-1]*a[i-1];
}
for(int j = a.length-2;j>=0;j--)
{
    temp *=a[j+1];
    ans[j] *=temp;
}

return ans;
    }
```

## [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

难度简单349

给定一个 **正整数** `num` ，编写一个函数，如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**进阶：不要** 使用任何内置的库函数，如 `sqrt` 。

---

这里采用二分法，因为sqrt（num)一定在1~num之间

```java
  public boolean isPerfectSquare(int num) {

int low = 1,high = num;
while(low <= high)
{
        int mid = (low + high)/2;
      long square = (long) mid * mid;

    if(square == num) return true;
    else if(square > num) high = mid -1;
    else low = mid+1;
}
return false;
    }
```

## 平方根

求x的平方根：

方法1：

本题是一道常见的面试题，面试官一般会要求面试者在不使用 \sqrt{x} 
x

  函数的情况下，得到 x 的平方根的整数部分。一般的思路会有以下几种：

通过其它的数学函数代替平方根函数得到精确结果，取整数部分作为答案；

通过数学方法得到近似结果，直接作为答案。

方法一：袖珍计算器算法
「袖珍计算器算法」是一种用指数函数 \exp 和对数函数 \ln代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。

![image-20220129124312522](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220129124312522.png)

![image-20220129124918652](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220129124918652.png)

```java
    public int mySqrt(int x) {
if(x==0)return 0;
int ans = (int)Math.exp(0.5*Math.log(x));
return (long)(ans +1) *(ans +1)<=x?ans+1:ans;
    }
```

方法二：二分法

  

```java
public int mySqrt(int x) {

int left=0,right=x;

int ans=-1;

while(right>=left){

int mid=left+(right-left)/2;

if((long)mid*(long)mid<=x)

//注意这里不能写成(long)(mid*mid),不能把相乘写在括号里里面，因为这样mid*mid的结果已经会溢出了

//可以写成(long)mid*(long)mid或者(long)mid*mid

{
  left=mid+1;
ans=mid;

}
else right=mid-1;
}

return ans;

  }


```

或者这样：

```java
    public int mySqrt(int x) {
int left=0,right=x;
int ans=-1;
while(right>=left){
int mid=left+(right-left)/2;
if((long)mid*(long)mid<x)
//注意这里不能写成(long)(mid*mid),不能把相乘写在括号里里面，因为这样mid*mid的结果已经会溢出了
//可以写成(long)mid*(long)mid或者(long)mid*mid
{
    left=mid+1;
    ans=mid;

}
else if((long)mid*mid>x) right=mid-1;
else{
    ans=mid;break;
}
}
return ans;
    }
```



## [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/)

难度困难144

给你一个 **山脉数组** `mountainArr`，请你返回能够使得 `mountainArr.get(index)` **等于** `target` **最小** 的下标 `index` 值。

如果不存在这样的下标 `index`，就请返回 `-1`。

 

何为山脉数组？如果数组 `A` 是一个山脉数组的话，那它满足如下条件：

**首先**，`A.length >= 3`

**其次**，在 `0 < i < A.length - 1` 条件下，存在 `i` 使得：

- `A[0] < A[1] < ... A[i-1] < A[i]`
- `A[i] > A[i+1] > ... > A[A.length - 1]`

---



思路：二分法找到山顶，然后两边一个升序一个降序，升序用升序的递归，降序用降序的递归，这里尤其注意边界条件（low<high还是low<=high，如果符号出错会导致结果错误）

```java
 public int findInMountainArray(int target, MountainArray mountainArr) {
        int low = 0,high = mountainArr.length()-1;
        int index = -1;
     //如果nums[mid]>num[mid+1]，则说明mid在数组降序的第二部分，最大值在mid的左边，更新right=mid-1;
//如果nums[mid]<num[mid+1]，则说明mid在数组升序的第二部分，最大值在mid的右边，更新left=mid+1；
      while(low <= high)
        {
            int mid = (low + high)/2;
         if(mountainArr.get(mid)<mountainArr.get(mid+1))
         low = mid+1;
         else high = mid-1;

        
        }
        index = binaryfind(0,low,target,mountainArr,true);
        if(index!= -1) return index;
        return binaryfind(low+1,mountainArr.length()-1,target,mountainArr,false);
    }
    public int binaryfind(int low,int high,int target,MountainArray mountainArr,boolean flag)
    {
        if(flag){
while(low <= high)
{
    int mid = (low + high)/2;//升序二分查找
    if(mountainArr.get(mid) == target) return mid;
    else if(mountainArr.get(mid)<target) low = mid+1;
    else high = mid-1;
}
return -1;
        }
        else
        {
while(low <= high)
{
    int mid = (low + high)/2;//降序二分查找
    if(mountainArr.get(mid) == target) return mid;
    else if(mountainArr.get(mid)<target) high = mid-1;
    else low = mid+1;
}
return -1;
        }
```

## 木头切割

给定长度为n的数组，每个元素代表一个木头的长度，木头可以任意截断，从这堆木头中截出至少k个相同长度为m的木块。已知k，求max(m)。

输入两行，第一行n, k，第二行为数组序列。输出最大值。

> 输入
> 5 5
> 4 7 2 10 5
> 输出
> 4
> 解释：如图，最多可以把它分成5段长度为4的木头
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVHVR60EJHyZEZAdt5KkTSSvpjP30ZWe9WxlFFHibiaPchmjVcVpkkCkVqUNicm9NReAvCbKC0vdy6sZg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

----

方法一：暴力。大概思路就是从1遍历到木棍最长的长度，每次遍历的长度作为m，如果可以将所有木头截出来k个长度为m的木块，则更新最大值，最后输出最大值即可。

方法二：二分。方法一在[1,max]寻找最大长度时是顺序遍历，由于其有序，我们可借助二分来快速检出结果。如果能截出来k个长度为x的木块，说明答案肯定 >= x，则接下来只需在[x,max]中找m最大满足条件的长度。反之则说明答案 < x，则在[1,x-1]中寻找结果。这样我们每次可以舍弃1/2的情况，因此使用二分的时间复杂度是O(n * log Len)。

```java
#include <iostream>
using namespace std;

const int N = 100010;
int a[N];
int n, k;

int check(int mid)
{
    int res = 0;
    for (int i = 0; i < n; i ++ ) res += a[i] / mid;
    return res;
}

int main()
{
    cin >> n >> k;
    int l = 1, r = -1;
    
    for (int i = 0; i < n; i ++ )
    {
        cin >> a[i];
        r = max(r, a[i]);
    }
    
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid) >= k) l = mid;
        else r = mid - 1;
    }
    
    cout << l << endl;
    return 0;
}
```

## 1~n中缺失的数字

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

 

示例 1:

输入: [0,1,3]
输出: 2
示例 2:

输入: [0,1,2,3,4,5,6,7,9]
输出: 8

------

自己一开始是用哈希表写的，但是发现题目中数组是有序的，二分法更快。

![image-20220414110142460](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220414110142460.png)

```java
    public int missingNumber(int[] nums) {
int[]map = new int[nums.length+1];
int low = 0,high = nums.length-1;
while(low <= high)
{
    int mid = (low +high)/2;
    if(nums[mid] == mid)
    low = mid +1;//low最后是第一个nums[mid]!=mid的索引位置
    else high = mid-1;//注意这个地方，high=mid-1
}
return low;

    }
```

## 巧妙二分：[875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

难度中等417【这种具有单调性的数组出现 时都可以猜是否可以二分】

珂珂喜欢吃香蕉。这里有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `h` 小时后回来。

珂珂可以决定她吃香蕉的速度 `k` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `k` 根。如果这堆香蕉少于 `k` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 `h` 小时内吃掉所有香蕉的最小速度 `k`（`k` 为整数）。

 

**示例 1：**

```
输入：piles = [3,6,7,11], h = 8
输出：4
```

**示例 2：**

```
输入：piles = [30,11,23,4,20], h = 5
输出：30
```

-------

如果珂珂在 hh 小时内吃掉所有香蕉的最小速度是每小时 kk 个香蕉，则当吃香蕉的速度大于每小时 kk 个香蕉时一定可以在 hh 小时内吃掉所有香蕉，当吃香蕉的速度小于每小时 kk 个香蕉时一定不能在 hh 小时内吃掉所有香蕉。

由于吃香蕉的速度和是否可以在规定时间内吃掉所有香蕉之间存在单调性，因此可以使用二分查找的方法得到最小速度 kk。

由于每小时都要吃香蕉，即每小时至少吃 1 个香蕉，因此二分查找的下界是 1；由于每小时最多吃一堆香蕉，即每小时吃的香蕉数目不会超过最多的一堆中的香蕉数目，因此二分查找的上界是最多的一堆中的香蕉数目。

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
int sum = Arrays.stream(piles).sum();
int average = sum/piles.length ;
Arrays.sort(piles);
int max = Arrays.stream(piles).max().getAsInt();
int ans = max;
int high = max;
//最小是每小时1 根，最大是最大的那一堆数量
int low = 1;
while(low < high){
    int mid = low +(high-low)/2;
    if(getTime(piles,mid)<=h){
        high = mid;
        ans = mid;
    }
    else low = mid+1;
}
return ans;
    }
    int getTime(int[]piles,int speed){
        //注意这里有一个很巧妙的计算时间法，是数组中的元素+吃的速度-1再除以速度的办法，可以解决 8/4=2 6/4=2 的问题（如果一堆有6个 每小时吃4个 要吃两小时）
        int tot = 0;
        for(int pile:piles){
            tot +=(pile+speed-1)/speed;
        }
        return tot;
    }
}
```

## [658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)

难度中等426

给定一个 **排序好** 的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。

整数 `a` 比整数 `b` 更接近 `x` 需要满足：

- `|a - x| < |b - x|` 或者
- `|a - x| == |b - x|` 且 `a < b`

 

**示例 1：**

```
输入：arr = [1,2,3,4,5], k = 4, x = 3
输出：[1,2,3,4]
```

**示例 2：**

```
输入：arr = [1,2,3,4,5], k = 4, x = -1
输出：[1,2,3,4]
```

-----------------



假设数组长度为 nn，注意到数组 \textit{arr}arr 已经按照升序排序，我们可以将数组 \textit{arr}arr 分成两部分，前一部分所有元素 [0, \textit{left}][0,left] 都小于 xx，后一部分所有元素 [\textit{right}, n - 1][right,n−1] 都大于等于 xx，\textit{left}left 与 \textit{right}right 都可以通过二分查找获得。

\textit{left}left 和 \textit{right}right 指向的元素都是各自部分最接近 xx 的元素，因此我们可以通过比较 \textit{left}left 和 \textit{right}right 指向的元素获取整体最接近 xx 的元素。如果 x - \textit{arr}[\textit{left}] \le \textit{arr}[\textit{right}] - xx−arr[left]≤arr[right]−x，那么将 \textit{left}left 减一，否则将 \textit{right}right 加一。相应地，如果 \textit{left}left 或 \textit{right}right 已经越界，那么不考虑对应部分的元素。

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int right = binarySearch(arr, x);
        int left = right - 1;
        while (k > 0) {
            if (left < 0) {
                right++;
            } else if (right >= arr.length) {
                left--;
            } else if (x - arr[left] <= arr[right] - x) {
                left--;
            } else {
                right++;
            }
            k--;
        }
        List<Integer> ans = new ArrayList<Integer>();
        for (int i = left + 1; i < right; i++) {
            ans.add(arr[i]);
        }
        return ans;
    }

   public int binarySearch(int[] arr, int x) {
        int low = 0, high = arr.length - 1;
        while (low <= high) {
            int mid = low + (high-low)/2;
            if(arr[mid]==x) return mid;
            if (arr[mid] > x) {
                high = mid-1;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
}


```

## [1268. 搜索推荐系统](https://leetcode.cn/problems/search-suggestions-system/)

难度中等140

给你一个产品数组 `products` 和一个字符串 `searchWord` ，`products` 数组中每个产品都是一个字符串。

请你设计一个推荐系统，在依次输入单词 `searchWord` 的每一个字母后，推荐 `products` 数组中前缀与 `searchWord` 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。

请你以二维列表的形式，返回在输入 `searchWord` 每个字母后相应的推荐产品的列表。

 

**示例 1：**

```
输入：products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
输出：[
["mobile","moneypot","monitor"],
["mobile","moneypot","monitor"],
["mouse","mousepad"],
["mouse","mousepad"],
["mouse","mousepad"]
]
解释：按字典序排序后的产品列表是 ["mobile","moneypot","monitor","mouse","mousepad"]
输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 ["mobile","moneypot","monitor"]
输入 mou， mous 和 mouse 后系统都返回 ["mouse","mousepad"]
```

------------------------

未优化时的写法：单纯地判断每一个字符串indexof(前缀)是否等于0 【其实可以用startswith判断】，时间复杂度很高，因为可能要把products中的全部遍历一遍

改进：对于product中的字符串，先二分查找找到第一个以前缀开头的字符串，然后往后遍历即可

```java
 public List<List<String>> suggestedProducts(String[] products, String searchWord) {
Arrays.sort(products);
List<List<String>>ans=new ArrayList<>();
int index=0;
//二分查找首个以pre开头的单词
for(int i = 0;i<searchWord.length();i++){
    String pre=searchWord.substring(0,i+1);
    int l=0,r=products.length-1;
    while(l<=r){
        int mid=(l+r)/2;
        //注意这里比较的字符串是pre，也就是目前截出来的前缀
        if(products[mid].compareTo(pre)<0){
            //mid这个字符串的字典序小于pre的
            l=mid+1;
        }else{
            index=mid;
            r=mid-1;
        }
    }
List<String>str=new ArrayList<>();
for(int j=index;j<Math.min(index+3,products.length);j++){
    if(!products[j].startsWith(pre)) break;
   
    str.add(products[j]);
}
ans.add(new ArrayList<>(str));
}
return ans;
    }
```

## 排序数组中出现1次的数

要求用logn复杂度，空间复杂度o(1)实现

-------

假设出现一次的数下标是x,那么x左边的数字如果下标为偶数，则一定有nums[偶数]=nums[偶数+1]，如果x左边的数字下标为奇数，则一定有nums[奇数]=nums[ 奇数-1]所以如果一个数下标m为偶数且nums[m]=nums[m+1]那么它一定在x的左边，一个数下标n为奇数且nums[n]=nums[n-1]那么一定在x的左边



![image-20230220131916402](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230220131916402.png)

```java
  public int singleNonDuplicate(int[] nums) {
int low=0,high=nums.length-1;
while(low<high)
{
    int mid=low+(high-low)/2;
if (nums[mid]==nums[mid^1]) {
    //或者写成 if((mid%2==0&&nums[mid]==nums[mid+1])||(mid%2==1&&nums[mid]==nums[mid-1]))
                low = mid + 1;
            } else {
                high = mid;
            }

}
return nums[low];
    }
```



#  非递归归并排序

```java
/**
     * 归并排序（非递归）
     * （合并内部已排好序的两两相邻数组）从切分的数组长度为1开始，一次归并变回原来长度的2倍
     * @param nums 待排序数组
     * @return 排好序的数组
     */
	static int[] mergSort(int a[]) {
		int len=1;
		while(len<=a.length) {//while终止条件
			for(int i=0;i+len<a.length;i+=len*2) {
			//for循环终止条件为当剩下的元素数量不超过一组时（即没有第二组与之合并了）
				int lb=i,ub=i+len*2-1,mid=i+len-1;
				if(ub>a.length-1) {
					ub=a.length-1;//整个待排序数组为奇数的情况
				}
				merge(a,lb,mid,ub);
				//其中[low,mid],[mid+1,high]为两组已排好序的数组，
				//各自的长度为len;后者长度可能不满len，这只可能出现在原数组元素个数为奇时。
			}
			len*=2;
		}
		return a;
	}
	    /**
     * 将合并起来的两个内部已排序数组归并排序，同递归版，
     * 先将左半部分存在L，右半部分存在R，然后直接对原数组进行修改。
     * @param nums 带排序数组
     * @param low 左边数组第一个元素索引
     * @param mid 左边数组最后一个元素索引，mid + 1为右边数组第一个元素索引
     * @param high 右边数组最后一个元素索引
     */
	static void merge(int a[],int lb,int mid,int ub) {
		int n1=mid-lb+1;
		int n2=ub-mid;
		int L[]=new int[n1+1];
		int R[]=new int[n2+1];
		for(int i=0;i<n1;i++) {
			L[i]=a[lb+i];
		}
		for(int i=0;i<n2;i++) {
			R[i]=a[mid+1+i];
		}
		L[n1]=R[n2]=Integer.MAX_VALUE;
		int i=0,j=0;
		for(int k=lb;k<=ub;k++) {
			if(L[i]<=R[j]) {
				a[k]=L[i];
				i++;
			}else {
				a[k]=R[j];
				j++;
			}
		}
	}

```

# 拓扑排序

![image-20230402180911308](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230402180911308.png) 

    根据图中的边的方向，我们可以看出，若要满足得到其拓扑排序，则结点被遍历的顺序必须满足如下要求：

结点1必须在结点2、3之前
结点2必须在结点3、4之前
结点3必须在结点4、5之前
结点4必须在结点5之前
        则一个满足条件的拓扑排序为[1, 2, 3, 4, 5]。 

拓扑排序存在的前提
        当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序。该论断可以利用反证法证明如下：

        假设我们有一由到这n个结点构成的有向图，且图中这些结点构成一个环。这即是说对于所有1≤i<n-1，图中存在一条有向边从指向。同时还存在一条从指向的边。假设该图存在一个拓扑排序。
    
        那么基于这样一个有向图，显然我们可以得知对于所有1≤i<n-1，必须在之前被遍历，也就是必须在之前被遍历。同时由于还存在一条从指向的边，必须在之前被遍历。这里出现了与我们的假设所冲突的结果。因此我们可以知道，该图存在拓扑排序的假设不成立。也就是说，对于非有向无环图而言，其拓扑排序不存在。


## [剑指 Offer II 115. 重建序列](https://leetcode.cn/problems/ur2n8P/)

难度中等129

给定一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 是范围为 `[1，n]` 的整数的排列。还提供了一个 2D 整数数组 `sequences` ，其中 `sequences[i]` 是 `nums` 的子序列。
检查 `nums` 是否是唯一的最短 **超序列** 。最短 **超序列** 是 **长度最短** 的序列，并且所有序列 `sequences[i]` 都是它的子序列。对于给定的数组 `sequences` ，可能存在多个有效的 **超序列** 。

- 例如，对于 `sequences = [[1,2],[1,3]]` ，有两个最短的 **超序列** ，`[1,2,3]` 和 `[1,3,2]` 。
- 而对于 `sequences = [[1,2],[1,3],[1,2,3]]` ，唯一可能的最短 **超序列** 是 `[1,2,3]` 。`[1,2,3,4]` 是可能的超序列，但不是最短的。

*如果 `nums` 是序列的唯一最短 **超序列** ，则返回 `true` ，否则返回 `false` 。*
**子序列** 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。

 

**示例 1：**

```
输入：nums = [1,2,3], sequences = [[1,2],[1,3]]
输出：false
解释：有两种可能的超序列：[1,2,3]和[1,3,2]。
序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。
序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。
因为 nums 不是唯一最短的超序列，所以返回false。
```

**示例 2：**

```
输入：nums = [1,2,3], sequences = [[1,2]]
输出：false
解释：最短可能的超序列为 [1,2]。
序列 [1,2] 是它的子序列：[1,2]。
因为 nums 不是最短的超序列，所以返回false。
```

----



![image-20230402182338499](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230402182338499.png)

```java
public boolean sequenceReconstruction(int[] nums, int[][] sequences) {
        //可以将 sequences 中的所有序列看成有向图，数字 1 到 n 分别表示图中的 n 个结点，每个序列中的相邻数字表示的结点之间存在一条有向边。根据给定的序列构造超序列等价于有向图的拓扑排序。


  //转化成边
        Map<Integer, Set<Integer>> edge = new HashMap<>();
        //记录入度
        int[] inDegree = new int[nums.length + 1];
        for (int[] sequence : sequences) {
            //注意这里是一个子序列，有多个元素，不是两个
            for (int i = 1; i < sequence.length; i++) {
                int from = sequence[i - 1];
                int to = sequence[i];
                //判断是否有此条边
                if (edge.containsKey(from) && edge.get(from).contains(to)) {
                    continue;
                }
                if(!edge.containsKey(from)) edge.put(from,new HashSet<>());
             
                edge.get(from).add(to);
                inDegree[to]++;
            }
        }
        //记录入度为0的点
        Queue<Integer> queue = new ArrayDeque<>();
        for (int i = 1; i <= nums.length; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        while (!queue.isEmpty()) {
            //存在多个入度为0的点 会有多个超序列 直接返回false
            if (queue.size() > 1) {
                return false;
            }
            int from = queue.poll();
            Set<Integer> set = edge.get(from);
            if (set == null) {
                continue;
            }
            //和此点连通的点入度减一
            for (int point : set) {
                inDegree[point]--;
                //注意这里，只有入度为0的时候才加入到队列中去
                if (inDegree[point] == 0) {
                    queue.add(point);
                }
            }
        }
        return true;


    }
```



# 滑动窗口

1. 右指针平稳移动，左指针视情况移动。右先行，左视定。
2. 多数情况下可以先对数组进行排序处理；
3. 循环条件以及边界条件一定要处理好。（在这个地方失败很多次了）

对于负数，滑动窗口处理不好，左右摇摆了，不知道往那边走了。

该算法的⼤致逻辑如下：

```c
int left = 0, right = 0;
while (right < s.size()) {`
// 增⼤窗⼝
window.add(s[right]);
right++;
while (window needs shrink) {
// 缩⼩窗⼝
window.remove(s[left]);
left++;
}
}
```

算法框架：

```c
void slidingWindow(string s, string t) {
unordered_map<char, int> need, window;
for (char c : t) need[c]++;

int left = 0, right = 0;
int valid = 0;
while (right < s.size()) {
// c 是将移⼊窗⼝的字符
char c = s[right];
// 右移窗⼝
right++;
// 进⾏窗⼝内数据的⼀系列更新
...
/*** debug 输出的位置 ***/
printf("window: [%d, %d)\n", left, right);
/********************/
// 判断左侧窗⼝是否要收缩
while (window needs shrink) {
// d 是将移出窗⼝的字符
char d = s[left];
// 左移窗⼝
left++;
// 进⾏窗⼝内数据的⼀系列更新
...
}
}
}
```

## 在串s里找出包含t所有字母的最小子串

![image-20210827204229140](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210827204229140.png)

滑动窗⼝算法的思路是这样：
1、我们在字符串 S 中使⽤双指针中的左右指针技巧，初始化 left =
right = 0 ，把索引左闭右开区间 [left, right) 称为⼀个「窗⼝」。
2、我们先不断地增加 right 指针扩⼤窗⼝ [left, right) ，直到窗⼝中
的字符串符合要求（包含了 T 中的所有字符）。
3、此时，我们停⽌增加 right ，转⽽不断增加 left 指针缩⼩窗⼝
[left, right) ，直到窗⼝中的字符串不再符合要求（不包含 T 中的所有
字符了）。同时，每次增加 left ，我们都要更新⼀轮结果。
4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。
这个思路其实也不难，第 2 步相当于在寻找⼀个「可⾏解」，然后第 3 步在优化这个「可⾏解」，最终找到最优解，也就是最短的覆盖⼦串。左右指针轮流前进，窗⼝⼤⼩增增减减，窗⼝不断向右滑动，这就是「滑动窗⼝」这个名字的来历。
 **needs 和 window 相当于计数器，分别记录 T 中字符出现次数和「窗⼝」中的相应字符的出现次数。**



**valid 变量表⽰窗⼝中满⾜ need 条件的字符个数**，如果 valid 和
need.size 的⼤⼩相同，则说明窗⼝已满⾜条件，已经完全覆盖了串 T 。
现在开始套模板，只需要思考以下四个问题：
1、当移动 right 扩⼤窗⼝，即加⼊字符时，应该更新哪些数据？
2、什么条件下，窗⼝应该暂停扩⼤，开始移动 left 缩⼩窗⼝？
3、当移动 left 缩⼩窗⼝，即移出字符时，应该更新哪些数据？
4、我们要的结果应该在扩⼤窗⼝时还是缩⼩窗⼝时进⾏更新？
如果⼀个字符进⼊窗⼝，应该增加 window 计数器；如果⼀个字符将移出窗⼝的时候，应该减少 window 计数器；当 valid 满⾜ need 时应该收缩窗⼝；应该在收缩窗⼝的时候更新最终结果。
下⾯是完整代码：

```java
string minWindow(string s, string t) {
unordered_map<char, int> need, window;
for (char c : t) need[c]++;
int left = 0, right = 0;
int valid = 0;
// 记录最⼩覆盖⼦串的起始索引及⻓度
int start = 0, len = INT_MAX;
while (right < s.size()) {
    // c 是将移⼊窗⼝的字符
char c = s[right];
// 右移窗⼝
right++;
// 进⾏窗⼝内数据的⼀系列更新
if (need.count(c)) {
window[c]++;
if (window[c] == need[c])
valid++;
}
// 判断左侧窗⼝是否要收缩
while (valid == need.size()) {
// 在这⾥更新最⼩覆盖⼦串
if (right - left < len) {
start = left;
len = right - left;
}
// d 是将移出窗⼝的字符
char d = s[left];
// 左移窗⼝
left++;
// 进⾏窗⼝内数据的⼀系列更新
if (need.count(d)) {
if (window[d] == need[d])
valid--;
window[d]--;
}
}
}
// 返回最⼩覆盖⼦串
return len == INT_MAX ?"" : s.substr(start, len);
}
```

![image-20210826214459019](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210826214459019.png)



## [567. 字符串的排列]判断s2是否包含s1的排列

难度中等564

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true` ；否则，返回 `false` 。

换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

**示例 1：**

```
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").
```

---



```java
 public boolean checkInclusion(String s1, String s2) {
int n=s1.length(),m = s2.length();
int[]arr1 = new int[26];//每个字母出现的次数
int[]arr2 = new int[26];//只要第一个数组中每个字母出现的次数等于第二个数组中每个字母出现的次数即可
if(n >m) return false;
for(int i=0;i < n;i++)
{
arr1[s1.charAt(i) - 'a']++;
arr2[s2.charAt(i)-'a']++;
}
if(Arrays.equals(arr1,arr2)) return true;//注意这个判断数组相同的函数，之前没用过
for(int i=n;i <m;i++)//必须要匹配s1的全部字符串，因此滑动窗口是固定大小的n
{
    arr2[s2.charAt(i)-'a']++;
    arr2[s2.charAt(i-n)-'a']--;
    if(Arrays.equals(arr1,arr2)) return true;
}
return false;
    }
```





## 159.至多包含两个不同字符的最长子串



比如说“abbbce",最长的是"abbb"或者"bbbc"，长度为4，包含2个不同字符



-----------------------------



思路：
使用一个数组int fre[256] 存储字符每个出现的 频率，初值均为0。定义整型变量 count 记录不同字符数量。

当窗口右指针 r < s.size()，开始循环，窗口右移。新加入窗口的字符如果未出现过，count ++。然后更新频率 fre[s[r]]++。

如果这时count值更新后大于2，说明当前窗口不满足要求了，这时要做的就是 缩小窗口。循环左移窗口左指针，直到窗口再次满足要求。

每次移动窗口右指针时 更新窗口最大值，也就是求得的最长子串t的长度。
代码：

```java
// 滑动窗口
int lengthOfLongestSubstringTwoDistinct(string s){
    // 左右指针
    int l, r;
    l = r = 0;
    // 获得长度
    int len = s.size();
    // 存储字符出现频率
    int fre[256] = {0};
    // 不同字符个数
    int count = 0;
    // result
    int res = 0;
    while(r < len){
        // 窗口内出现一个新字符，计数+1
        if(!fre[s[r++]]++){
            count++;
        }
        // 字符种类 > 2, 窗口左边界右移，缩小窗口
        while(count > 2){
            if(--fre[s[l++]] == 0) count--;
        }
        // 更新最大值
        res = max(res, r - l);
    }
    return res;
}

```





## [1358. 包含所有三种字符的子字符串数目](https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/)

难度中等82

给你一个字符串 `s` ，它只包含三种字符 a, b 和 c 。

请你返回 a，b 和 c 都 **至少** 出现过一次的子字符串数目。

 

**示例 1：**

```
输入：s = "abcabc"
输出：10
解释：包含 a，b 和 c 各至少一次的子字符串为 "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" 和 "abc" (相同字符串算多次)。
```

------

这个题的关键在于要明白，加入从0~i中出现了abc至少一次,则从0一直到i之后的子串也一定出现了abc至少一次，所以用双指针（类似滑动窗口）只要找到左边固定时，右边最早的出现abc的串，然后再移动左边指针

```java
 public int numberOfSubstrings(String s) {
 int[]cnt=new int[3];
        int ans = 0, left = 0,right =-1;
       while(left < s.length()) {
          
           while(right<s.length()&&!(cnt[0]>=1&&cnt[1]>=1&&cnt[2]>=1)){
               right++;
               if(right==s.length()) break;
               cnt[s.charAt(right)-'a']++;
               
           }
          
           ans +=s.length()-right;
           cnt[s.charAt(left++)-'a']--;
       }
       return ans;
    }
```





## 求一个数组中子数组的最大平均数

![image-20210903131619101](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210903131619101.png)



```java
public static double findMaxAverage(int[]nums,int k){
        int sum = 0;
    for (int i = 0; i < k; i++) {
        sum += nums[i];//先统计第一个窗口
    }
    int max = sum;
    for (int i = k; i < nums.length; i++) {
        sum -= nums[i-k];//这题窗口大小是固定的，恒为k，因此窗口每次前移一格，比较是否大于原来的sum,大于则更新
        sum+=nums[i];
        max =Math.max(max,sum);
    }
    return 1.0 * max/k;//返回Double
}
```





## 汉明距离
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

java的位运算符中有一个叫异或的运算符，用符号(^)表示，其运算规则是：两个操作数的位中，相同则结果为0，不同则结果为1。但是在c++中不能这么使用。因此这题不适合用c++来算。
如int i = 15, j = 2;

System.out.println("i ^ j = " + (i ^ j));

}

}

运行结果是：i ^ j = 13.
首先要注意很少用到的异或运算，在关于判断两个数的二进制数字的位数是否相等时非常有效，然后还有右移符号是除以二 x >>2
x,都有x ^ x = 0,x ^ 0 = x ,A^ B=A^ 0=A

，因此异或运算对于判断两个数字是否相等非常有效。
用异或实现：
```java
   public int hammingDistance(int x, int y) {
int xor = x^y;
int distance = 0;
while(xor != 0)
{
    if(xor % 2 == 1)
    distance++;
    xor = xor>>1;
}
return distance;
    }
```
还有一种实现是用java内置的函数即Integer.binary

## [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

难度困难1794

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 



---------

![image-20220414100640708](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220414100640708.png)





```java
class Solution {
    public String minWindow(String s, String t) {
        if(s.length()<t.length() || s.length()==0 || s ==null || t == null || t.length() == 0)
            return "";

        //模拟哈希表，存储目标字符串的各个字符的个数
        int[] map = new int[255];
        for(int i=0;i<t.length();i++){
            map[t.charAt(i)]++;
        }

        //双指针遍历源字符串s
        int begin = 0,end = 0;
        //最小字符串的起点
        int minBegin = 0;
        //最小字符串的长度
        int res = Integer.MAX_VALUE;
        //用来记录匹配到字符的个数，如果count == t.length()意味着找到一个匹配的字串
        int count = 0;

        //遍历
        while(end < s.length()){
            //这里可理解为缺失字符的个数，==0时则表示 这个字符匹配够了，==1则表示仍需要再匹配一个该字符
            if(map[s.charAt(end)]>0)
                count ++;
            //不需要匹配的字符，其值此时小于0,这里不需要匹配的字符一直都不会出现大于零的情况
            map[s.charAt(end)]--;
            //尾指针右移
            end++;
            //匹配到一个字串
            while(count == t.length()){
                //比较字串长度，更新字串信息
                if(end - begin < res){
                    res = end - begin;
                    minBegin = begin;
                }
                //如果首指针对应字符是目标字符之一，则跳出循环
                if(map[s.charAt(begin)] == 0)
                    count--;
                //首指针对应字符的哈希值还原
                map[s.charAt(begin)]++;
                //首指针右移
                begin++;
            }
        }

        return res == Integer.MAX_VALUE? "" :s.substring(minBegin,minBegin + res);
    }
} 

```

或者用map这样写：

```java
 public String minWindow(String s, String t) {
        int count=t.length();
int left=0,right=0;
int ans=s.length()+1;
String subs="";
Map<Character,Integer>map=new HashMap<>();
if(s.indexOf(t)>-1) return t;
for(int i=0;i<26;i++)
{
    char temp=(char)(i+'a');
    map.put(temp,0);
}
        for(int i=0;i<26;i++)
        {
            char temp=(char)(i+'A');
            map.put(temp,0);
        }
for(char ch:t.toCharArray())
{
    map.put(ch,map.getOrDefault(ch,0)+1);
}
while(right<s.length())
{
    char ch=s.charAt(right);
if(map.get(ch)>0){
   
count--;
}
    map.put(ch,map.getOrDefault(ch,0)-1);
if(count==0)
{
    //這一步是为了缩小左边窗口，因为可能当前左边的字符并没有在t中出现，那么要右移
    while(map.get(s.charAt(left))<0)
    {
        map.put(s.charAt(left),map.get(s.charAt(left))+1);
        left++;
    }
    //更新答案
    if(right-left+1<ans)
    {
        ans=right-left+1;
        subs=s.substring(left,right+1);
    }
}
right++;
}
return subs;
    }
```





## [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

难度中等986

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

 

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

-----------------------

用一个int[]数组当成hashmap,来记录每个字母出现的次数

```java
  public List<Integer> findAnagrams(String s, String p) {
int nump=0;
int len1 = s.length(),len2=p.length();
if(len1<len2) return new ArrayList<>();

List<Integer>ans = new ArrayList<>();
        int[] sCount = new int[26];
        int[] pCount = new int[26];
        for (int i = 0; i < len2; ++i) {
            ++sCount[s.charAt(i) - 'a'];
            ++pCount[p.charAt(i) - 'a'];
        }
if(Arrays.equals(sCount,pCount))
ans.add(0);
//起始从0开始
for(int i=0;i<len1-len2;i++){
--sCount[s.charAt(i)-'a'];
++sCount[s.charAt(i+len2)-'a'];
if(Arrays.equals(sCount,pCount))
//记得这里因为刚刚已经判断了s字符串从0开始是否与p形成异位词，所以这里是i+1
ans.add(i+1);
}
return ans;
    }
```

或者这样写：

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
     int[] st = new int[128];
     // 维护一个结果集合
     List<Integer> res = new ArrayList<Integer>();
     // p中字符的个数 也就是窗口的大小
     int count = p.length();
    //  记录 p中每个字符出现的个数
     for(int i =0; i<p.length();i++){
         st[p.charAt(i)]++;
     }
     for(int l =0, r=0; r < s.length(); r++){
         char c = s.charAt(r);
//     如果是p中出现的字符 并且个数也符合 count条件减去1
         if(st[c] > 0){
            count --;
         }
         st[c] --;
        //  如果满足条件
         if(count == 0){
            //  压缩左边界，如果小于0就表示这个字符没有出现在p中，那么必须要去掉，这样的话退出while时l对应的字符一定是在p中出现了的
             while(st[s.charAt(l)] < 0){
                 st[s.charAt(l++)]++;
             }
            //  满足异位
             if(r - l +1 == p.length()){
                 res.add(l);
             }
            //  l 右移 找新的窗口
             st[s.charAt(l++)]++;
             count++;
         }
     }
     return res;
    }
}


```



## [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

难度中等118

给你一个整数数组 `nums` 和一个整数 `x` 。每一次操作时，你应当移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值。请注意，需要 **修改** 数组以供接下来的操作使用。

如果可以将 `x` **恰好** 减到 `0` ，返回 **最小操作数** ；否则，返回 `-1` 。

 

**示例 1：**

```
输入：nums = [1,1,4,2,3], x = 5
输出：2
解释：最佳解决方案是移除后两个元素，将 x 减到 0 。
```

-------



```java
  public int minOperations(int[] nums, int x) {
        //转化思维，这里是要数组中减去最左边或者最右边的元素，直到减去的元素和为x,那么可以变换成数组中连续的数组之和为sum-x，其中要保证这个连续数组长度最大，这样减去的元素才会最少，所以其实只是求数组中连续长度之和为某一个值的最大长度
int sum = 0;
for(int i : nums)
sum +=i;
if(sum < x) return -1;
int maxlen = -1;
int left = 0,right = 0,begin=0;
while(right< nums.length){
    begin += nums[right];
    while(begin > sum-x && left<nums.length){
        begin -=nums[left];
        left++;
    }
    if(begin == sum-x){
        maxlen = Math.max(maxlen,right-left+1);

    }
    right++;
}//这里记得答案是nums-maxlen,因为是返回减去的数组
 if (maxlen == -1) return -1;
        else return nums.length-maxlen;

    }
```

## [424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)

难度中等704

给你一个字符串 `s` 和一个整数 `k` 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 `k` 次。

在执行上述操作后，返回包含相同字母的最长子字符串的长度。

 

**示例 1：**

```
输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
```

-------------------

最基本的思路：

于每一个子串：

如果子串里所有的字符都一样，就考虑长度更长的子串；
如果当前子串里出现了至少两种字符，要想使得替换以后所有的字符都一样，并且重复的、连续的部分更长，应该替换掉出现次数最多字符 以外 的字符。



右边界先移动找到一个满足题意的可以替换 k 个字符以后，所有字符都变成一样的当前看来最长的子串，直到右边界纳入一个字符以后，不能满足的时候停下；
然后考虑左边界向右移动，左边界只须要向右移动一格以后，右边界就又可以开始向右移动了，继续尝试找到更长的目标子串；
替换后的最长重复子串就产生在右边界、左边界交替向右移动的过程中。



```java
    public int characterReplacement(String s, int k) {
        int len = s.length();
        if (len < 2) {
            return len;
        }

        char[] charArray = s.toCharArray();
        int left = 0;
        int right = 0;

        int res = 0;
        //maxCount是left,righ区间内字母出现次数最多的这个次数
        int maxCount = 0;
        int[] freq = new int[26];
        // [left, right) 内最多替换 k 个字符可以得到只有一种字符的子串
        while (right < len){
            freq[charArray[right] - 'A']++;
            // 在这里维护 maxCount，因为每一次右边界读入一个字符，字符频数增加，才会使得 maxCount 增加
            maxCount = Math.max(maxCount, freq[charArray[right] - 'A']);
            right++;

            if (right - left > maxCount + k){
              	// 说明此时 k 不够用
                // 把其它不是最多出现的字符替换以后，都不能填满这个滑动的窗口，这个时候须要考虑左边界向右移动
                // 移出滑动窗口的时候，频数数组须要相应地做减法
                freq[charArray[left] - 'A']--;
                left++;
            }
            res = Math.max(res, right - left);
        }
        return res;
    }

```



## [面试题 17.18. 最短超串](https://leetcode.cn/problems/shortest-supersequence-lcci/)

难度中等64

假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。

返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。

**示例 1:**

```
输入:
big = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]
small = [1,5,9]
输出: [7,10]
```

**示例 2:**

```
输入:
big = [1,2,3]
small = [4]
输出: []
```

---------------------





注意：这里因为要判断长数组中是否出现了短数组中某个元素，短数组放在hashset中，巧妙转化为判断长数组中该元素是否被短数组包含

```java
    public int[] shortestSeq(int[] big, int[] small) {
        //1.把[left,right]称为一个窗口；
//2.先右移右指针扩大窗口，直到窗口中的数字满足small数组要求；
//3.满足要求时，停止增加right，转而增加left缩小窗口，直到不满足要求
//4.重复2,3步直到right走到big尽头


//set是用于判断之后的窗口中是否含有small中的元素
Set<Integer>smallmap=new HashSet<>();
Map<Integer,Integer>window=new HashMap<>();
for(int i:small)
smallmap.add(i);
int start=0,right=0,left=0,match=0,minlen= Integer.MAX_VALUE;
while(right<big.length){
    if(smallmap.contains(big[right])){
       //只有短数组包含了这个元素 才放进window中
        window.put(big[right],window.getOrDefault(big[right],0)+1);
//注意 因为短数组中元素各不相同，因此只要第一次出现的时候匹配个数加一就行了
        if(window.get(big[right])==1)
        match++;
    }
    //while循环中移动左指针直到不满足条件 即直到匹配的个数小于small中的个数
  while(match==small.length){
      //在这个循环中left右移
if(right-left<minlen){
    minlen=right-left;
    start=left;
}
//注意移动的时候要判断左指针指向的元素是否在small中，如果在small中则需要将window中该元素个数减一
if(smallmap.contains(big[left])){
       window.put(big[left],window.getOrDefault(big[left],0)-1);
       //因为之前的步骤中只要是small中出现的元素，window中数量都加上了1，所以一定存在该键，而且数量为0时表示Window窗口已经不存在该元素
       if(window.get(big[left])==0)
       match--;
}
//移动左指针
left++;
    }
    //在最外层循环最后右指针向右移动
    right++;
}
return minlen == Integer.MAX_VALUE? new int[]{}: new int[]{start,start+minlen};
    }
```

## [1156. 单字符重复子串的最大长度](https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/)

难度中等99

如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。

给你一个字符串 `text`，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。

 

**示例 1：**

```
输入：text = "ababa"
输出：3
```

**示例 2：**

```
输入：text = "aaabaaa"
输出：6
```



-----

方法一：

```java
   public int maxRepOpt1(String text) {
int[]num=new int[26];
for(int i=0;i<text.length();i++)
num[text.charAt(i)-'a']++;
int i = 0;
int maxlen=0;
//可以理解为，如果遇到了一个与当前字符不一样的字符，那么先跳过这个字符，继续遍历后面的字符，看后面的能否与当前字符相等
while(i<text.length()){
    int cur=i;
    while(i<text.length()&& text.charAt(i)==text.charAt(cur))
{
i++;
}
int next=i+1;
int len=0;
while(next<text.length()&&text.charAt(next)==text.charAt(cur)){
    next++;
    len++;
}
//注意这里长度还要加一，不然答案少一个，因为跳过了一个不同的字符，这个不同的字符是可以被交换掉的，但是要注意能否交换取决于这个字符出现的总次数是否会超，比如aaab这里是无法交换b的 也就是a最大出现次数也只有3次 而len+i-cur+1=4,所以还要取一个小的,
maxlen=Math.max(maxlen,Math.min(len+i-cur+1,num[text.charAt(cur)-'a']));
//if(i==cur) i++;
}
return maxlen;
    }
}
```

## [剑指 Offer II 016. 不含重复字符的最长子字符串](https://leetcode.cn/problems/wtcaE1/)

难度中等69

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长连续子字符串** 的长度。

 

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子字符串是 "abc"，所以其长度为 3。
```

-------

```java
    public int lengthOfLongestSubstring(String s) {
Set<Character>set=new HashSet<>();
        int left=0,right=0;
        int ans=0;
        if(s.length()==0) return 0;
        while(right<s.length())
        {
           
            char index=s.charAt(right);
            if(!set.contains(index)) {
                set.add(index);
                ans=Math.max(ans,right-left+1);
                right++;
                
            }else {
                while(set.contains(index))
                {
set.remove(s.charAt(left++));
                }
              //尤其注意这里不能只移动Right指针，因为Right指针的元素还没有加入进去
            //  right++;
            下面的这两句可以加也可以不加
            set.add(index);
            right++;
            }
    
        }
        return ans;
    }
```

## 滑动窗口+有序集合：值和下标差都在给定范围内

给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k 。

如果存在则返回 true，不存在返回 false。

 

示例 1：

输入：nums = [1,2,3,1], k = 3, t = 0
输出：true


----------------------------



![image-20230218150812058](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230218150812058.png)

我们可以使用有序集合来支持这些操作。

实现方面，我们在有序集合中查找大于等于 x-t的最小的元素 
y，如果 y 存在，且 y≤x+t，我们就找到了一对符合条件的元素。完成检查后，我们将 x 插入到有序集合中，如果有序集合中元素数量超过了 k，我们将有序集合中最早被插入的元素删除即可。

为了防止溢出，我们采用long来存储

```java
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
 TreeSet<Long>tree=new TreeSet<>();
 for(int i=0;i<nums.length;i++)
 {
       Long ceiling = tree.ceiling((long) nums[i] - (long) t);
       //还要判断这个数字是否小于nums[i]+t才行，因为Math.abs(a-b)<=t表示 a-b<t&&b-a<t
       //所以对于b来说，范围是[a-t,a+t]
     if(ceiling!=null&&ceiling<=(long)nums[i]+(long)t) return true;
     tree.add((long)nums[i]);
     if(i>=k)  tree.remove((long)nums[i-k]);
 }
return false;
    }
```

## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

难度中等1604

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```



--

```java
 public int minSubArrayLen(int target, int[] nums) {
     int left=0,right=0;
        int sum=0;
        int minlen=nums.length+1;
        while(right<nums.length)
        {
            sum+=nums[right];
            if(sum>=target) {
                minlen = Math.min(minlen, right - left + 1);
                while (sum >= target) {
                     minlen = Math.min(minlen, right - left + 1);
                    sum -= nums[left];
                    left++;
                }
            
            }
            right++;
        }
         return minlen==nums.length+1?0:minlen;
    }
```



# 模拟

## [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

难度简单1827

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

-------

```java
  public int romanToInt(String s) {
   Map<Character, Integer> symbolValues = new HashMap<Character, Integer>() {{
        put('I', 1);//先建立一个哈希表进行映射
        put('V', 5);
        put('X', 10);
        put('L', 50);
        put('C', 100);
        put('D', 500);
        put('M', 1000);
    }};
int num = 0;
for(int i =0;i < s.length();i++)
{
int value = symbolValues.get(s.charAt(i));
if(i < s.length()-1 && symbolValues.get(s.charAt(i+1))>value)//判断是IX 还是XI的情况，前者的话要减去1，后者加上1
num -=value;
else 
num +=value;
}
return num;

    }
```

## 【LeetCode - 362】敲击计数器

![image-20221006220008121](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221006220008121.png)



--------------------

思路：

使用一个队列用于存储敲击时的时间戳，定义一个变量 startIndex 作为队首元素值，即五分钟内的第一次敲击的时间戳；

  1、hit(timestamp)：

  如果 startIndex == -1，即此时 queue 没有任何元素，则当前 hit 就是第一次敲击，startIndex = timestamp；

  2、getHits(int timestamp)：

  五分钟内的边界是满足 timestamp - startIndex + 1 == 300。

  如果 timestamp - startIndex + 1 > 300，表明当前的 startIndex 是超出五分钟的。

  我们把队首元素删除，用新的队首去更新 startIndex，重新判断，循环往复，直到 timestamp - startIndex + 1 <= 300 或者队列为空。

  最终返回队列的元素个数。
```java
class HitCounter {
    Queue<Integer> queue;
    int startIndex = -1;    // 五分钟内的第一次敲击的时间戳，-1 表示没有元素

    /** Initialize your data structure here. */
    public HitCounter() {
        queue = new LinkedList<Integer>();
    }

    /** Record a hit.
     @param timestamp - The current timestamp (in seconds granularity). */
    public void hit(int timestamp) {
        if(startIndex == -1) {  // 当前没有元素，新敲击的作为第一个
            startIndex = timestamp;
        }
        queue.offer(timestamp);
    }

    /** Return the number of hits in the past 5 minutes.
     @param timestamp - The current timestamp (in seconds granularity). */
    public int getHits(int timestamp) {
        // 五分钟的临界值应该是 timestamp - startIndex + 1 == 300
        // 或者队列根本没有元素
        while (timestamp - startIndex >= 300 && !queue.isEmpty()) {
            // timestamp - startIndex >= 300 说明当前队首元素超过了5分钟，删除队首
            queue.poll();
            if(!queue.isEmpty()) {
                // 如果队列不为空，更新 startIndex 为新的队首
                startIndex = queue.peek();
            } else {
                // 如果队列为已经为空，则 startIndex 恢复成初始值
                startIndex = -1;
            }
        }
        return queue.size();
    }
}

```

## 力扣（LeetCode）311. 稀疏矩阵的乘法

题目描述：
给你两个 稀疏矩阵 A 和 B，请你返回 AB 的结果。你可以默认 A 的列数等于 B 的行数。
请仔细阅读下面的示例。
示例：
输入：
A = [
[ 1, 0, 0],
[-1, 0, 3]
]
B = [
[ 7, 0, 0 ],
[ 0, 0, 0 ],
[ 0, 0, 1 ]

]

------

方法一：直接全部相乘

方法二：1）既然稀疏矩阵中的大部分元素是0，而0的乘法是可以忽略的，故可以先对两个数组中的非零元素进行统计，获得非零元素的位置，然后再在乘法中，只处理这些非零元素即可；

网上的c++版：

```java
class Solution {
public:
    vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {
        vector<vector<int>> res(A.size(),vector<int>(B[0].size()));
        //统计数组A中的非零元素
        vector<vector<int>> A_tmp(A.size());
        for(int i=0;i<A.size();++i){
            for(int j=0;j<A[0].size();++j){
                if(A[i][j]){
                    A_tmp[i].push_back(j);
                }
            }
        }
        //统计数组B中的非零元素
        vector<vector<int>> B_tmp(B[0].size());
        for(int i=0;i<B[0].size();++i){
            for(int j=0;j<B.size();++j){
                if(B[j][i]){
                    B_tmp[i].push_back(j);
                }
            }
        }
		//处理矩阵的乘法
        for(int i=0;i<A.size();++i){
            for(int j=0;j<B[0].size();++j){
            	//使用非零元素较少的数组来实现乘法
                if(A_tmp[i].size()<B_tmp[j].size()){
                    for(int&k:A_tmp[i]){
                        res[i][j]+=A[i][k]*B[k][j];
                    }
                }
                else{
                    for(int&k:B_tmp[j]){
                        res[i][j]+=A[i][k]*B[k][j];
                    }
                }
            }
        }
        //返回结果
        return res;
    }
};

```

自己写的Java版：

```java
int[][] multiply(List<List<Integer>> A, List<List<Integer>> B) {
        List<List<Integer>>tempA=new ArrayList<>();
        List<List<Integer>>tempB=new ArrayList<>();
        List<List<Integer>>ans=new ArrayList<>();
        int[][]array=new int[A.size()][B.get(0).size()];
        for (int j = 0; j < A.size(); j++) {
            tempA.add(new ArrayList<>());
        }
        for(int i=0;i<A.size();i++)
        {
            for (int j = 0; j < A.get(i).size(); j++) {
                if(A.get(i).get(j)!=0){
                    tempA.get(i).add(j);
                }
            }
        }
        for (int j = 0; j < B.get(0).size(); j++) {
            tempB.add(new ArrayList<>());
        }
        for(int i=0;i<B.get(0).size();i++)
        {
            for (int j = 0; j < B.size(); j++) {
                if(A.get(j).get(i)!=0){
                    tempB.get(i).add(j);
                }
            }
        }
        for (int i = 0; i < tempA.size(); i++) {
            for (int j = 0; j < tempB.size(); j++) {
                //使用非零元素较少的数组来实现乘法
                if(tempA.get(i).size()<tempB.get(j).size())
for(int numA:tempA.get(i))
{
    array[i][j]=A.get(i).get(numA)*tempB.get(numA).get(j);
}
else{
                    for(int numB:tempB.get(i))
                    {
                        array[i][j]=A.get(i).get(numB)*tempB.get(numB).get(j);
                    }
                }
            }
        }
        return array;
    }
```



## 思维转化：[453. 最小操作次数使数组元素相等](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/)

#### 

难度中等510

给你一个长度为 `n` 的整数数组，每次操作将会使 `n - 1` 个元素增加 `1` 。返回让数组所有元素相等的最小操作次数。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：3
解释：
只需要3次操作（注意每次操作会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```

-----

```java
 //因为只需要找出让数组所有元素相等的最小操作次数，所以我们不需要考虑数组中各个元素的绝对大小，即不需要真正算出数组中所有元素相等时的元素值，只需要考虑数组中元素相对大小的变化即可。
//因此，每次操作既可以理解为使 n−1 个元素增加 1，也可以理解使 1 个元素减少 1。显然，后者更利于我们的计算。于是，要计算让数组中所有元素相等的操作数，我们只需要计算将数组中所有元素都减少到数组中元素最小值所需的操作数
    public int minMoves(int[] nums) {
int sum=0;
int min=Integer.MAX_VALUE;
for(int i:nums)
min=Math.min(min,i);
for(int i=0;i<nums.length;i++)
sum+=nums[i]-min;
return sum;
    }
```



# 双指针问题

寻找链表的倒数第 k 个元素
我们的思路还是使⽤快慢指针，让快指针先⾛ k 步，然后快慢指针开始同速前进。这样当快指针⾛到链表末尾 null 时，慢指针所在的位置就是倒数第 k个链表节点（为了简化，假设 k 不会超过链表⻓度）：

```java
ListNode slow, fast;
slow = fast = head;
while (k-- > 0)
fast = fast.next;
while (fast != null) {
slow = slow.next;
fast = fast.next;
}
return slow;
```



左右指针的常⽤算法
左右指针在数组中实际是指两个索引值，⼀般初始化为 left = 0, right =
nums.length - 1 。

反转数组

```java
void reverse(int[] nums) {
int left = 0;
int right = nums.length - 1;
while (left < right) {
// swap(nums[left], nums[right])
int temp = nums[left];
nums[left] = nums[right];
nums[right] = temp;
left++; right--;
}
}
```

## [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

难度中等3163

给你 `n` 个非负整数 `a1，a2，...，a``n`，每个数代表坐标中的一个点 `(i, ai)` 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 `(i, ai)` 和 `(i, 0)` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

![image-20220208135353130](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220208135353130.png)

------

![image-20220208135456347](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220208135456347.png)



```java
 public int maxArea(int[] height) {
    int maxtotal=0;
    int i=0,j=height.length-1;
    while(i<j)
    {
        int min=Math.min(height[i],height[j]);
        maxtotal = Math.max(min*(j-i),maxtotal);
        if(height[i]<height[j]) i++;
        else j--;
    }

return maxtotal;
    }
```

## [611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

难度中等349

给定一个包含非负整数的数组 `nums` ，返回其中可以组成三角形三条边的三元组个数。

 

**示例 1:**

```
输入: nums = [2,2,3,4]
输出: 3
解释:有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```

---

最普通：暴力枚举法，这种情况下时间复杂度n3

![image-20220221192820177](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220221192820177.png)

改进办法：排序+双指针

![image-20220221192914960](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220221192914960.png)

```java
public int triangleNumber(int[] nums) {
Arrays.sort(nums);
used = new boolean[nums.length];
for(int i = nums.length-1;i >=0;i--)//双指针，两大一小
for(int j = i-1,k=0;k<j;j--)
{
    while(k<j&&nums[k]+nums[j]<=nums[i])
    k++;
    tot+=j-k;//k~j之间的均满足条件
}
return tot;
    }
```

## [80. 原地删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

难度中等666

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **最多出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

------

```java
 public int removeDuplicates(int[] nums) {
int tot = 0;
 int numbers = 0;
if(nums.length<2) return nums.length;
int fast = 2,slow=2;
while(fast < nums.length)
{
    if(nums[fast] != nums[slow-2])//这里是与slow-2比较
    {
        nums[slow] = nums[fast];//注意这里的slow不是刚刚被比较的slow-2,slow是第一个重复个数大于2的下标或者是一个出现一次的数下标
slow++;
    }
    fast++;
}
return slow;
    }
```

## 918 · 三数之和小于



描述

给定一个`n`个整数的数组和一个`目标整数target`，找到下标为`i、j、k`的数组元素`0 <= i < j < k < n`，满足条件`nums[i] + nums[j] + nums[k] < target`.

---------------------



套路：这种三数之和问题，如果可以排序的话先进行排序，再遍历其中一个元素，对其余元素进行双指针遍历，这里题中虽然提到了索引，但是其实和索引并无关系，可以排完序再进行判断。

```java
 public int threeSumSmaller(int[] nums, int target) {
        // Write your code here
         int ans = 0;
         Arrays.sort(nums);
        for (int i = 0; i < nums.length-2; i++) {
        
            int left = i+1,right = nums.length-1;
            while(left < right){
               if(nums[left]+nums[i]+nums[right]<target) {
                   ans+=right-left;
               left++;
               }
               else right--;

            }

        }
        return ans;
    }
```

## 三数之和等于0

求一个数组中所有三数之和等于0的三元组

时间复杂度on2

```java
public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
        Arrays.sort(num);
        ArrayList<ArrayList<Integer>> ans=new ArrayList<>();
        if(num.length<3)  return ans;
        for(int i=0;i<num.length-2;i++)
        {
            //要加这一步判断，不然会重复
              if(i != 0 && num[i] == num[i - 1])
                continue;
         int l=i+1,r=num.length-1;
         while(l<r)
         {
            if(num[l]+num[r]==-num[i]){
                ArrayList<Integer>temp=new ArrayList<Integer>();

                temp.add(num[i]);
 temp.add(num[l]);
  temp.add(num[r]);
  ans.add(temp);
  //去重
while(num[l]==num[l+1]&&l+1<r) l++;
while(num[r]==num[r-1]&&r-1>l) r--; 
            l++;
            r--;
            } 
else if(num[l]+num[r]+num[i]>0)
r--;
else l++;
         }
        }
return ans;
    }
```



## [457. 环形数组是否存在循环](https://leetcode.cn/problems/circular-array-loop/)

难度中等197

存在一个不含 `0` 的 **环形** 数组 `nums` ，每个 `nums[i]` 都表示位于下标 `i` 的角色应该向前或向后移动的下标个数：

- 如果 `nums[i]` 是正数，**向前**（下标递增方向）移动 `|nums[i]|` 步
- 如果 `nums[i]` 是负数，**向后**（下标递减方向）移动 `|nums[i]|` 步

因为数组是 **环形** 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。

数组中的 **循环** 由长度为 `k` 的下标序列 `seq` 标识：

- 遵循上述移动规则将导致一组重复下标序列 `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`
- 所有 `nums[seq[j]]` 应当不是 **全正** 就是 **全负**
- `k > 1`

如果 `nums` 中存在循环，返回 `true` ；否则，返回 `false` 。

-----------------

![image-20221213214625498](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221213214625498.png)

题难点在于题目的两个限制条件：


在每次循环的过程中，必须保证所经历过的所有数字都是同号的。
那么，在快指针经历过的每个位置都要判断一下和出发点的数字是不是相同的符号。
当快慢指针相遇的时候，还要判断环的大小不是 1。
所以，找到相遇点的位置后，如果再走 1 步，判断是不是自己。



```java
 public boolean circularArrayLoop(int[] nums) {
   int len = nums.length;
        for (int i = 0; i < nums.length; i++)
        {
        if(nums[i]==0) continue;
        int slow = i,fast = next(nums,i);
        while(nums[slow]*nums[fast]>0 && nums[slow]*nums[next(nums,fast)]>0){
            if(slow == fast){
                if(slow != next(nums,slow)){
                    return true;
                }
                else {
                    break;
                }
            }
            slow = next(nums,slow);
            fast = next(nums,next(nums,fast));
        }
        int add = i;
        while(nums[add]*nums[next(nums,add)]>0){
            int temp = add;
            add = next(nums,add);
            nums[temp] = 0;
        }
        }
        return false;
    }
    public int next(int[]nums,int n){
        int len = nums.length ;
        //这里必须得加上len,因为不加len的话，负数模正数为一个负数，会使得结果为负数,这里要让返回结果在[0,len)之间
        return ((n+nums[n])%len+len)%len;
    }
```

关于环形链表的问题：

![image-20221213215704160](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221213215704160.png)

## 回文子串的个数



![image-20230212234148204](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230212234148204.png)

![image-20230212234425336](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230212234425336.png) 

注意这里，如果是奇数那么回文中心是中间的数，如果是偶数那么则是中间的两个数

```java
  public int countSubstrings(String s) {

int ans=0;
//这里可以发现，0和1除以2的结果都是0，2和3除以2的结果都是1，只是模2的值不一样
//相当于中心是这样：先第一个 然后第一个第二个 然后第二个 然后第二个第三个 
for(int i=0;i<2*s.length()+1;i++)
{//一共可以有2*N-1个中心
    int left=i/2,right=i/2+i%2;
    while(left>=0&&right<s.length()&&s.charAt(left)==s.charAt(right))
    {
        ans++;
        left--;
        right++;
    }
}
return ans;
    }
```

## 判断一个字符串能否删除一些字母得到另一个字符串

[524. 通过删除字母匹配到字典里最长单词](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/)

难度中等330

给你一个字符串 `s` 和一个字符串数组 `dictionary` ，找出并返回 `dictionary` 中最长的字符串，该字符串可以通过删除 `s` 中的某些字符得到。

如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。

 

**示例 1：**

```
输入：s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]
输出："apple"
```



------

这里可以用双指针，两个字符串比较，如果匹配上了都向前移动，否则只移动那个原来的s

可以先排序再计算

```java
 public String findLongestWord(String s, List<String> dictionary) {
 String res = "";
 Collections.sort(dictionary,new Comparator<String>() {
    @Override
    public int compare(String o1, String o2) {
        if(o1.length()<o2.length()) return o2.length()-o1.length();
        if(o1.length()>o2.length()) return o2.length()-o1.length();
     else return o1.compareTo(o2);
    }
});
        for (String t : dictionary) {
            int i = 0, j = 0;
            while (i < t.length() && j < s.length()) {
                if (t.charAt(i) == s.charAt(j)) {
                    ++i;
                }
                ++j;
            }
            if (i == t.length()) {
              res=t;break;
            }
        }
        return res;
    }

```

 也可以不排序，直接维护这个答案字符串：

```java
 public String findLongestWord(String s, List<String> dictionary) {
 String res = "";

        for (String t : dictionary) {
            int i = 0, j = 0;
            while (i < t.length() && j < s.length()) {
                if (t.charAt(i) == s.charAt(j)) {
                    ++i;
                }
                ++j;
            }
            if (i == t.length()) {
            if(t.length()>res.length()|| (t.length() == res.length() && t.compareTo(res) < 0))
            res=t;
            }
        }
        return res;
    }
```



# 位运算

⼏个有趣的位操作
1. 利⽤或操作 | 和空格将英⽂字符转换为⼩写
('a' | ' ') = 'a'
('A' | ' ') = 'a'
1. 利⽤与操作 & 和下划线将英⽂字符转换为⼤写
('b' & '_') = 'B'
('B' & '_') = 'B'
1. 利⽤异或操作 ^ 和空格进⾏英⽂字符⼤⼩写互换
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'

**算法常⽤操作 n&(n-1)**

作⽤是消除数字 n 的⼆进制表⽰中的最后⼀个1

如果让你返回 n 的⼆进制表⽰中有⼏个 1：

因为 n & (n - 1) 可以消除最后⼀
个 1，所以可以⽤⼀个循环不停地消除 1 同时计数，直到 n 变成 0 为⽌。

```c
int hammingWeight(uint32_t n) {
int res = 0;
while (n != 0) {
n = n & (n - 1);
res++;
}
return res;
}
```

**判断⼀个数是不是 2 的指数**

⼀个数如果是 2 的指数，那么它的⼆进制表⽰⼀定只含有⼀个 1：
2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100

如果使⽤位运算技巧就很简单了（注意运算符优先级，括号不可以省略）：
bool isPowerOfTwo(int n) {
if (n <= 0) return false;
return (n & (n - 1)) == 0;
}

对于异或运算（ ^ ），我们知道它有⼀个特殊性质：⼀个数和它本⾝做异
或运算结果为 0，⼀个数和 0 做异或运算还是它本⾝。
⽽且异或运算满⾜交换律和结合律，也就是说：
2 ^ 3 ^ 2 = 3 ^ (2 ^ 2) = 3 ^ 0 = 3

## [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

难度简单241

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 [汉明重量](http://en.wikipedia.org/wiki/Hamming_weight)).）。

 

**提示：**

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用 [二进制补码](https://baike.baidu.com/item/二进制补码/5295284) 记法来表示有符号整数。因此，在上面的 **示例 3** 中，输入表示有符号整数 `-3`。

 

**示例 1：**

```
输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

-----------

循环检测二进制位，将输入的数字与2的i次方进行与运算，得到结果

```java
    public int hammingWeight(int n) {

        int ans = 0;
for(int i = 0;i <32;i++)
{
if((n &(1<<i)) !=0)
ans++;
}
        return ans;
    }
```





## 位1的个数



![image-20211212171351327](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211212171351327.png)

![image-20211212171658613](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211212171658613.png)

![image-20211212171849488](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211212171849488.png)

```java
 public int[] countBits(int n) {

 int[]nums = new int[n+1];
        for (int i = 0; i <= n; i++) {
            nums[i] = countOne(i);

        }
        return nums;
    }

    private int countOne(int i) {
        int ones = 0;
        while(i >0)
        {
            i &= (i-1);
            ones++;
        }
        return ones;
    }
```

## 十进制转16进制

注：输入有正数有负数，负数用补码计算



-----

![image-20220208172852708](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220208172852708.png)

```java
   public String toHex(int num) {
char[]arr=new char[]{'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
String ans="";
char digit;
if(num==0) return "0";
long longnum;
for(int i=7;i>=0;i--)
{
    int value=(num>>4*i)&0xf;
    if(ans.length()>0||value>0)
  {  digit=value<10?(char)(value+'0'):(char)(value-10+'a');
    ans+=digit;
  }
}



return  ans;
    }
```

## 不用加号的加法

![image-20220208181543309](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220208181543309.png)

```java
    public int add(int a, int b) {
int m=a^b;
int n=(a&b)<<1;
while(n!=0)
{
    int temp=m^n;
    n=(m&n)<<1;
    m=temp;
}
return m;
    }
}
```



使用位运算(x >> i) & 1 得到 x的第 i 个二进制位。



异或运算

异或（XOR）”运算符“^”，其规则是“如果A和B不相同，则A^B为1，否则为0”。异或运算最重要的性质就是“开关性”——异或两次以后相当于没有异或，即A^B^B=A。另外，与、或和异或都满足交换律：A&B=B&A，A|B=B|A，A^B=B^A。

当用二进制表示子集时，位运算中的按位与、或、异或对应集合的交、并和对称差。





## 1.不使用额外空间交换两个数：

```java
public void swap(int a,int b)
{
    a = a ^b;
    b = a^b;
    a = a^b; //异或运算满足交换律，如b = a ^b ^b,得到的结果是a
}
```

2.求出一个int类型数字最右侧的1：

**a & (~a+1) 也即 a &(-a)**

a取反+1再和a相与

3.一个数组中有一个数出现k次，其他数都出现m次



4.一个数组中有两个数出现了奇数次，其他出现了偶数次

（左程云b站：异或相关面试题 第58分）

![image-20211202201705846](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211202201705846.png)

对一个数组来说，假设其中a与b出现了奇数次，eor ^ 每个数字得到的结果是a ^b,而eor & (-eor)得到的是最右侧的1，即rightone,用arr中的每个数字与rightone相与，则可以分为两类，一类是rightone最右侧的1这个位置上数字是1，一类是这个位置是0，且由于rightone是a b异或以后得到的，所以这个位置上a b必然不一样（一个是1 一个是0），这样相当于把arr又分为了两类，一类是a类，一类是b类，把a类与一个新的变量onlyone异或则可以得到a

可参考力扣第260题：

![image-20220215230856942](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220215230856942.png)

代码

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int xorsum = 0;
        for (int num : nums) {
            xorsum ^= num;
        }
        // 防止溢出
        int lsb = (xorsum == Integer.MIN_VALUE ? xorsum : xorsum & (-xorsum));//按位取反也可写成~x+1
        int type1 = 0, type2 = 0;
        for (int num : nums) {
            if ((num & lsb) != 0) {
                type1 ^= num;
            } else {
                type2 ^= num;
            }
        }
        return new int[]{type1, type2};
    }
}


```



## [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

难度中等800

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

----



 ```java
  public int singleNumber(int[] nums) {
         int ans = 0;
 for(int i = 0;i < 32;i++)//32位整数
 {
     int tot=0;//每一位上的1有多少个
     for(int num:nums)
     {
         tot+=(num>>i)&1;
     }
     if(tot %3!=0)
     ans = ans|(1<<i);
 }
 return ans;
     }
 ```

## [有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

难度中等493

给你一个仅由整数组成的**有序数组**，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。

----------

注意条件：有序数组且时间复杂度logn,这里可以认为相等的数字必须相邻，找到那个“中间”的数

初始时，二分查找的左边界是 00，右边界是数组的最大下标。每次取左右边界的平均值mid 作为待判断的下标，根据mid 的奇偶性决定和左边或右边的相邻元素比较：

如果mid 是偶数，则比较nums[mid] 和nums[mid+1] 是否相等；

如果mid 是奇数，则比较nums[mid−1] 和 nums[mid] 是否相等。

如果上述比较相邻元素的结果是相等，则mid<x，调整左边界，否则mid≥x，调整右边界。调整边界之后继续二分查找，直到确定下标 xx 的值。

得到下标 xx 的值之后，nums[x] 即为只出现一次的元素。



```java
 public int singleNonDuplicate(int[] nums) {
int low= 0,high = nums.length-1;
while(low < high)
{
    int mid =(low +high)/2;
    //if(nums[mid] == nums[mid^1] )//这里不能用nums[mid]==nums[mid+1]判断，会出错 如果mid=mid^1说明
if((nums[mid]==nums[mid+1] && mid %2==0)||(mid > 0 &&nums[mid]==nums[mid-1] && mid %2==1))
    low = mid+1;
    
    else 
    high = mid;
}
return nums[low];
    }
```



## [剑指 Offer 56 - I. 两个只出现一次的数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

难度中等543

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

-----

让我们先来考虑一个比较简单的问题：

如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？

答案很简单：全员进行异或操作即可。考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。

那么这一方法如何扩展到找出两个出现一次的数字呢？

如果我们可以把所有数字分成两组，使得：

两个只出现一次的数字在不同的组中；

相同的数字会被分到相同的组中。

那么对两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。

步骤：

先对所有数字进行一次异或，得到两个出现一次的数字的异或值。

在异或结果中找到任意为 1 的位。

根据这一位对所有的数字进行分组。

在每个组内进行异或操作，得到两个数字

-----

```java
 public int[] singleNumbers(int[] nums) {

int ans = 0;
for(int num:nums)
ans = (ans ^ num);//最后的结果是两个出现次数为1的异或，比如4^6
int a=0,b= 0;
int div = 1;
while((ans & div)==0)//4^6=010,010&1=0->1左移，010&010 = 1，4与6之中只有一个在这一位上是1
div = (div <<1);//找到一个最低为1的位，比如4是100 6是110,最低是第二位的1
for(int i:nums)
{
    if((i&div) ==0)//nums中的每个数与
    a = a^i;
    else b = b^i;//相当于分为两组，一组是第二位有1 一组是第二位没1
}
return new int[]{a,b};
    }
```





## 一个数组中只有一个数字出现k次，其他数字都出现了m次



```java
  public static int onlyKTimes(int[]arr,int k,int m)
    {
        int[]times = new int[32];//int类型为32位长度
        for(int theNum:arr)
        {
            //遍历arr中的所有数字
            for (int i = 0; i < 32; i++) {
               times[i]+=(theNum >> i) &1;//theNum向右移动i位，再与1相与，表示这个位置上如果是1，则times[i]的次数加一
                //times[0]：第0位置的1出现了几次times[i]:第i位置的1出现了几次times
                //出现了m次的数，则times[i]一定是m的整数倍
            }
        }
        int ans = 0;//ans是答案 即出现了k次的数字
        for (int i = 0; i < 32; i++) {
            //现在开始遍历数组times
            if(times[i] % m != 0)
            {
                //如果times[i]%m不是0，则说明出现了k次的数字在这个i位置上是1
                ans |= (1 << i);//将1左移i位再与答案相或，即可让答案数字的第i位变成1
            }

        }
        return ans;
    }

    public static void main(String[] args) {

        int arr[] = new int[]{1,1,1,3,3,3,4,4};//2出现了2次
        System.out.println(onlyKTimes(arr,2,3));
    }
}
```



## 找到只出现一次的数

一个数组，其他的的元素都出现了两次，只有一个元素出现了一次，找到这个数

---

采用位运算，用异或操作，剩下的即结果

```java
 public int singleNumber(int[] nums) {
        int sing=0;
for(int i =0;i<nums.length;i++)
{
    sing ^=nums[i];
}
return sing;
    }
```

## [393. UTF-8 编码验证](https://leetcode.cn/problems/utf-8-validation/)

难度中等175

给定一个表示数据的整数数组 `data` ，返回它是否为有效的 **UTF-8** 编码。

**UTF-8** 中的一个字符可能的长度为 **1 到 4 字节**，遵循以下的规则：

1. 对于 **1 字节** 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。
2. 对于 **n 字节** 的字符 (n > 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。

这是 UTF-8 编码的工作方式：

```
      Number of Bytes  |        UTF-8 octet sequence
                       |              (binary)
   --------------------+---------------------------------------------
            1          | 0xxxxxxx
            2          | 110xxxxx 10xxxxxx
            3          | 1110xxxx 10xxxxxx 10xxxxxx
            4          | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

`x` 表示二进制形式的一位，可以是 `0` 或 `1`。

**注意：**输入是整数数组。只有每个整数的 **最低 8 个有效位** 用来存储数据。这意味着每个整数只表示 1 字节的数据。

----------------------

这里有一个技术点：如果判断一个数字的二进制开头几位是否为1，可以直接用与运算，因为底层都是转化为二进制进行的，并且用1<<n表示2的n次方，比如说9的二进制是1001，和1<<3进行与运算,就可以得到最高位是不是1了

比较是否是10，可以用最高位是11的数和目标数进行与运算

用 mm 表示 \textit{data}data 的长度，用index 表示UTF-8 字符的头字节在data 中的下标，初始时



index=0。对于每个字符，执行如下操作。

头字节包含了当前字符的字节数信息，根据头字节计算当前字符字节数的方法如下。

如果头字节的最高位是 00，则当前字符由 11 个字节组成，只有头字节，没有其余字节。

如果头字节的最高位是 11，则计算头字节从最高位开始的连续 11 的个数。如果连续 11 的个数为 22 个到 44 个，则连续 11 的个数表示当前字符的字节数；否则头字节不符合 \text{UTF-8}UTF-8 编码的规则，\textit{data}data 不是有效的 \text{UTF-8}UTF-8 编码。

当头字节符合 \text{UTF-8}UTF-8 编码的规则时，根据头字节得到当前字符的字节数为 nn，则当前字符包括头字节和 n - 1n−1 个其余字节。如果 \textit{data}data 在头字节后面的字节数小于 n - 1n−1，即 \textit{index} + n > mindex+n>m，则 \textit{data}data 不是有效的 \text{UTF-8}UTF-8 编码。

当data 在头字节后面的字节数大于等于 n - 1n−1 时，头字节后面的 n - 1n−1 个字节为当前字符的其余字节。判断每个其余字节的最高两位是否是 1010，如果存在一个其余字节的最高两位不是 1010，则data 不是有效的UTF-8 编码。

当前字符遍历结束之后，将index 的值加 n，则更新后的 index 是下一个字符的头字节在 data 中的下标。

重复上述操作，直到 index=n 时遍历结束，此时data 是有效的 \UTF-8 编码。



代码：

```java
  int mask2=(1<<7)+(1<<6);
    int mask1=(1<<7);
    public boolean validUtf8(int[] data) {

  int m = data.length;
        int index = 0;
 
        while (index < m) {
            int num = data[index];
            int n = getNum(num);
            if (n < 0 || index + n > m) {
                return false;
            }
            for (int i = 1; i < n; i++) {
                if (!valid(data[index + i])) {
                    return false;
                }
            }
            index += n;
        }
        return true;


    }
    public int getNum(int number){
        int mask=mask1;
        if((number &mask)==0)return 1;
        int n =0;
        while((number & mask)!=0){
            n++;
            mask>>=1;
            if(n>4)return -1;
        }
        return n>=2?n:-1;
    }
    public boolean valid(int n){
        return (n&mask2)==mask1;
    }
```

## [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

难度中等387

在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

 

**示例 1：**

```
输入：nums = [3,4,3,3]
输出：4
```

-------------------



![image-20220916213230308](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220916213230308.png)

```java
 public int singleNumber(int[] nums) {
 int[] counts = new int[32];
        for (int i = 0; i < nums.length; i++) {
            for (int j = 31; j >=0; j--) {
                //注意这里31开始，因为数组的第31位其实就是最低位，这里不要弄错了，这个count数组是每一位上的数字总和
                counts[j]+=nums[i]&1;
                nums[i]=nums[i]>>1;
            }

        }
        int res = 0;
        for (int i = 0; i < counts.length; i++) {
            //先左移再异或，恢复每个位数上的数字，记得要模3
            res <<=1;
            res = res|counts[i]%3;
        }
        return res;
    }
```

## 高效判断两个字符串是否有相同字母

思路1：用一个map记录字母和出现次数，先遍历其中一个次数加一，然后遍历另一个次数减一，如果出现某个键的次数为0则存在相同字母

方法二：位运算，使用或运算得到一个整数，然后将这个整数与另一个整数相与

```java
String[] words
int[]arr=new int[words.length];
        for(int i =0;i<words.length;i++){
            int sum=0;
            for(int j = 0;j<words[i].length();j++)
            sum|=1<<(words[i].charAt(j)-'0');
            arr[i]=sum;
        }
```



## IP地址与int整数的转换

给你一例如，ip地址为10.0.3.193，把每段拆分成一个二进制形式组合起来为`00001010 00000000 00000011 11000001`，然后把这个二进制数转变成十进制整数就是167773121。



解答：

借助位运算实现。如IP 10.0.3.193，将10左移24位，0左移16位，3左移8位，193左移0位。4个seg`或运算`，即为结果。

也可以用加法运算实现，但是因为会溢出要用long:

```java
 public static long ipToTen(String str)
    {
        String[]line=str.split("\\.");
         long ans=0;
         int begin=24;
         for(String s:line)
         {
ans+=((long)Integer.valueOf(s)<<begin);
begin-=8;
         }
         return ans;
    }
用或运算：
     public static long ipToTen(String str)
    {
        String[]line=str.split("\\.");
         long ans=0;
         int begin=24;
         for(String s:line)
         {
ans=ans<<8|Integer.valueOf(s);

         }
         return ans;
    }
```



我们再来看一下如何将整数转成IP。将整数和255做`与运算`，结果为IP的第4段。整数右移8位，和255做`与运算`的结果就是IP的第3段...最后再将每轮与运算的结果拼接起来便是最终的IP地址

```c++
string intToIp(unsigned num) {
    vector<string> ipList;
    string res = "";
    for(int i = 0; i < 4; i ++) {
        string seg = to_string(num & 255);
        ipList.push_back(seg);
        num = num >> 8;
    }
    reverse(ipList.begin(), ipList.end());
    for(int i = 0; i < 4; i ++) {
        if(i == 3) res += ipList[i];
        else res += ipList[i] + '.';
    }
    return res;
}
或者这样写：
       public static String tenToIp(String str)
       {
long num=Long.valueOf(str);
int begin=24;
int n=8;
StringBuilder sb=new StringBuilder();
for(int i=24;i>=0;i=i-8)
{
sb.append(String.valueOf((num&(0xff<<i))>>i)).append(".");
}
sb.deleteCharAt(sb.length()-1);
return sb.toString();
       }
```





## [338. 比特位计数](https://leetcode.cn/problems/counting-bits/)

难度简单1141

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

 

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```



--------------------------

加入一个数字num,比他小的最大的2的幂次方为high,则有num比num-high只多了1个比特位，**这里有一个巧妙判断一个数字是否是2的幂次方的方法：i&i-1 是否为0**，所以用位运算+动态规划的思想是最快的

```java
 public int[] countBits(int n) {
int[]ans=new int[n+1];
ans[0]=0;
int highbit=0;
for(int i = 1;i<=n;i++){
if((i&i-1)==0)
highbit=i;

//21=16+5 可以说21比5只多了1个比特位，所以用这种动态规划的思想。
ans[i]=ans[i-highbit]+1;
}
return ans;
    }
```

## [剑指 Offer II 001. 整数除法](https://leetcode.cn/problems/xoh6Oh/)

难度简单220

给定两个整数 `a` 和 `b` ，求它们的除法的商 `a/b` ，要求不得使用乘号 `'*'`、除号 `'/'` 以及求余符号 `'%'` 。

 

**注意：**

- 整数除法的结果应当截去（`truncate`）其小数部分，例如：`truncate(8.345) = 8` 以及 `truncate(-2.7335) = -2`
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 `[−231, 231−1]`。本题中，如果除法结果溢出，则返回 `231 − 1`

 

**示例 1：**

```
输入：a = 15, b = 2
输出：7
解释：15/2 = truncate(7.5) = 7
```

-----

一种用位运算的方法：

```java
 public int divide(int a, int b) {
        //这里已经把-2147483648和-1的情况返回了
           if (a == Integer.MIN_VALUE && b == -1)
        return Integer.MAX_VALUE;

int res=0;
 int sign = (a > 0) ^ (b > 0) ? -1 : 1;
a=Math.abs(a);
b=Math.abs(b);

    for(int i=31;i>=0;i--)
    {
        //相当于a/2的i次方-b>0  

        // 注意，这里不能是 (a >>> i) >= b 而应该是 (a >>> i) - b >= 0
        // 这个也是为了避免 b = -2147483648，如果 b = -2147483648
        // 那么 (a >>> i) >= b 永远为 true，但是 (a >>> i) - b >= 0 为 false
        //这里不能是a>>i,而是无符号的>>>， >>表示右移，如果该数为正，则高位补0，若为负数，则高位补1， >>>表示 无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0
        if((a>>>i)-b>=0)
        {a-=(b<<i);
        //这里不用res+1<<i可以防止溢出，因为加法更大
         if (res > Integer.MAX_VALUE - (1 << i)) {
                return Integer.MIN_VALUE;
            }
        res+=(1<<i);
        }
    
}
    return sign == 1 ? res : -res;
    }
```

或者把变量都变为long:

```java
  public int divide(int a, int b) {
        //这里已经把-2147483648和-1的情况返回了
           if (a == Integer.MIN_VALUE && b == -1)
        return Integer.MAX_VALUE;

int res=0;
 int sign = (a > 0) ^ (b > 0) ? -1 : 1;
 long la=a,lb=b;
 long aa=la<0?-la:la,bb=lb<0?-lb:lb;


    for(int i=31;i>=0;i--)
    {
 //这里不能aa=aa-(aa>>i)
         if(aa>=(bb<<i))
        {
            aa-=(bb<<i);
        res+=(1<<i);
        }
    
}
    return sign == 1 ? res : -res;
    }
```

## 求一段区间内1的个数最多的数

求一段区间内，转为二进制时1个数最多的数：

用异或运算，先获得所有2的幂次方，比如2的0次方1,2的1次方10 2的2次方100，每次都是1左移，然后再将区间左端点进行异或这些2的幂次方用于添加一个1，直到大于右端点

```java
 int[]bin=new int[60];
        bin[0]=1;
        for (int i = 1; i < 60; i++) {
            bin[i]=bin[i-1]<<1;
        }
        //l:左端点 每异或一次，这个数当中的1的个数就多了一个
            long l=in.nextLong();
            long r=in.nextLong();
            for (int i = 0; i < 60; i++) {
                if((l|bin[i])<=r) l|=bin[i];
                  else break;
            }
            System.out.println(l+" "+cal(l));
            q--;
        
```



# 动态规划问题套路

先看下题⽬：给你 k 种⾯值的硬币，⾯值分别为 c1, c2 ... ck ，每种硬
币的数量⽆限，再给⼀个总⾦额 amount ，问你最少需要⼏枚硬币凑出这个
⾦额，如果不可能凑出，算法返回 -1 。算法的函数签名如下

// coins 中是可选硬币⾯值，amount 是⽬标⾦额
int coinChange(int[] coins, int amount);

⽐如说 k = 3 ，⾯值分别为 1，2，5，总⾦额 amount = 11 。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。



⾸先，这个问题是动态规划问题，因为它具有「最优⼦结构」的。要符合
「最优⼦结构」，⼦问题间必须互相独⽴。啥叫相互独⽴？你肯定不想看数
学证明，我⽤⼀个直观的例⼦来讲解。
⽐如说，你的原问题是考出最⾼的总成绩，那么你的⼦问题就是要把语⽂考
到最⾼，数学考到最⾼…… 为了每门课考到最⾼，你要把每门课相应的选
择题分数拿到最⾼，填空题分数拿到最⾼…… 当然，最终就是你每门课都
是满分，这就是最⾼的总成绩。

回到凑零钱问题，为什么说它符合最优⼦结构呢？⽐如你想求 amount =11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（⼦问题），你只需要把⼦问题的答案加⼀（再选⼀枚⾯值为 1 的硬币）就是原问题的答案，因为硬币的数量是没有限制的，⼦问题之间没有相互制，是互相独⽴的明确 base case，显然⽬标⾦额为 0 时，所需硬币数量为 0；当⽬标⾦额⼩于 0 时，⽆解，返回 -1：

![](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210824222340149.png)

时间复杂度分析：⼦问题总数 x 每个⼦问题的时间。
⼦问题总数为递归树节点个数，这个⽐较难看出来，是 O(n^k)，总之是指数级别的。每个⼦问题中含有⼀个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。
2、带备忘录的递归
只需要稍加修改，就可以通过备忘录消除⼦问题：
def coinChange(coins: List[int], amount: int):

![image-20210824222517094](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210824222517094.png)

，很显然「备忘录」⼤⼤减⼩了⼦问题数⽬，完全消除了⼦问题的
冗余，所以⼦问题总数不会超过⾦额数 n，即⼦问题数⽬为 O(n)。处理⼀个
⼦问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。

![image-20210824222603288](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210824222603288.png)

}
}
return (dp[amount] == amount + 1) ? -1 : dp[amount];
}

## 零钱兑换



![image-20210829191501516](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210829191501516.png)



```java
  public int coinChange(int[] coins, int amount) {
if(amount < 1) return 0;
int[]dp= new int[amount+1];//dp[i]:当目标金额为i时至少需要多少硬币
Arrays.fill(dp,amount+1);
dp[0]=0;
for(int i=0;i<dp.length;i++)
{
   for(int num:coins)
   {
       if(i-num<0)
       continue;
       else
       dp[i]=Math.min(dp[i-num]+1,dp[i]);
   }
}
return dp[amount]==amount+1?-1:dp[amount];

    }

```



## [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

难度中等715

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

------

![image-20220821105740114](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220821105740114.png)

![image-20220821105752103](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220821105752103.png)

![image-20220821105819869](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220821105819869.png)

```java
    public int change(int amount, int[] coins) {
int[]dp = new int[amount+1];
if(amount==0) return 1;
dp[0]=1;
for(int coin:coins)
{
    for(int i=coin;i<=amount;i++)
    dp[i]+=dp[i-coin];
}
return dp[amount];
    }
```






最优⼦结构性质作为动态规划问题的必要条件，⼀定是让你求最值的



## [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

难度中等689

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

-------------------

![image-20220831172726160](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220831172726160.png)

由此可以得到动态规划的做法：

初始化 dp[0]=1；

遍历 i 从 1 到target，对于每个 i，进行如下操作：

遍历数组nums 中的每个元素 num，当num≤i 时，将dp[i−num] 的值加到 dp[i]。
最终得到 dp[target] 的值即为答案。

```java
  public int combinationSum4(int[] nums, int target) {
int []dp = new int[target+1];
dp[0]=1;
for(int i = 1;i <= target;i++){
    for(int num:nums){
        if(num<=i){
            dp[i]+=dp[i-num];
        }
    }
}
    
return dp[target];

}
```





## 背包问题：

dp\[i][w] 表⽰：对于前 i 个物品，当前背包的容量为 w 时，这种情况下可以装下的最⼤价值是 dp\[i][w] 。
如果你没有把这第 i 个物品装⼊背包，那么很显然，最⼤价值 dp\[i][w]应该等于 dp\[i-1][w] ，继承之前的结果。
如果你把这第 i 个物品装⼊了背包，那么 dp\[i][w] 应该等于 dp\[i-1][w-wt[i-1]] + val[i-1] 。

换句话说，如果 j - nums[i-1] 的重量可以被恰好装满，那么只要把第 i个物品装进去，也可恰好装满 j 的重量；否则的话，重量 j 肯定是装不满的。
⾸先，由于 i 是从 1 开始的，所以 val 和 wt 的索引是 i-1 时表⽰第i 个物品的价值和重量。(有两个数组，分别放val价值和wt重量)
⽽ dp\[i-1][w - wt[i-1]] 也很好理解：你如果装了第 i 个物品，就要寻求剩余重量 w - wt[i-1] 限制下的最⼤价值，加上第 i 个物品的价值val[i-1] 。

由于 i 是从 1 开始的，⽽数组索引是从 0 开始的，所以第 i 个物品的重量应该是 nums[i-1] ，这⼀点不要搞混。

```java
问题描述：有一个背包可以装物品的总重量为W，现有N个物品，每个物品中w[i]，价值v[i]，用背包装物品，能装的最大价值是多少？

定义状态转移数组dp[i][j]，表示前i个物品，背包重量为j的情况下能装的最大价值。

例如，dp[3][4]=6，表示用前3个物品装入重量为4的背包所能获得的最大价值为6，此时并不是3个物品全部装入，而是3个物品满足装入背包的条件下的最大价值。

状态转移方程：

dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])

dp[i-1][j]表示当前物品不放入背包，dp[i-1][j-w[i]]+v[i]表示当前物品放入背包，即当前第i个物品要么放入背包，要么不放入背包。


dp = [[0]*(n+1) for _ in range(m+1)]
for i in range(1,m+1):
    for j in range(1,n+1):
        if j-w[i]>=0:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])
        else:
            dp[i][j] = dp[i-1][j]
return dp[m][n]
```



416 

![image-20210830173243676](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210830173243676.png)

```java
  public boolean canPartition(int[] nums) {
int sum = 0;
for(int n:nums)
sum += n;
if(sum % 2 == 1) return false;
int size = nums.length;
boolean [][]dp = new boolean[size+1][sum+1];
sum = sum/2;
for(int i =0;i <= size;i++)
for(int j = 1;j <= sum;j++)
dp[i][j] = false;
for(int i = 0;i <= size;i++) dp[i][0] = true;
for(int i = 1;i <= size;i++)
for(int j = 1;j <= sum;j++)
{
    if(j - nums[i-1] < 0) dp[i][j] = dp[i-1][j];
    else
    {
        dp[i][j] = dp[i -1][j] | dp[i-1][j - nums[i-1]];
    }
}
return dp[size][sum];
    }
```

## [879. 盈利计划](https://leetcode-cn.com/problems/profitable-schemes/)

难度困难224

集团里有 `n` 名员工，他们可以完成各种各样的工作创造利润。

第 `i` 种工作会产生 `profit[i]` 的利润，它要求 `group[i]` 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。

工作的任何至少产生 `minProfit` 利润的子集称为 **盈利计划** 。并且工作的成员总数最多为 `n` 。

有多少种计划可以选择？因为答案很大，所以 **返回结果模** `10^9 + 7` **的值**。

 

**示例 1：**

```
输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
输出：2
解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
总的来说，有两种计划。
```

----

![image-20220205213612459](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220205213612459.png)

dp\[i]\[j][k]=*dp*\[*i*−1]\[j][k]+dp\[i−1]\[j−group[i]]\[max(0,*k*−*profit*[*i*])]

由于我们定义的第三维是工作利润至少为 k 而不是 工作利润恰好为 k，因此上述状态转移方程中右侧的第三维是max(0,k−profit[i]) 而不是k−profit[i]

```java
public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
int max=(int)(1e9+7);
int[][][]dp=new int[group.length+1][n+1][minProfit+1];
dp[0][0][0]=1;//n名员工
for(int i=1;i<=group.length;i++)
{
    int member=group[i-1],thepro=profit[i-1];
    for(int j=0;j<=n;j++)
    for(int z=0;z<=minProfit;z++)
    {
if(j<member) dp[i][j][z]=dp[i-1][j][z];
else
dp[i][j][z]=(dp[i-1][j][z]+dp[i-1][j-member][Math.max(0,z-thepro)])%max;
    }
}
  int sum = 0;
for(int j=0;j<=n;j++)
sum=(sum+dp[group.length][j][minProfit])%max;
return sum;
    }
```

## [1155. 掷骰子的N种方法](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/)

难度中等119

这里有 `d` 个一样的骰子，每个骰子上都有 `f` 个面，分别标号为 `1, 2, ..., f`。

我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。

如果需要掷出的总点数为 `target`，请你计算出有多少种不同的组合情况（所有的组合情况总共有 `f^d` 种），**模 `10^9 + 7`** 后返回。

 

**示例 1：**

```
输入：d = 1, f = 6, target = 3
输出：1
```

----

方程：dp\[i][j] 与 dp[i - 1] 的关系是什么呢？ 第 i 次我投了 k ( 1 <= k <= f)，那么前 i - 1 次 和 为 j - k，对应 dp\[i - 1][j - k]；

dp\[i][j] = dp\[i - 1][j - 1] + dp\[i - 1][j - 2] + ... + dp\[i - 1][j - f]

```java
    public int numRollsToTarget(int n, int k, int target) {
int[][]dp=new int[31][1001];//dp[i][j]:i个骰子投出和为j
int maxnum=1000000007;
int min=Math.min(k,target);
for(int i=1;i<=min;i++)
dp[1][i]=1;//取面数和target中的更小值，1个骰子时投出和是i的种数有一种
for(int i=2;i<=n;i++)//n个骰子
for(int j=i;j<=n*k;j++)//上一次是i-1个骰子投出和为j-z 最大数也只有n*k
for(int z=1;z<=j&&z<=k;z++)
dp[i][j]=(dp[i-1][j-z]+dp[i][j])%maxnum;//相当于dp[i][j]=dp[i-1][j-1]+dp[i-1][j-2]+..... 如果不取模的话就是dp[i][j]+=dp[i-1][j-z]

return dp[n][target];
    }
```



## 连续序列最大和

```c++
//给定一个数字序列，求i j 使得A[i]~A[j]的和最大 
int a[maxn],dp[maxn];//dp[i]存放以i结尾的连续序列的最大和

int main()
{	
 
int n;
cin >> n;
for(int i = 0; i < n; i++)
cin >> a[i];
a[0] = dp[0];//边界
for(int i = 1; i < n; i++)
dp[i] = max( dp[i-1] + a[i] ,a[i]); 
int k = 0;
for(int i = 1; i < n; i++)
if(dp[i] > dp[k])//遍历dp[0~n-1]求出最大值即为连续序列的最大和 
k = i;//k存储下标
cout << dp[k]; 


}
```







## 编辑距离

![image-20210831111014605](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210831111014605.png)



![image-20230319231433309](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230319231433309.png)

```java
 public int minDistance(String word1, String word2) {
int dp[][] = new int[word1.length()+1][word2.length()+1];
for(int i = 0;i <= word1.length();i++)
dp[i][0] = i;
for(int i = 0;i  <=word2.length();i++)
dp[0][i] = i;
for(int i = 1;i <= word1.length();i++)
for(int j = 1;j <= word2.length();j++)
{
    if(word1.charAt(i-1) == word2.charAt(j-1))
    dp[i][j] = dp[i-1][j-1];
    else
    {
        if(dp[i-1][j] <= dp[i][j-1] && dp[i-1][j] <=dp[i-1][j-1]  )
         dp[i][j]  = dp[i-1][j]  +1;
         else if(dp[i-1][j-1] <= dp[i-1][j] && dp[i-1][j-1] <=dp[i][j-1])
            dp[i][j]  = dp[i-1][j-1]  +1;
      else
      dp[i][j] = dp[i][j-1]+1;
    }
}
return dp[word1.length()][word2.length()];
    }
```

![image-20210831111128148](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210831111128148.png)

![image-20210831111218996](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210831111218996.png)

dp 函数的 base case 是 i,j 等于 -1，⽽数组索引⾄少是 0，所以 dp 数组会偏移⼀位。
既然 dp 数组和递归 dp 函数含义⼀样，也就可以直接套⽤之前的思路写代码，唯⼀不同的是，DP table 是⾃底向上求解，递归解法是⾃顶向下求

如果用备忘录优化：

```python
def minDistance(s1, s2) -> int:
memo = dict() # 备忘录
def dp(i, j):
if (i, j) in memo:
return memo[(i, j)]
...
if s1[i] == s2[j]:
memo[(i, j)] = ...
else:
memo[(i, j)] = ...
return memo[(i, j)]
return dp(len(s1) - 1, len(s2) - 1)
```





## 合并两个有序数组

![image-20210903125638735](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210903125638735.png)

思路一。利用系统自带的system.arraycopy+sort

思路二：利用双指针+一个新的数组，空间复杂度高于1

思路三：双指针，且不需要一个新的数组，从后往前遍历即可

```java
public static int[]merge3(int[] nums1,int m,int[]nums2,int n){
    int p1 = m-1;
    int p2 = n-1;
    int p = m+n-1;(nums1的空间规定大小为m+n)
    while(p1>=0 && p2>=0){
        nums1[p--] = nums1[p1] < nums2[p2] ? nums2[p2--]:nums1[p1--];
    }
    System.arraycopy(nums2,0,nums1,0,p2+1);
}

    public static void main(String[] args) {
//      int[]arr = getMaxWindow(new int[]{4,3,5,4,3,3,6,7},3);
//        for (int i = 0; i < arr.length; i++) {
//            System.out.println(arr[i]);
//        }
        int[] nums1=new int[]{1,4,5,6,0,0,0};
        int[] nums2 = new int[]{2,4,8};
        nums1 =merge3(nums1,4,nums2,nums2.length);
        for (int i = 0; i < nums1.length; i++) {
            System.out.println(nums1[i]);
        }
        //注意，这个函数的第二个参数不是nums1的长度，而是nums1中有序的元素个数
```

## 高楼扔鸡蛋

「状态」很明显，就是当前拥有的鸡蛋数 K 和需要测试的楼层数 N 。随
着测试的进⾏，鸡蛋个数可能减少，楼层的搜索范围会减⼩，这就是状态的
变化。
「选择」其实就是去选择哪层楼扔鸡蛋。回顾刚才的线性扫描和⼆分思路，
⼆分查找每次选择到楼层区间的中间去扔鸡蛋，⽽线性扫描选择⼀层层向上
测试。不同的选择会造成状态的转移。
现在明确了「状态」和「选择」，动态规划的基本思路就形成了：肯定是个
⼆维的 dp 数组或者带有两个状态参数的 dp 函数来表⽰状态转移；外加
⼀个 for 循环来遍历所有选择，择最优的选择更新状态：

当前状态为 K 个鸡蛋，⾯对 N 层楼，返回这个状态下的最优结果

def dp(K, N):
int res
for 1 <= i <= N:
res = min(res, 这次在第 i 层楼扔鸡蛋)
return res
这段伪码还没有展⽰递归和状态转移，不过⼤致的算法框架已经完成了。

我们选择在第 i 层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。注意，这时候状态转移就来了：
如果鸡蛋碎了，那么鸡蛋的个数 K 应该减⼀，搜索的楼层区间应该从
[1..N] 变为 [1..i-1] 共 i-1 层楼；
如果鸡蛋没碎，那么鸡蛋的个数 K 不变，搜索的楼层区间应该从 [1..N]
变为 [i+1..N] 共 N-i 层楼。

因为我们要求的是最坏情况下扔鸡蛋的次数，所以鸡蛋在第 i 层楼碎没
碎，取决于那种情况的结果更⼤：

最坏情况下的最少扔鸡蛋次数

```python
def dp(K, N):
for 1 <= i <= N:
res = min(res,
max(
dp(K - 1, i - 1), # 碎
dp(K, N - i) # 没碎
) + 1 # 在第 i 楼扔了⼀次
)
return res
```

递归的 base case 很容易理解：当楼层数 N 等于 0 时，显然不需要扔鸡
蛋；当鸡蛋数 K 为 1 时，显然只能线性扫描所有楼层：
def dp(K, N):
if K == 1: return N
if N == 0: return 0

⾸先，有读者可能不理解代码中为什么⽤⼀个 for 循环遍历楼层 [1..N] ，
也许会把这个逻辑和之前探讨的线性扫描混为⼀谈。其实不是的，这只是在
做⼀次「选择」

⽐⽅说你有 2 个鸡蛋，⾯对 10 层楼，你这次选择去哪⼀层楼扔呢？不知
道，那就把这 10 层楼全试⼀遍。⾄于下次怎么选择不⽤你操⼼，有正确的
状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。

```java
  Map<Integer, Integer> memo = new HashMap<Integer, Integer>();

    public int superEggDrop(int k, int n) {
        return dp(k, n);
    }

    public int dp(int k, int n) {
        if (!memo.containsKey(n * 100 + k)) {
            int ans;
            if (n == 0) {
                ans = 0;
            } else if (k == 1) {
                ans = n;
            } else {
                int lo = 1, hi = n;
                while (lo + 1 < hi) {
                    int x = (lo + hi) / 2;
                    int t1 = dp(k - 1, x - 1);
                    int t2 = dp(k, n - x);

                    if (t1 < t2) {
                        lo = x;
                    } else if (t1 > t2) {
                        hi = x;
                    } else {
                        lo = hi = x;
                    }
                }

                ans = 1 + Math.min(Math.max(dp(k - 1, lo - 1), dp(k, n - lo)), Math.max(dp(k - 1, hi - 1), dp(k, n - hi)));
            }

            memo.put(n * 100 + k, ans);
        }

        return memo.get(n * 100 + k);
    }
```





------------



一个问题必须有重叠子问题，才可以用动态规划解。

一个问题必须有最优子结构，才能用动态规划解决。

```c++
const int maxn = 1000;
//动态规划之数塔问题
int f[maxn][maxn], dp[maxn][maxn];

 
int main()
{	

int n;
cin >> n;
fill(dp[0], dp[0] + maxn*maxn, -1);
for(int i = 0; i < n ;i ++)
for(int j = 0; j <= i; j++)
cin >> f[i][j];
for(int i = n-1; i >=0 ; i--)
dp[n-1][i] = f[n-1][i];//最底层先赋值

 for(int i = n-2; i >= 0 ; i--)
for(int j = 0; j <= i; j++)
{
	//状态转移方程 从倒数第二层开始向上算出一条累加和最大的路径 
	dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j];	
}
cout<<dp[0][0];


}
```

递归与递推：前者是自顶向下，从目标问题开始将它分解成子问题的组合，后者是自底向上，从边界开始，不断向上解决问题



## 动态规划之输出两个字符串最长公共子序列c++版

摘录自书籍《趣学算法》动态规划章节

算法设计

最长公共子序列问题满足动态规划的最优子结构性质，可以自底向上逐步得到最优解。 
（1）确定合适的数据结构 采用二维数组c[][]来记录最长公共子序列的长度，二维数组b[][]来记录最长公共子序列的长度的来源，以便算法结束时倒推求解得到该最长公共子序列。 （2）初始化 输入两个字符串s1、s2，初始化c[][]第一行第一列元素为0。 
（3）循环阶段 i = 1：s1[0]与s2[j-1]比较，j=1，2，3，…，len2。 如果s1[0]=s2[j-1]，c\[i][j] = c\[i-1][j-1]+1；并记录最优策略来源b\[i][j]=1； 如果s1[0] ≠s2[j-1]，则公共子序列的长度为c\[i][j-1]和c\[i-1][j]中的最大值，如果c\[i][j-1]c\[i-1][j]，则c\[i][j]=c\[i][j-1]，最优策略来源b\[i][j]=2；否则c\[i][j]= c\[i-1][j]，最优策略来源b\[i][j]=3。 i = 2：s1[1]与s2[j-1]比较，j=1，2，3，…，len2。 以此类推，直到i > len1时，算法结束，这时c\[len1][len2]就是最长公共序列的长度。 
（4）构造最优解 根据最优决策信息数组b[][]递归构造最优解，即输出最长公共子序列。因为我们在求最长公共子序列长度c[i][j]的过程中，用b[i][j]记录了c[i][j]的来源，那么就可以根据b[i][j]数组倒推最优解。 如果b[i][j]=1，说明s1[i-1]=s2[j-1]，那么就可以递归求解print(i-1, j-1)；然后输出s1[i-1]。 注意：如果先输出，后递归求解print(i-1,j-1)，则输出的结果是倒序。 如果b[i][j]=2，说明s1[i-1]≠s2[j-1]且最优解来源于c[i][j]=c[i][j-1]，递归求解print(i, j-1)。 如果b[i][j]=3，说明s1[i-1]≠s2[j-1]且最优解来源于c[i][j]=c[i-1][j]，递归求解print(i-1, j)。当i==0 || j==0时，递归结束。 

图解

以字符串s1=“ABCADAB”，s2=“BACDBA”为例。 
（1）初始化 len1=7，len2=6，初始化c[][]第一行、第一列元素为0，如图4-7所示。 
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526032237112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU4NTc0,size_16,color_FFFFFF,t_70) 
                                             图 4-7

 2）i=1：s1[0]与s2[j-1]比较，j=1，2，3，…，len2。即“A”与“BACDBA”分别比较一次。 如果字符相等，c\[i][j]取左上角数值加1，记录最优值来源b\[i][j]=1。 如果字符不等，取左侧和上面数值中的最大值。如果左侧和上面数值相等，默认取左侧数值。如果c\[i][j]的值来源于左侧b\[i][j]=2，来源于上面b\[i][j]=3。 j=1：A≠B，左侧=上面，取左侧数值，c\[1][1]= 0，最优策略来源b[1]\[1]=2，如图4-8所示。  图4-8　最长公共子序列求解过程 j=2：A=A，则取左上角数值加1，c\[1][2]= c\[0][1]+1=2，最优策略来源b\[1][2] =1，如图4-9所示。  图4-9　最长公共子序列求解过程 j=3：A≠C，左侧上面，取左侧数值，c\[1][3]= 1，最优策略来源b\[1][3] =2，如图4-10所示。 


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526032333745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU4NTc0,size_16,color_FFFFFF,t_70)
图4-9

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526032409692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU4NTc0,size_16,color_FFFFFF,t_70)
图4-10


最后得到的b数组：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526032435394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU4NTc0,size_16,color_FFFFFF,t_70)

完整代码：

```cpp
int len1, len2;
const int n = 1002;
int b[n][n];//b[i][j]表示c[i][j]的来源，用于输出最长公共子序列 为1时说明s1[i-1]=s2[j-1] 则可以递归函数print再输出s1[i-1]
//b[i][j]为2时说明s1[i-1]不等于s2[j-1] 最优解来源于c[i][j]=c[i][j-1] 递归输出print(i,j-1)
//为3时说明1[i-1]不等于s2[j-1] 最优解来源于c[i][j]=c[i-1][j] 递归输出print(i-1,j) i或者j为0时递归结束
int c[n][n];//c[len1][len2]表示最长公共子序列的长度
char s1[n], s2[n];

void LCSL() {

    for (int i = 1; i <= len1; i++) 
        for (int j = 1; j <= len2; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                b[i][j] = 1;
                c[i][j] = c[i - 1][j - 1] + 1;
            }
            else if (c[i - 1][j] >= c[i][j - 1]) {
                b[i][j] = 2;
                c[i][j] = c[i - 1][j];
            }
            else {
                b[i][j] = 3;
                c[i][j] = c[i][j - 1];
            }
        }
    
}



        void print(int i, int j) {
            if (i == 0 || j == 0) return;
            if (b[i][j] == 1)
            {
                print(i - 1, j - 1);
                cout << s1[i - 1];
            }
            else if (b[i][j] == 2) {
                print(i - 1, j);
            }
            else
                print(i, j - 1);
        }
int main()

{
   
    cout << "input s1 and s2";
    cin >> s1;
    cout << "s2:";
    cin >> s2;
    len1 = strlen(s1);
    len2 = strlen(s2);
    for (int i = 0; i < len1; i++) {
        for (int j = 0; j < len2; j++) {
            c[0][j] = 0;
            c[i][0] = 0;
        }
    }
    LCSL();
    print(len1, len2);
}


```

## [1143. 最长公共子序列长度](https://leetcode.cn/problems/longest-common-subsequence/)

难度中等1180

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

-----------------

注意：是最长公共子序列不是最长公共子串，二者不一样

如果是最长公共子串的长度则这样解：

```java
  public static int getLCS(char[] x, char[] y) {
        // base case，默认 dp 中的每个元素都为 0。定义dp[i][j]表示字符串str1中第i个字符和str2种第j个字符为最后一个元素所构成的最长公共子串
        int dp[][] = new int[x.length+1][y.length+1];
        
        // 最长公共子串， 用一个临时变量表示
        int resultLCS = 0;
        for (int i = 1; i <= x.length; i++) {
            for (int j = 1; j <= y.length; j++) {
                // 以下是状态转移方程
                if (x[i-1] == y[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                    resultLCS = Math.max(resultLCS, dp[i][j]);
                } else {
                    dp[i][j] = 0;
                }
            }
        }
        return resultLCS;
    }
```



![image-20221212172627633](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221212172627633.png)

![image-20221212172707863](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221212172707863.png)

最长公共子序列代码如下：

```java
  public int longestCommonSubsequence(String text1, String text2) {
              //这里dp[i][j]表示长度为i和j的前缀,所以要加一
        String word1 = text1,word2=text2;,
   int[][]dp = new int[word1.length()+1][word2.length()+1];
        for (int i = 1; i <= word1.length(); i++)
        {

            char ch1=word1.charAt(i-1);
            for (int j = 1; j <= word2.length(); j++) {
                char ch2=word2.charAt(j-1);
                if(ch1==ch2){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        int n = dp[word1.length()][word2.length()];
        return n;
    }
```

例题：查找两个字符串a,b中的最长公共子串。若有多个，输出在**较短串中最先出现的那个。**

注：子串的定义：将一个字符串删去前缀和后缀（也可以不删）形成的字符串。请和“子序列”的概念分开！

关键：先找到更短的串，然后先从更短的串遍历

```java
 public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        String str1=in.nextLine();
        String str2=in.nextLine();
        String ans="";
    String temp="";
   // 保证str1是较短字符串
        if (str1.length() > str2.length()) {
            temp = str1;
            str1 = str2;
            str2 = temp;
        }
        int m = str1.length() + 1;
        int n = str2.length() + 1;
        // 表示在较短字符串str1以第i个字符结尾，str2中以第j个字符结尾时的公共子串长度。
        int[][] dp = new int[m][n];
        // 匹配字符，并记录最大值的str1的结尾下标
        int max = 0;
        int index = 0;
        // 从左向右递推，i为短字符串str1的结尾索引，j为str2的结尾索引
        for (int i=1; i < m; i++) {
            for (int j=1; j < n; j++) {
                if (str1.charAt(i-1) == str2.charAt(j-1)) {
                    // 相等则计数
                    dp[i][j] = dp[i-1][j-1] + 1;
                    // 不断更新变量
                    if (dp[i][j] > max) {
                        max = dp[i][j];
                        index = i;
                    }
                }
            }
        }
        // 截取最大公共子串
      System.out.println(str1.substring(index-max+1, index+1));
    }
```



## 

## [712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)

难度中等306

给定两个字符串`s1` 和 `s2`，返回 *使两个字符串相等所需删除字符的 **ASCII** 值的最小和* 。

 

**示例 1:**

```
输入: s1 = "sea", s2 = "eat"
输出: 231
解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
在 "eat" 中删除 "t" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
```

**示例 2:**

```
输入: s1 = "delete", s2 = "leet"
输出: 403
解释: 在 "delete" 中删除 "dee" 字符串变成 "let"，
将 100[d]+101[e]+101[e] 加入总和。在 "leet" 中删除 "e" 将 101[e] 加入总和。
结束时，两个字符串都等于 "let"，结果即为 100+101+101+101 = 403 。
如果改为将两个字符串转换为 "lee" 或 "eet"，我们会得到 433 或 417 的结果，比答案更大。
```



--------------------------



![image-20230205190637166](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230205190637166.png)

![image-20230205190650147](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230205190650147.png)

```java
  public int minimumDeleteSum(String s1, String s2) {
int a=97;
int[][]dp=new int[s1.length()+1][s2.length()+1];
      //这里一定要注意初始化问题
for(int i =1;i<=s1.length();i++)
dp[i][0]=dp[i-1][0]+s1.codePointAt(i-1);
for(int i =1;i<=s2.length();i++)
dp[0][i]=dp[0][i-1]+s2.codePointAt(i-1);
for(int i = 1;i<=s1.length();i++)
{
    int code1=s1.codePointAt(i-1);
    for(int j=1;j<=s2.length();j++)
    {
int code2=s2.codePointAt(j-1);
if(code1==code2)
dp[i][j]=dp[i-1][j-1];
else 
dp[i][j]=Math.min(dp[i-1][j]+code1,dp[i][j-1]+code2);
    }
}
return dp[s1.length()][s2.length()];
    }
```





## 纸牌游戏

![image-20211213203920446](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211213203920446.png)



![image-20211213203901180](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211213203901180.png)



## 连续子数组的最大和

![image-20211218011851971](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211218011851971.png)

题解：

![image-20211218011938711](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211218011938711.png)



```java
  public int maxSubArray(int[] nums) {
       if (nums.length == 0) {
            return 0;
        }
        int min= 0;

        int maxsub = nums[0];
      
     for(int i = 0;i <nums.length;i++)
     {
min = Math.max(nums[i],min+nums[i]);
maxsub = Math.max(maxsub,min);
     }
        return maxsub;
        }
            }
```



## 不能连续的数组之和

一个有名的按摩师会收到源源不断的预约请求， 每个预约都可以选择接或不接。在每次预约服务之间要有休息时间， 因此她不能接受相邻的预约。给定一个预约请求序列， 替按摩师找到最优的预约集合（ 总预约时间最长） ， 返回总的分钟数。
示例 1 ：
输入： [ 1 , 2 , 3 , 1 ]
输出： 4
解释： 选择 1 号预约和 3 号预约， 总时长 = 1 + 3 = 4

示例 2 ：
输入： [ 2 , 7 , 9 , 3 , 1 ]
原创 山大王wld 数据结构和算法 11月16日
输出： 1 2
解释： 选择 1 号预约、 3 号预约和 5 号预约， 总时长 = 2 + 9 + 1 =12



动态规划解决
数组中的值表示的是预约时间， 按摩师可以选择接或者不接， 如果前一个接了， 那么下一个肯定是不能接的， 因为按摩师不能接相邻的两次预约。如果上一个没接， 那么下一
个可以选择接也可以选择不接， 视情况而定。
这里可以定义一个二维数组d p [ l e n g t h ] [ 2 ] ， 其中d p [ i ] [ 0 ] 表示第i + 1 （ 因为数组下标
是从0 开始的， 所以这里是i + 1 ） 个预约没有接的最长总预约时间， d p [ i ] [ 1 ] 表示的是第i + 1 个预约接了的最长总预约时间。那么我们找出递推公式1 ， d p [ i ] [ 0 ] = m a x ( d p [ i - 1 ] [ 0 ] , d p [ i - 1 ] [ 1 ] )
他表示如果第i + 1 个没有接， 那么第i 个有没有接都是可以的， 我们取最大值即可。
2 ， d p [ i ] [ 1 ] = d p [ i - 1 ] [ 0 ] + n u m s [ i ]
他表示的是如果第i + 1 个接了， 那么第i 个必须要没接， 这里n u m s [ i ] 表示的是第i + 1 个预约的时间。
递推公式找出来之后我们再来看下边界条件， 第一个预约可以选择接， 也可以选择不接， 所以d p [ 0 ] [ 0 ] = 0 ， 第一个没接
d p [ 0 ] [ 1 ] = n u m s [ 0 ] ， 第一个接了。
最后再来看下代码

```java
public int massage(int[] nums) {
 //边界条件判断
 if (nums == null || nums.length == 0)
 return 0;
 int length = nums.length;
 int[][] dp = new int[length][2];
 dp[0][0] = 0;//第1个没接
 dp[0][1] = nums[0];//第1个接了
 //从第2个开始判断
 for (int i = 1; i < length; i++) {
 //下面两行是递推公式2
     dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
 dp[i][1] = dp[i - 1][0] + nums[i];
 }
 //最后取最大值即可
 return Math.max(dp[length - 1][0], dp[length - 1][1]);
 }
```



动态规划优化
上面定义了一个二维数组， 但每次计算的时候都只是用二维数组的前一对值， 在往前面
的就永远使用不到了， 这样就会造成巨大的空间浪费， 所以我们可以定义两个变量来解
决， 来看下代码
1 public int massage(int[] nums) {
2 //边界条件判断
3 if (nums == null || nums.length == 0)
4 return 0;
5 int length = nums.length;
6 int dp0 = 0;//第1个没接
7 int dp1 = nums[0];//第1个接了
8 //从第2个开始判断
9 for (int i = 1; i < length; i++) {
10 //防止dp0被修改之后对下面运算造成影响，这里
11 //使用一个临时变量temp先把结果存起来，计算完
12 //之后再赋值给dp0.
13 int temp = Math.max(dp0, dp1);
14 dp1 = dp0 + nums[i];
15 dp0 = temp;
16 }
17 //最后取最大值即可
18 return Math.max(dp0, dp1);
19 }



## 三角形最小路径和

给定一个三角形， 找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点
上。
相邻的结点在这里指的是下标与上一层结点下标相同或者等于一层结点下标+ 1 的两个结
点。
例如， 给定三角形：
[
[2],
[3,4],
[6,5,7],
[4,1,8,3]
]





答：



自顶向下的最小路径和为 1 1 （ 即， 2 + 3 + 5 + 1 = 1 1 ） 。
递归求解
这题让求路径的最小值， 如果知道了下面路径的最小值， 只需要选择最小的即可， 描述
不是很明白， 这里以示例为例画个图来看一下

![image-20211222115559783](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211222115559783.png)



```java
  public int minimumTotal(List<List<Integer>> triangle) {
return minimumTotal(triangle,0,0,triangle.size());
    }

    private int minimumTotal(List<List<Integer>> triangle,int line, int row, int size) {
        if(line > size||row > size)
        {
            return 0;//这时候代表已经出去到三角形外面了，返回零。注意这个三角形中每一行的行号等于这一行元素个数
        }
        int left = minimumTotal(triangle,line+1,row,size);//下一行的左边元素的
        int right = minimumTotal(triangle,line+1,row+1,size);
        return triangle.get(line).get(row)+Math.min(left,right);
    }
```

这种解法虽然没有逻辑上的错误， 但是执行效率很差， 因为他包含大量的重复计算， 有
点类似斐波那契数量一样， 在之前讲过3 5 6 ， 青蛙跳台阶相关问题的时候提到过斐波那
契数列可以使用m a p 把计算的结果存储起来， 下次用的时候如果m a p 中有就直接从
m a p 中取， 如果m a p 中没有再计算。

if (line >= total || row >= total)
8 return 0;
9 String key = line + "-" + row;
10 if (map.containsKey(key))
11 return map.get(key);
12 int left = minimumTotal(triangle, line + 1, row, total, map);
13 int right = minimumTotal(triangle, line + 1, row + 1, total, map);
14 int sum = triangle.get(line).get(row) + (left < right ? left : right);
15 //把计算的结果存储到map中
16 map.put(key, sum);
17 return sum;

动态规划解决
递归使用的是从上到下的方式来计算（ 但实际上计算的时候由于递归的原因， 他还是先
从下面开始计算， 然后把计算的结果返回给上一层调用递归的地方） 。其实还可以不使
用递归， 倒数第一行的最小路径就是他自己， 从倒数第二行开始， 当前元素的最小路径
就是当前元素加上他下一行左右两个元素的最小路径。画个图来看一下

![image-20211222121004749](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211222121004749.png)

我们来定义一个二维数组d p ， 他表示当前位置的最小路径和， 我们可以得出递推公式
d p [ i ] [ j ] = m i n ( d p [ i + 1 ] [ j ] + d p [ i + 1 ] [ j + 1 ] )
+ t r i a n g l e . g e t ( i ) . g e t ( j ) ；
  他表示当前位置的最小路径和是下一行左右两个最小的路径和加上当前的值。

```java
public int minimumTotal(List<List<Integer>> triangle) {
2 //定义一个二维数组
3 int[][] dp = new int[triangle.size() + 1][triangle.size() + 1];
4 //从最后一行开始计算
5 for (int i = triangle.size() - 1; i >= 0; i--) {
6 for (int j = 0; j < triangle.get(i).size(); j++) {
7 //递归公式
8 dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j);
9 }
10 }
11 return dp[0][0];
12 }
13
上面代码使用的是二维数组， 每一行使用之后就不会再使用了， 造成了空间的浪费， 其
实我们还可以把它改成一维的， 就像之前讲的3 7 0 ， 最长公共子串和子序列中提到的代
码优化那样， 最后再来看下代码
1 public int minimumTotal(List<List<Integer>> triangle) {
2 int[] dp = new int[triangle.size() + 1];
3 for (int i = triangle.size() - 1; i >= 0; i--) {
4 for (int j = 0; j < triangle.get(i).size(); j++) {
5 //min函数中的dp[j]实际上是下一行的值这里还没有更新
6 dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);
7 }
8 }
9 return dp[0];
10 }
```



## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

![image-20220126142448040](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220126142448040.png)

贪心法：

![image-20220126142544340](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220126142544340.png)



```java
 public int maxProfit(int[] prices) {
int ans = 0;
for(int i = 1;i <prices.length;i++)
{
ans +=Math.max(prices[i]-prices[i-1],0);
}

return ans;
    }
```

动态规划法：

![image-20220126142837613](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220126142837613.png)

![image-20220126142858553](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220126142858553.png)

## 买卖股票的最佳时机3

z在上一个问题的基础上又多了一条件：最多只能进行两笔操作（即两次买入卖出）

--------------

![image-20220219180248135](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220219180248135.png)

![image-20220219180316521](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220219180316521.png)

![image-20220219180726558](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220219180726558.png)

```java
 public int maxProfit(int[] prices) {
int buy1 = -prices[0],sell1 = 0,buy2 = -prices[0],sell2 = 0;
for(int i = 1; i < prices.length;i++)
{
    buy1=Math.max(-prices[i],buy1);
    sell1 = Math.max(prices[i]+buy1,sell1);
    buy2 = Math.max(sell1-prices[i],buy2);
    sell2 = Math.max(buy2+prices[i],sell2);
}
return Math.max(sell1,sell2);
    }
```



## [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

难度困难676

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

-------------



![image-20220311082340926](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220311082340926.png)

![image-20220311082717971](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220311082717971.png)



```java
    public int maxProfit(int k, int[] prices) {

if(prices.length == 0) return 0;
   //k = Math.min(k, prices.length / 2);
int[][]buy = new int[prices.length][k+1];
int[][]sell = new int[prices.length][k+1];
buy[0][0] = -prices[0];
      
  for (int i = 1; i <= k; ++i) {
            buy[0][i] = sell[0][i] = Integer.MIN_VALUE / 2;
        }
for(int i = 1;i < prices.length;i++)
{
    buy[i][0] = Math.max(buy[i-1][0],sell[i-1][0]-prices[i]);//这里都要进行  buy[i][0] 的判断
    for(int j = 1;j <=k;j++)//注意这里从1开始
    {
buy[i][j] = Math.max(buy[i-1][j],sell[i-1][j]-prices[i]);
sell[i][j] = Math.max(sell[i-1][j],buy[i-1][j-1]+prices[i]);
        //注意，buy对应sell[i-1][j] sell对应buy[i-1][j-1] 只有完成卖出才是一笔交易
    }
}
return Arrays.stream(sell[prices.length-1]).max().getAsInt();
    }
```

也可以这么理解：

本题中存在三种「状态」：天数、是否持有股票的状态、交易次数
而对于每种状态，我们又有不同的选择：
1. 天数由prices确定
2. 是否持有股票的状态我们可以用0/1表示，0代表不持有股票，1代表持有股票
3. 交易次数由k确定

这样一来，我们可以设定一个三维数组dp[i][j][k]，其存储的内容是在第i天，我们持有股票的状态为j，已经进行了k次交易时能够获取的最大利润
这里需要说明的是，第i天和数组的索引一致，它的范围是0 ~ prices.length-1，所以我设置的起点是第0天
比如说dp\[5]\[0][2]：其中存储了 「在第5天时，我们不持有股票，已经进行了2次交易」 时获取的最大利润
好了，到这里dp的定义和状态我们就确定下来了，那么初始值怎么确定呢？

因为对于第0天来说，它所能够获取的最大利润只有两种，与交易次数毫无关系，所以我们有以下初始值：
1.不持有股票时：dp\[0]\[0][k]=0
2.持有股票时：dp\[0]\[1][k]=-prices[0]

好了，到这里初始值也确定下来了，那么还剩下最后一个问题「状态方程」
我们首先要知道一点，**第i天的状态只和第i-1天有关，第i天持有/不持有股票 能够获取的最大利润取决于 第i-1天持有/不持有股票**
这里需要注意：我将买入股票时作为一次交易，也就是在买入股票的时候交易次数+1
第i天不持有股票时：
1.如果第i-1天也不持有股票，那就代表状态不变，第i天的状态=第i-1天的状态
2.如果第i-1天持有股票，说明我们在第i天把股票卖了，既然卖股票赚钱了，利润就要多prices[i]

dp\[i]\[0][k] = max(dp\[i-1]\[0][k] , dp\[i-1]\[1][k]+prices[i])

第i天持有股票时：
1.如果第i-1天也持有股票，那就代表状态不变，即dp\[i]\[1][k] = dp\[i-1]\[1][k]
2.如果第i-1天不持有股票，说明我们在第i天买入股票，既然买股票要花钱，利润就要少price[i]
买入股票的同时，当天的交易次数要在前一天的基础上+1

```java
dp[i][1][k] = max(dp[i-1][1][k] , dp[i-1][0][k-1]-prices[i])
```

至此，思路捋顺，开始码代码了！
还需要注意的点：因为一次交易涉及一天买入一天卖出，一共两天，所以如果k值大于数组长度的一半，k就直接取数组长度的一半，因为多余的交易次数无法达到
即：k=min(k , prices.length/2)

```java
 public int maxProfit(int K, int[] prices) {//这里悄咪咪把小k换成了大K，便于后续索引赋值
        int n=prices.length;
        if(n<=1)    return 0;
        //因为一次交易至少涉及两天，所以如果k大于总天数的一半，就直接取天数一半即可，多余的交易次数是无意义的
        K=Math.min(K,n/2);

        /*dp定义：dp[i][j][k]代表 第i天交易了k次时的最大利润，其中j代表当天是否持有股票，0不持有，1持有
        注意在这里k不是k次全部完成后的利润，而是最大利润，也就是不一定是k次都完成的利润
        */
        int[][][] dp=new int[n][2][K+1];
        for(int k=0;k<=K;k++){
            dp[0][0][k]=0;
            dp[0][1][k]=-prices[0];
        }

        /*状态方程：
        dp[i][0][k]，当天不持有股票时，看前一天的股票持有情况
        dp[i][1][k]，当天持有股票时，看前一天的股票持有情况*/
        for(int i=1;i<n;i++){
            for(int k=1;k<=K;k++){
                dp[i][0][k]=Math.max(dp[i-1][0][k],dp[i-1][1][k]+prices[i]);
                dp[i][1][k]=Math.max(dp[i-1][1][k],dp[i-1][0][k-1]-prices[i]);
            }
        }
        return dp[n-1][0][K];
    }


```

## [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

难度中等1363

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

--------------

![image-20221212225748724](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221212225748724.png)

![image-20221212225805544](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221212225805544.png) 

```java
   public int maxProfit(int[] prices) {
 if(prices.length==0){
            return 0;
        }
        //// f[i][0]: 手上持有股票的最大收益
        //        // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
        //        // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
        //

        int[][]f = new int[prices.length][3];
        f[0][0]=-prices[0];
        f[0][1]=0;
        f[0][2]=0;
        for (int i = 1; i < prices.length; i++) {
            f[i][0] = Math.max(f[i-1][0],f[i-1][2]- prices[i]);
            f[i][1]=f[i-1][0]+prices[i];
            f[i][2]=Math.max(f[i-1][1],f[i-1][2]);
        }
        return Math.max(f[prices.length-1][1],f[prices.length-1][2]);
    }
```





## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

难度中等1003

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。



这里注意每一个为1的格子都自身是一个小正方形，然后才向外拓展，需要保证对角线也为1，这里有一个巧妙的点：用dp数组时的状态转移方程

  dp\[i][j] = Math.min(Math.min(dp\[i-1][j],dp[i][j-1]),dp\[i-1][j-1])+1;

```java
 public int maximalSquare(char[][] matrix) {
int[][]dp = new int[matrix.length][matrix[0].length];
int maxSide = 0;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return maxSide;
        }

for(int i = 0;i <matrix.length;i++)
{
    for(int j = 0;j <matrix[0].length;j++)
    {
        if(matrix[i][j] == '1')
        {
            if(i == 0 ||j == 0)
         {  dp[i][j] = 1;}
            else
            dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1;
              maxSide = Math.max(maxSide,dp[i][j]);
        }
  
    }
}
return maxSide*maxSide;
    }
```



## [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

 

示例：

输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。

------------------

![image-20220128142922730](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220128142922730.png)

```java
 public int findLength(int[] nums1, int[] nums2) {
int tot=0;
int[][]dp = new int[nums1.length+1][nums2.length+1];
if(nums1[0]==nums2[0])
dp[0][0] = 1;
if(nums1[0]==nums2)
for(int i =0;i<nums1.length-1;i++)
{
   for(int j = 0;j <nums2.length-1;j++)
    {
if(nums1[i]==nums2[j]&&i!=0&&j!=0)
  dp[i][j] =dp[i-1][j-1] +1;
  tot = Math.max(dp[i][j],tot);
    }
     
}
return tot;
    }
```



## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

---------

![image-20220128165608528](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220128165608528.png)



```java
 public int uniquePaths(int m, int n) {
        boolean[][]vis = new boolean[m][n];
int[][]dp = new int[m][n];
for(int i = 0;i<m;i++)
dp[i][0] = 1;
for(int i = 0;i<n;i++)
dp[0][i] = 1;
for(int i = 1;i<m;i++)
for(int j = 1;j<n;j++)
{
    dp[i][j] = dp[i-1][j]+dp[i][j-1];
}

return dp[m-1][n-1];
    }
    public void dfs(   boolean[][]vis ,int i,int j,int m,int n)
    {
        if(i == m-1 && j==n-1)
       {
           tot++;
            return; 
       }
       vis[i][j] = true;
       int[]d1 = {1,0};
       int[]d2 = {0,1};
       for(int z = 0;z < 2;z++)
       {if(i+d1[z] < m  && j+d2[z]<n&&!vis[i+d1[z]][j+d2[z]])
           dfs(vis,i+d1[z],j+d2[z],m,n);
       }
       vis[i][j] = false;
    }
```

## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

难度中等719

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

 注意：这个题试过了用递归，虽然解答是正确的但是会超出时间限制，需要考虑用动态规划

```java
   int tot=0;
    boolean[][]vis=new boolean[100][100];
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid[0][0]==1) return 0;
int[][]dp=new int[obstacleGrid.length][obstacleGrid[0].length];
for(int i = 0;i<obstacleGrid.length && obstacleGrid[i][0] == 0;i++)
    //尤其注意这个循环条件，如果dp[i][0]为0，则dp[i+1][0]也为0，即如果有一个obstacleGrid[i][0]为1，则这一行后面的位置必然都到不了，可以直接退出循环

dp[i][0]=1;
for(int i = 0;i<obstacleGrid[0].length && obstacleGrid[0][i] == 0;i++)
if(obstacleGrid[0][i]==0)
dp[0][i]=1;
for(int i = 1;i<obstacleGrid.length;i++)
{
    for(int j = 1;j<obstacleGrid[0].length;j++)
    {
        if(obstacleGrid[i][j]==0)
        {
          
dp[i][j]=dp[i-1][j]+dp[i][j-1];
        }
    }
}

return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];
    }
```



## 打家劫舍2

这里变成了环形房屋，即数组元素的第一个和最后一个不能同时房屋

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

----

由于是环形的，所以选择遍历两次的方式

```java
 public int rob(int[] nums) {
if(nums.length==2) return Math.max(nums[0],nums[1]);
if(nums.length==1) return nums[0];
int[]dp=new int[nums.length];
int[]dp2=new int[nums.length];
dp[0]=nums[0];
dp[1]=Math.max(nums[0],nums[1]);
dp2[1]=nums[1];
dp2[2]=Math.max(nums[1],nums[2]);
for(int i=2;i<nums.length-1;i++)
dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1]);
for(int i=3;i<nums.length;i++)
dp2[i]=Math.max(dp2[i-2]+nums[i],dp2[i-1]);
return Math.max(dp2[nums.length-1],dp[nums.length-2]);
    }
```

## 树形动态规划[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

#### 

难度中等

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

![image-20220129141844949](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220129141844949.png)

--------

![image-20220129141938823](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220129141938823.png)

```java
HashMap<TreeNode,Integer>g = new HashMap<>();//不选某个点
HashMap<TreeNode,Integer>f = new HashMap<>();//选某个点
    public int rob(TreeNode root) {
dfs(root);
return Math.max(g.getOrDefault(root,0),f.getOrDefault(root,0));
    }
    public void dfs(TreeNode root)
    {
     if(root == null) return;
       dfs(root.left);
     dfs(root.right);
     f.put(root,root.val+g.getOrDefault(root.right,0)+g.getOrDefault(root.left,0));
     g.put(root,Math.max(f.getOrDefault(root.left,0),g.getOrDefault(root.left,0))+Math.max(f.getOrDefault(root.right,0),g.getOrDefault(root.right,0)));
   
    }
```

## [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)

难度中等541

给你一个整数数组 `nums` ，你可以对它进行一些操作。

每次操作中，选择任意一个 `nums[i]` ，删除它并获得 `nums[i]` 的点数。之后，你必须删除 **所有** 等于 `nums[i] - 1` 和 `nums[i] + 1` 的元素。

开始你拥有 `0` 个点数。返回你能通过这些操作获得的最大点数。

 

**示例 1：**

```
输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
```

-----

![image-20220211002242987](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220211002242987.png)

```java
 public int deleteAndEarn(int[] nums) {
int maxval = 0;
if(nums.length == 1) return nums[0];
for(int i:nums)
maxval = Math.max(i,maxval);
int[]sum = new int[maxval+1];
for(int i:nums)
sum[i]+=i;
return rob(sum);
    }
    public int rob(int[] sum)
    {
        int[]dp = new int[sum.length];
        dp[0]= sum[0];dp[1] = Math.max(sum[0],sum[1]);
        int first = sum[0], second = Math.max(sum[0],sum[1]);
        for(int i = 2;i< sum.length;i++)
        {
            dp[i] = Math.max(dp[i-1],sum[i]+dp[i-2]);
        }
        return dp[sum.length-1];
    }
```





## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

难度中等1366

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

"cars" ["car","ca","rs"]

输出: true

---------------

![image-20220129151203572](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220129151203572.png)

```java
 public boolean wordBreak(String s, List<String> wordDict) {
        Set<String>mydict = new HashSet(wordDict);
        boolean[]dp = new boolean[s.length()+1];
        dp[0] = true;//注意这个初始化条件
        for(int i = 1;i <= s.length();i++)
        {
            for(int j = 0;j < i;j++)
            {
                if(dp[j] && mydict.contains(s.substring(j,i)))
                dp[i] = true;
            }
        }
return dp[s.length()];


    }
```



## [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

难度困难2700

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。

**示例 1：**

```
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

---

![image-20220207155503642](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220207155503642.png)

![image-20220207155558891](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220207155558891.png)

![image-20230203165009123](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230203165009123.png)



```java
  public boolean isMatch(String s, String p) {
boolean[][]dp=new boolean[s.length()+1][p.length()+1];
dp[0][0]=true;
for(int i=0;i<=s.length();i++)
{
    for(int j=1;j<=p.length();j++)
    {
if(p.charAt(j-1)=='*')
{dp[i][j]=dp[i][j-2];
if(match(s,p,i,j-1))
dp[i][j]=dp[i][j]||dp[i-1][j];
}
else{ if(match(s,p,i,j))
dp[i][j]=dp[i-1][j-1];
}
    }
}
return dp[s.length()][p.length()];
    }
public boolean match(String s,String p,int i,int j)
{
    if(i==0) return false;
    if(p.charAt(j-1)=='.') return true;
    return s.charAt(i-1)==p.charAt(j-1);
}
    
```

## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

难度中等6229

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

 

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

------

![image-20230308223714264](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230308223714264.png) 

```java

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }

```







## 分割回文串

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。

 

示例 1：

输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]



![image-20220203153229497](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220203153229497.png)

```java
List<List<String>>ans = new LinkedList<>();
boolean [][]dp;
   List<String>member =new LinkedList<>();
    public List<List<String>> partition(String s) {
         
if(s.length()==1) {

    member.add(s);
    ans.add(member);
    return ans;
}
dp=new boolean[s.length()][s.length()];
      for (int i = 0; i < s.length(); ++i) 
Arrays.fill(dp[i],true);
for(int i=s.length()-1;i>=0;i--)
{
    for(int j=i+1;j<s.length();j++)
    dp[i][j] = s.charAt(i)==s.charAt(j)&& dp[i+1][j-1];
}
dfs(s,0);
return ans;
    }
    public void dfs(String s,int start)
    {
        if(start==s.length())
        {
            ans.add(new LinkedList<>(member));
            return;
        }
        for(int i=start;i<s.length();i++)
        {
            if(dp[start][i])
            {
                member.add(s.substring(start,i+1));
                dfs(s,i+1);
                member.remove(member.size()-1);
            }
        }
    }
```



## 推箱子

堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。

输入使用数组[wi, di, hi]表示每个箱子。

示例1:

 输入：box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]
 输出：6
示例2:

 输入：box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]]
 输出：10

------

关键：可以选择这个箱子也可以不选这个箱子，需要比较两种情况下得到最大值

用一个二维dp：注意先对数组进行排序

```java
 public int pileBox(int[][] box) {
              Arrays.sort(box, (a,b)->{return a[0]-b[0];});//必须要先排序
int[][]dp=new int[box.length][2];//dp[i][0]对应的是不选这个箱子的高度，dp[i][1]对应选这个箱子的高度
dp[0][1]=box[0][2];
dp[0][0] = 0;
for(int i =1;i <box.length;i++)
{
int[]temp=box[i];
int max=temp[2];
for(int j = 0;j <i;j++)
{
    int[]pre=box[j];
    if(temp[0]>pre[0]&&temp[1]>pre[1]&&temp[2]>pre[2])
    {
int val = dp[j][1]+temp[2];
max=Math.max(val,max);
    }
}
dp[i][1]=max;
dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]);//这个很巧妙，如果不选这个箱子，则最大值是不选上一个箱子和选上一个箱子比较之后得到的最大值
}
return Math.max(dp[box.length-1][0],dp[box.length-1][1]);
    }
```

## 背包：分割等和子集

题目：判断一个数组是否可以拆成两个子集，其中两个子集的和相等

前置知识：最基本的背包问题就是01背包问题（01 knapsack problem）：一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

如果采用暴力穷举的方式，每件物品都存在装入和不装入两种情况，所以总的时间复杂度是O(2^N)，这是不可接受的。而使用动态规划可以将复杂度降至O(NW)。我们的目标是书包内物品的总价值，而变量是物品和书包的限重，所以我们可定义状态dp:

```text
dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
```

那么我们可以将dp\[0][0...W]初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。那么当 i > 0 时`dp[i][j]`有两种情况：

1. 不装入第i件物品，即`dp[i−1][j]`；
2. 装入第i件物品（前提是能装下），即`dp[i−1][j−w[i]] + v[i]`。

即状态转移方程为

```text
dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i]) // j >= w[i]
// 01背包问题伪代码(空间优化版)
dp[0,...,W] = 0
for i = 1,...,N
    for j = W,...,w[i] // 必须逆向枚举!!!
        dp[j] = max(dp[j], dp[j−w[i]]+v[i])
```

完全背包（unbounded knapsack problem）与01背包不同就是每种物品可以有无限多个：一共有N种物品，每种物品有无限多个，第i（i从1开始）种物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

2.2 分析一

我们的目标和变量和01背包没有区别，所以我们可定义与01背包问题几乎完全相同的状态dp:

```text
dp[i][j]表示将前i种物品装进限重为j的背包可以获得的最大价值, 0<=i<=N, 0<=j<=W
```

初始状态也是一样的，我们将dp\[0][0...W]初始化为0，表示将前0种物品（即没有物品）装入书包的最大价值为0。那么当 i > 0 时`dp[i][j]`也有两种情况：

1. 不装入第i种物品，即`dp[i−1][j]`，同01背包；
2. 装入第i种物品，此时和01背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到`dp[i−1][j−w[i]]`而应该转移到`dp[i][j−w[i]]`，即装入第i种商品后还可以再继续装入第种商品。

所以状态转移方程为

```text
dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) // j >= w[i]
```

这个状态转移方程与01背包问题唯一不同就是max第二项不是dp[i-1]而是dp[i]。

和01背包问题类似，也可进行空间优化，优化后不同点在于这里的 j 只能**正向枚举**而01背包只能逆向枚举，因为这里的max第二项是`dp[i]`而01背包是`dp[i-1]`，即这里就是需要覆盖而01背包需要避免覆盖。所以伪代码如下：

```text
// 完全背包问题思路一伪代码(空间优化版)
dp[0,...,W] = 0
for i = 1,...,N
    for j = w[i],...,W // 必须正向枚举!!!
        dp[j] = max(dp[j], dp[j−w[i]]+v[i])
```

由上述伪代码看出，01背包和完全背包问题此解法的空间优化版解法唯一不同就是前者的 j 只能逆向枚举而后者的 j 只能正向枚举，这是由二者的状态转移方程决定的。此解法时间复杂度为O(NW), 空间复杂度为O(W)。

---





当i=0时，只有dp\[0][nums[0]]才为true,其余均为false

![image-20220203020142319](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220203020142319.png)

```java
  public boolean canPartition(int[] nums) {
//其中 dp[i][j] 表示从数组的 [0,i][0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被
//选取的正整数的和等于 j。
int sum=0,target=0;
int maxnum=0;
for(int i:nums)
{
    sum+=i;
    maxnum = Math.max(i,maxnum);
}
target = sum/2;
if(maxnum>target)
return false;
if(sum%2==1)
return false;
boolean[][]dp=new boolean[nums.length][target+1];
//如果不选取任何正整数，则被选取的正整数等于 0。因此对于所有0≤i<n，都有dp[i][0]=true。当 i==0 时，只有一个正整数nums[0] 可以被选取，因此dp[0][nums[0]]=true。

for(int i = 0;i<nums.length;i++)
dp[i][0]=true;
dp[0][nums[0]]=true;
for(int i = 1;i<nums.length;i++)
{
    for(int j=1;j<=target;j++)
    {
        if(j<nums[i])
        dp[i][j] = dp[i-1][j];
        else
        //如果不选取nums[i]，则dp[i][j]=dp[i−1][j]；如果选取 nums[i]，则dp[i][j]=dp[i−1][j−nums[i]]。

        dp[i][j] = dp[i-1][j-nums[i]]|dp[i-1][j];
    }
}
return dp[nums.length-1][target];
    }
```

## [368. 最大整除子集](https://leetcode.cn/problems/largest-divisible-subset/)

难度中等487

给你一个由 **无重复** 正整数组成的集合 `nums` ，请你找出并返回其中最大的整除子集 `answer` ，子集中每一元素对 `(answer[i], answer[j])` 都应当满足：

- `answer[i] % answer[j] == 0` ，或
- `answer[j] % answer[i] == 0`

如果存在多个有效解子集，返回其中任何一个均可。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,2]
解释：[1,3] 也会被视为正确答案。
```

------

![image-20230322001305402](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230322001305402.png) 

![image-20230322001327619](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230322001327619.png) 

然后查找大小为2的最大整除子集，依次类推

```java
  public List<Integer> largestDivisibleSubset(int[] nums) {
        int len = nums.length;
        Arrays.sort(nums);

        // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数
        int[] dp = new int[len];
        Arrays.fill(dp, 1);
        int maxSize = 1;
        int maxVal = dp[0];
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                // 题目中说「没有重复元素」很重要
                if (nums[i] % nums[j] == 0) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }

            if (dp[i] > maxSize) {
                maxSize = dp[i];
                maxVal = nums[i];
            }
        }

        // 第 2 步：倒推获得最大子集
        List<Integer> res = new ArrayList<Integer>();
        if (maxSize == 1) {
            res.add(nums[0]);
            return res;
        }
        
        for (int i = len - 1; i >= 0 && maxSize > 0; i--) {
            if (dp[i] == maxSize && maxVal % nums[i] == 0) {
                res.add(nums[i]);
                maxVal = nums[i];
                maxSize--;
            }
        }
        return res;
    }


```



## [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

难度中等703

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

----

将 i拆分成 j 和 i−j 的和，且i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；

将 i拆分成 j 和i−j 的和，且i−j 继续拆分成多个正整数，此时的乘积是j×dp[i−j]。



```java
   public int integerBreak(int n) {
int[]dp = new int[n+1];
//创建数组dp，其中dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此dp[0]=dp[1]=0。


        for (int i = 2; i <= n; i++) {
            int curmax = 0;
            for (int j = 1; j < i; j++) {
                curmax = Math.max( curmax,Math.max(j *(i-j),dp[i-j]*j));
            }
            dp[i] = curmax;
        }
        return dp[n];
    }
```

## [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

难度中等1232

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

----



```java
 public int numSquares(int n) {
if(Math.sqrt(n)==(int)Math.sqrt(n)) return 1;
if(Math.sqrt(n-1)==(int)Math.sqrt(n-1)) return 2;

//13=2+3 14=3+2+1 15 = 3+2+1+1 16 = 4 17 = 4+1 18 = 3+3 19 = 3+3+1 20=
int[]dp = new int[n+1];
for(int i = 0;i <= n;i++)
{
    dp[i] = i;// 最坏的情况就是每次+1
    for(int j = 0;i-j*j>=0;j++)
    {
        dp[i] = Math.min(dp[i],dp[i-j*j]+1);
    }
}
return dp[n];
    }
```



**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

## [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)

难度困难620

给定一个非负整数数组 `nums` 和一个整数 `m` ，你需要将这个数组分成 `m` 个非空的连续子数组。

设计一个算法使得这 `m` 个子数组各自和的最大值最小。

 

**示例 1：**

```
输入：nums = [7,2,5,10,8], m = 2
输出：18
解释：
一共有四种方法将 nums 分割为 2 个子数组。 
其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```

---

![image-20220216191233396](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220216191233396.png)

![image-20220216191407514](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220216191407514.png)

```java
    public int splitArray(int[] nums, int m) {
int len = nums.length;
int[][]dp = new int[len+1][m+1];
int[]sub = new int[len+1];
for(int i = 0;i <len;i++)
sub[i+1] = sub[i] +nums[i];
for(int i = 0;i <= len;i++)
Arrays.fill(dp[i],Integer.MAX_VALUE);
dp[0][0] = 0;
for(int i = 1;i <=len;i++)
{
    for(int j = 1;j <= Math.min(i,m);j++)
    {
        for(int k = 0;k < i;k++)
        dp[i][j] = Math.min(dp[i][j],Math.max(dp[k][j-1],sub[i]-sub[k]));
    }
}
return dp[len][m];
    }
```

## 字符串解码

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。



----

![image-20220219021207900](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220219021207900.png)

动态规划的边界条件为：

*f*0=1

即**空字符串可以有 1 种解码方法，解码出一个空字符串**。

```java
   int tot = 0;
    public int numDecodings(String s)
     {
         if(s == "0") return 0;
int[] dp = new int[s.length()+1];//dp[0]表示空字符串，有一种解码方法
dp[0] = 1;//注意这个初始化必不可少
for(int i = 1;i <=s.length();i++)
{
    if(s.charAt(i-1) != '0')//i-1是第i个字符 表示解析第i个字符
    dp[i] +=dp[i-1];
    if(i > 1&&s.charAt(i-2)!='0' && ((s.charAt(i-2)-'0')*10+s.charAt(i-1)-'0' <=26))//表示解析第i和第i-1个字符
dp[i]+=dp[i-2];
}
    return dp[s.length()]; 
}
```

## 300[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```java

    public int lengthOfLIS(int[] nums) {
        int[]dp = new int[nums.length];
        int maxn = 1;
        dp[0]=1;
for(int i = 1;i <nums.length;i++)
{
dp[i] = 1;
    for(int j = 0 ;j < i;j++)
    {
        if(nums[i] >nums[j])
        {
            dp[i] = Math.max(dp[i],dp[j]+1);
            maxn = Math.max(dp[i],maxn);
        }
    }
    
}
return maxn;
    }
```

## 上升子序列的应用：合唱队

时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。

## 描述

N 位同学站成一排，音乐老师要请最少的同学出列，使得剩下的 K 位同学排成合唱队形。



通俗来说，能找到一个同学，他的两边的同学身高都依次严格降低的队形就是合唱队形。

例子：

123 124 125 123 121 是一个合唱队形

123 123 124 122不是合唱队形，因为前两名同学身高相等，不符合要求

123 122 121 122不是合唱队形，因为找不到一个同学，他的两侧同学身高递减。



你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

**注意：不允许改变队列元素的先后顺序** **且** **不要求最高同学左右人数必须相等**



------

思路：找到每个元素左边递增序列和右边递减序列，然后加起来，用长度减去这个值

每一个位置i左侧的最长上升子序列长度numL[i]：每一个位置左侧最长子序列长度等于其左侧比它小的所有位置的最长子序列长度中的最大值+1
再找到每一个位置i右侧的最长下降子序列长度numR[i]：每一个位置右侧最长子序列长度等于其右侧比它小的所有位置的最长子序列长度中的最大值+1
然后求出所有位置的最长序列长度=左侧最长子序列长度+右侧最长子序列长度-1（因为该位置被算了两次，所以减1）

```java
  public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
  int n=in.nextInt();
int[]arr=new int[n];
for(int i=0;i<n;i++)
{
arr[i]=in.nextInt();
}
int[]left=new int[n];
int[]right=new int[n];
for(int i=0;i<arr.length;i++)
{
    left[i]=1;
    for(int j=0;j<i;j++)
    {
        if(arr[i]>arr[j])
        left[i]=Math.max(left[i],left[j]+1);
    }
    //left[i]+=1;
}
for(int i=arr.length-1;i>=0;i--)
{
    right[i]=1;
    for(int j=arr.length-1;j>i;j--)
    {
        if(arr[i]>arr[j])
        right[i]=Math.max(right[i],right[j]+1);
    }
    
}
int max=0;
for(int i=0;i<arr.length;i++)
{
    max=Math.max(max,right[i]+left[i]-1);
    }
    System.out.println(n-max);
}
```



## [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

难度中等551

给定一个未排序的整数数组 `nums` ， *返回最长递增子序列的个数* 。

**注意** 这个数列必须是 **严格** 递增的。

 

**示例 1:**

```
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

----

在这里由于还要求个数，因此再用一个额外的数组表示以nums[i]结尾的最长递增子序列个数，而且每次遇到更长的子序列要不断更新数组

```java
    public int lengthOfLIS(int[] nums) {//dp[i]是递增子序列的长度，cnt[i]是个数
        int[]dp = new int[nums.length];
        int maxn = 1;
        dp[0]=1;
        int number = 0;
        int[]cnt = new int[nums.length];
for(int i = 1;i <nums.length;i++)
{
dp[i] = 1;
cnt[i] = 1;
    for(int j = 0 ;j < i;j++)
    {
        if(nums[i] >nums[j])//i>j且num[i]>nums[j]说明是递增序列
        {
            if(dp[i] < dp[j]+1)
            {dp[i] =dp[j]+1;
          
            cnt[i] = cnt[j];
            }
            else if(dp[i] == dp[j]+1)
            {
                 cnt[i] +=cnt[j];
            }
        }
       
    }
    if(dp[i] > maxlen)
    {
        maxlen = dp[i];
        number = cnt[i];
    }
    else if(dp[i] == maxlen) number +=cnt[i];
    
}
return number;
    }
```



## [446. 等差数列划分 II - 子序列](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/)

难度困难245

给你一个整数数组 `nums` ，返回 `nums` 中所有 **等差子序列** 的数目。

如果一个序列中 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该序列为等差序列。

- 例如，`[1, 3, 5, 7, 9]`、`[7, 7, 7, 7]` 和 `[3, -1, -5, -9]` 都是等差序列。
- 再例如，`[1, 1, 2, 5, 7]` 不是等差序列。

数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。

- 例如，`[2,5,10]` 是 `[1,2,1,2,4,1,5,10]` 的一个子序列。

题目数据保证答案是一个 **32-bit** 整数。

 输入：nums = [2,4,6,8,10]
输出：7
解释：所有的等差子序列为：
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]

-----

```java
 public int numberOfArithmeticSlices(int[] nums) {
Map<Long, Integer>[]dp = new HashMap[nums.length];
//每一个 nums[i] 的状态，其实是一张哈希表（键值对），「键」 是 nums[i] 与它前面的每一个元素的「差」，那「值」是什么呢？「值」是以 nums[i] 结尾组成的、公差为某个值的 长度大于等于 2 的等差子序列的个数


int res = 0;
for(int i = 0;i<nums.length;i++)
dp[i] = new HashMap<Long,Integer>();
for(int i = 1;i < nums.length;i++)
for(int j = 0;j < i;j++)
{
    long diff = (long) nums[i] - nums[j];
    if(diff > Integer.MAX_VALUE||diff<Integer.MIN_VALUE)
    continue;//注意，这里可能有负数，因此公差可能出现大于 Integer.MAX_VALUE的情况，用long类型
     // dp[i][diff] += (dp[j][diff] + 1) ，Java 写起来有点麻烦，表示 nums[i] 可以接在之前「公差相等」的等差数列后面形成长度更长的等差数列
    dp[i].put(diff,dp[i].getOrDefault(diff,0)+dp[j].getOrDefault(diff,0)+1);
    if(dp[j].containsKey(diff))      // 与之前的等差数列公差相等的时候，说明可以接上，此时计算结果
    {   // 理解：对结果的贡献「恰好是」之前的某个 j 的对应状态值，这里的 j 一定会在之前的某一个 i 加上 1，看上面有注释的那一行代码
res +=dp[j].get(diff);
//之前的状态值里有同样的 diff 的时候，说明才可能形成长度大于等于 3 的等差数列，此时记录结果
    }
}
return res;
    }
```

## 圆环回原点问题

圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。

```
输入: 2
输出: 2
解释：有2种方案。分别是0->1->0和0->9->0
```

----


本题考察的是动态规划。

**走n步到0的方案数=走n-1步到1的方案数+走n-1步到9的方案数。**

因此，若设dp\[i][j]为从0点出发走i步到j点的方案数，则递推式为：

```java
dp[i][j]= dp[i-1][(j-1+length)%length]+dp[i-1][(j+1+length)%length]
    公式之所以取余是因为j-1或j+1可能会超过圆环0~9的范围
```

初始化dp\[0][0] = 1 

```java
int[][]dp = new int[n][length];
dp[0][0] = 1;
for(int i = 1;i < n;i++)
{
    for(int j = 0;j < length;j++)
        dp[i][j] = dp[i-1][(j-1+length)%length]+dp[i-1];
}
return dp[n][0];
```

## 较难：[面试题 17.24. 最大子矩阵](https://leetcode-cn.com/problems/max-submatrix-lcci/)

难度困难129

给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。

返回一个数组 `[r1, c1, r2, c2]`，其中 `r1`, `c1` 分别代表子矩阵左上角的行号和列号，`r2`, `c2` 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。

```
输入：
[
   [-1,0],
   [0,-1]
]
输出：[0,1,0,1]
解释：输入中标粗的元素即为输出所表示的矩阵
```

----

详细过程可以看题解

```java
class Solution {
    public int[] getMaxMatrix(int[][] matrix) {
        int[] ans = new int[4];//保存最大子矩阵的左上角和右下角的行列坐标
        int N = matrix.length;
        int M = matrix[0].length;
        int[] b = new int[M];//记录当前i~j行组成大矩阵的每一列的和，将二维转化为一维
        int sum = 0;//相当于dp[i],dp_i
        int maxsum = Integer.MIN_VALUE;//记录最大值
        int bestr1 = 0;
        int bestc1 = 0;//暂时记录左上角，相当于begin

        for(int i = 0;i < N; i++){     //以i为上边，从上而下扫描
            for(int t = 0;t < M; t++ ) {
                b[t]=0;    //每次更换子矩形上边，就要清空b，重新计算每列的和
            }
            for(int j = i;j < N; j++){    //子矩阵的下边，从i到N-1，不断增加子矩阵的高
                //一下就相当于求一次最大子序列和
                sum = 0;//从头开始求dp
                for(int k=0; k < M; k++){
                    b[k] += matrix[j][k];   
//我们只是不断增加其高，也就是下移矩阵下边，所有这个矩阵每列的和只需要加上新加的哪一行的元素
//因为我们求dp[i]的时候只需要dp[i-1]和nums[i],所有在我们不断更新b数组时就可以求出当前位置的dp_i
                    if(sum>0){
                        sum+=b[k];//即便b[k]小于0也没关系，下面会判断sum与maxsum哪个大，如果sum加一个负数会比原来的数字小，这样就不会更新maxnum
                    }
                    else{
                        sum = b[k];
                        bestr1 = i;//自立门户，暂时保存其左上角，在这里更新sum
                        bestc1 = k;
                    }
                    if( sum > maxsum){
                        maxsum = sum;
                        ans[0] = bestr1;//更新答案
                        ans[1] = bestc1;
                        ans[2] = j;
                        ans[3] = k;
                    }
                }
            }
        }
        return ans;
    }
}
```



## [877. 石子游戏](https://leetcode.cn/problems/stone-game/)

难度中等443

Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，**排成一行**；每堆都有 **正** 整数颗石子，数目为 `piles[i]` 。

游戏以谁手中的石子最多来决出胜负。石子的 **总数** 是 **奇数** ，所以没有平局。

Alice 和 Bob 轮流进行，**Alice 先开始** 。 每回合，玩家从行的 **开始** 或 **结束** 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 **石子最多** 的玩家 **获胜** 。

假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 `true` ，当 Bob 赢得比赛时返回 `false` 。

 （注意：即便变成石头总数不一定是奇数，下面的解法也是可以直接用的）

**示例 1：**

```
输入：piles = [5,3,4,5]
输出：true
解释：
Alice 先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。
如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。
```

----------------

![image-20220820001852301](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220820001852301.png)

```java
    public boolean stoneGame(int[] piles) {
int[][]dp =new int[piles.length][piles.length];
for(int i = 0;i <piles.length;i++)
dp[i][i]=piles[i];
        //这个i必须从piles.length-2开始，然后再减小，否则会错
for(int i = piles.length-2;i >=0;i--){
    for(int j = i+1;j < piles.length;j++){
        //piles[i]是取走左端 piles[j]是取走右端
        dp[i][j] = Math.max(piles[i]-dp[i+1][j],piles[j]-dp[i][j-1]);
    }
}
return dp[0][piles.length-1]>0;
    }
```

另一个思路：

博弈论
事实上，这还是一道很经典的博弈论问题，也是最简单的一类博弈论问题。

为了方便，我们称「石子序列」为石子在原排序中的编号，下标从 11 开始。

由于石子的堆数为偶数，且只能从两端取石子。因此先手后手所能选择的石子序列，完全取决于先手每一次决定。

证明如下：

由于石子的堆数为偶数，对于先手而言：每一次的决策局面，都能「自由地」选择奇数还是偶数的序列，从而限制后手下一次「只能」奇数还是偶数石子。

具体的，对于本题，由于石子堆数为偶数，因此先手的最开始局面必然是 [奇数, 偶数][奇数,偶数]，即必然是「奇偶性不同的局面」；当先手决策完之后，交到给后手的要么是 [奇数,奇数][奇数,奇数] 或者 [偶数,偶数][偶数,偶数]，即必然是「奇偶性相同的局面」；后手决策完后，又恢复「奇偶性不同的局面」交回到先手 ...

不难归纳推理，这个边界是可以应用到每一个回合。

因此先手只需要在进行第一次操作前计算原序列中「奇数总和」和「偶数总和」哪个大，然后每一次决策都「限制」对方只能选择「最优奇偶性序列」的对立面即可。

同时又由于所有石子总和为奇数，堆数为偶数，即没有平局，所以先手必胜。

## 1230.抛掷硬币

有一些不规则的硬币。在这些硬币中，prob[i] 表示第 i 枚硬币正面朝上的概率。

请对每一枚硬币抛掷 一次，然后返回正面朝上的硬币数等于 target 的概率。

示例 1：

输入：prob = [0.4], target = 1
输出：0.40000
1
2
示例 2：

输入：prob = [0.5,0.5,0.5,0.5,0.5], target = 0

输出：0.03125

---------



解法1：二维dp dp\[i][j]表示0~i一共j枚硬币朝上的概率，状态转移，若第 1  个硬币到第 i 个硬币有 j  个硬币正面朝上时

第 i  个硬币正面朝上，则第 1 个到第 i − 1  个硬币中必须有 j−1 个硬币正面朝上。即 $prob(i - 1)*f(i - 1, j - 1) $
第 i 个硬币反面朝上，则第 1  个到第 i − 1 个硬币中必须有 j 个硬币正面朝上。即$ [ 1 − p r o b ( i − 1 ) ]* f ( i − 1 , j )$

代码：

```java
class Solution {
    public double probabilityOfHeads(double[] prob, int m) {
        int n = prob.length;
        double[][] f = new double[n + 1][m + 1];
        f[0][0] = 1;
        double p = 1;
        for(int i = 1; i <= n; i++){ // 连续 i 个硬币反面朝上时·
            p *= 1 - prob[i - 1];
            f[i][0] = p;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {       
                f[i][j] = f[i - 1][j - 1] * prob[i - 1] + f[i - 1][j] * (1 - prob[i - 1]);
            }
        }
        return f[n][m];
    }
}

```

## [688. 骑士在棋盘上的概率](https://leetcode.cn/problems/knight-probability-in-chessboard/)

难度中等311

在一个 `n x n` 的国际象棋棋盘上，一个骑士从单元格 `(row, column)` 开始，并尝试进行 `k` 次移动。行和列是 **从 0 开始** 的，所以左上单元格是 `(0,0)` ，右下单元格是 `(n - 1, n - 1)` 。

象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png)

每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。

骑士继续移动，直到它走了 `k` 步或离开了棋盘。

返回 *骑士在棋盘停止移动后仍留在棋盘上的概率* 。

----------------------

注意：这个题尝试了用dfs会超时，只能用动态规划

![image-20230119130613801](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230119130613801.png)

```java
   public double knightProbability(int n, int k, int row, int column) {
int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};
double[][][]dp=new double[k+1][n][n];
for(int step=0;step<=k;step++){
for(int i = 0;i<n;i++){
    for(int j = 0;j<n;j++){
 if(step==0) dp[step][i][j]=1;
 else{
     for(int []dir:dirs){
     int nx=i+dir[0];
     int ny=j+dir[1];
     if(!(nx<0||ny<0||nx>=n||ny>=n)){
         dp[step][i][j]+=dp[step-1][nx][ny]/8.0;
     }
 }       
 }
    }
}
}

    return dp[k][row][column];
    }
```



## 记忆化搜索：[983. 最低票价](https://leetcode.cn/problems/minimum-cost-for-tickets/)

难度中等488

在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 `days` 的数组给出。每一项是一个从 `1` 到 `365` 的整数。

火车票有 **三种不同的销售方式** ：

- 一张 **为期一天** 的通行证售价为 `costs[0]` 美元；
- 一张 **为期七天** 的通行证售价为 `costs[1]` 美元；
- 一张 **为期三十天** 的通行证售价为 `costs[2]` 美元。

通行证允许数天无限制的旅行。 例如，如果我们在第 `2` 天获得一张 **为期 7 天** 的通行证，那么我们可以连着旅行 7 天：第 `2` 天、第 `3` 天、第 `4` 天、第 `5` 天、第 `6` 天、第 `7` 天和第 `8` 天。

返回 *你想要完成在给定的列表 `days` 中列出的每一天的旅行所需要的最低消费* 。

 

**示例 1：**

```
输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
```



--------------------------



![image-20230131100824904](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230131100824904.png)

这里必须出行指的是这个日子是否在days中，如果在那么久必须出行，如果不在就是不必须出行，这里实际上是以递归的形式，递归的最后一层就是最后的一天，由于我们是倒着进行动态规划的，因此我们可以使用记忆化搜索，减少代码的编写难度。我们使用一个长度为 366 的数组存储所有的动态规划结果，这样所有的 dp(i) 只会被计算一次（和普通的动态规划相同），时间复杂度不会增大。

```java
  Set<Integer>set=new HashSet<>();
    //我们用 dp(i) 来表示从第i 天开始到一年的结束
    int[]memo=new int[366];

    int[]costs;
    public int mincostTickets(int[] days, int[] costs) {
            Arrays.fill(memo,-1);
for(int d:days)
set.add(d);
this.costs=costs;
return dp(1);
    }
    public int dp(int i){
        if (i > 365) {
            return 0;
        }
        if(memo[i]!=-1) return memo[i];
        //表示成递归的形式，用递归解决
        if(set.contains(i)){
memo[i]=Math.min(Math.min(dp(i+1)+costs[0],dp(i+7)+costs[1]),dp(i+30)+costs[2]);
        }else{
            memo[i]=dp(i+1);
        }
        return memo[i];
    }
```





## 96.不同的二叉搜索树

![image-20230312170724335](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230312170724335.png) 

------

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

1. 确定dp数组（dp table）以及下标的含义

**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。

也可以理解是i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

以下分析如果想不清楚，就来回想一下dp[i]的定义

1. 确定递推公式

在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量（j-1其实就是0-j-1的树，i-j就是j到i的树）

1. dp数组如何初始化 令dp[0]=1

所以答案为：

```java
  int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
```

## 矩阵的最小路径和

给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。



例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12，

所选择的最小累加和路径如下图所示：

![image-20230325131431755](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230325131431755.png)

------

如果采用dfs+记忆化的方法应该这样写：因为不是四个方向都可以走，只需要两个方向即可

```java
  int[][]memo;

  public int minPathSum (int[][] matrix) {
​    // write code here
​    memo=new int[matrix.length][matrix[0].length];
​    return dfs(matrix,0,0);
  }
  public int dfs(int[][]matrix,int i,int j)

  {
​    if(i<0||i>=matrix.length||j<0||j>=matrix[0].length)
​    {
​      return Integer.MAX_VALUE;
​    }
​    if(i==matrix.length-1&&j==matrix.length-1) return matrix[i][j];
         if(memo[i][j]!=0) return memo[i][j];
​    int left=dfs(matrix,i+1,j);
​    int down=dfs(matrix,i,j+1);
​    memo[i][j]=Math.min(left, down)+matrix[i][j];

   return memo[i][j];

  }
```

根据「解法一优化」方法的启发，可以想到此题最优解为**动态规划方法**：
动态规划方法的思想是：将原问题分解为若干子问题，称为「**最优子结构**」，通过求解子问题完成对最终问题的求解。对于重复出现的子问题，在第一次出现时对其进行求解，然后**保存其结果**，从而在求解后续的子问题时可以**直接利用先前得到的结果**。

针对这道题目，我们可以先思考最优子结构：题目要求得到从「左上角」到「右下角」的**整个二维数组**的最小路径，因此其子问题为：对于二维数组中的每个元素位置，求取**从起点到该位置的最短路径**；对于「右下角」的元素位置，从起点到该位置的最短路径即为最终答案。

在求解子问题时，需要构建动态转移方程，即：从「上一状态」到「下一状态」的递推式。

如下图所示，对于数组中的每一个元素[i,j]，达到该位置共有两种方式：左侧元素([i,j-1])向右移动一步，或者上方元素([i-1,j])向下移动一步。

因此，对于数组中的每个元素，从上述两种方式中选取较短的那一条路径即为到该点的最短路径。因此，可以得到求解子问题时的状态转移方程：

dp[i, j] = min(dp\[i - 1][j], dp\[i][j - 1]) + matrix\[i][j]

在完成整个动态规划算法时，需要明确算法的推进方向，在此题中，算法的推进方向为：从左至右、从上至下，因此在进行动态规划数组数组dp的初始化时，需要分别初始化数组的「第一行」与「第一列」。

```java
 public int minPathSum (int[][] matrix) {
        // write code here
      
        int[][]dp=new int[matrix.length][matrix[0].length];
        dp[0][0]=matrix[0][0];//记得初始化左上角第一个元素
        for(int i=1;i<matrix[0].length;i++)
        dp[0][i]=dp[0][i-1]+matrix[0][i];
    for(int i=1;i<matrix.length;i++)
        dp[i][0]=dp[i-1][0]+matrix[i][0];
for(int i=1;i<matrix.length;i++)
{
    for(int j=1;j<matrix[0].length;j++)
    {
        dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+matrix[i][j];
    }
}
return dp[matrix.length-1][matrix[0].length-1];
      //  return dfs(matrix,0,0);
    }
```

## 1039.多边形剖分为三角形的最低得分

你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序 ）。

假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。

返回 多边形进行三角剖分后可以得到的最低分 。

----

![image-20230402212823370](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230402212823370.png)



-----

![image-20230402205745186](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230402205745186.png) 

```java
 int n;
    int[] values;
    Map<Integer, Integer> memo = new HashMap<Integer, Integer>();

    public int minScoreTriangulation(int[] values) {
        this.n = values.length;
        this.values = values;
        return dp(0, n - 1);
    }

    public int dp(int i, int j) {
        if (i + 2 > j) {
            return 0;
        }
        if (i + 2 == j) {
            return values[i] * values[i + 1] * values[j];
        }
        int key = i * n + j;
        if (!memo.containsKey(key)) {
            int minScore = Integer.MAX_VALUE;
            for (int k = i + 1; k < j; k++) {
                minScore = Math.min(minScore, values[i] * values[k] * values[j] + dp(i, k) + dp(k, j));
            }
            memo.put(key, minScore);
        }
        return memo.get(key);
    }


```

也可以这样写：

 很经典的一道区间DP，dp\[l][r]表示边集l -> l+1,l+1 -> l+2,......,r-1 -> r,r -> l围成的多边形。整体思路其实就是枚举三角形的一条边l -> r，此时这条边对应的角k会被限制在(l,r)区间内的顶点，三角形lkr就能够把多边形分成三个部分，即三角形lkr和它的左右两侧。对于两侧，只要顶点数大于3就可以继续划分出三角形，从而得到状态转移方程dp\[l][r] = dp\[l][k] + dp\[k][r] + values[l]\*values[k]*values[r]。



接下来就是老套路了，从3开始枚举长度，然后枚举区间左端点，最后枚举分割点k。

```java
 public int minScoreTriangulation(int[] values) {
int[][]dp=new int[50][50];
        int n = values.length;
        for(int len = 3; len <= n; len++) {
            for(int left = 0; left + len - 1 < n; left++) {
                int right = left + len - 1;
                dp[left][right] = Integer.MAX_VALUE;
                for(int k = left + 1; k < right; k++) {
                    dp[left][right] = Math.min(dp[left][right], dp[left][k] + dp[k][right] + values[left]*values[k]*values[right]);
                }
            }
        }
        return dp[0][n - 1];
    
    }
```

## [剑指 Offer II 091. 粉刷房子](https://leetcode.cn/problems/JEj789/)

难度中等146

假如有一排房子，共 `n` 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 `n x 3` 的正整数矩阵 `costs` 来表示的。

例如，`costs[0][0]` 表示第 0 号房子粉刷成红色的成本花费；`costs[1][2]` 表示第 1 号房子粉刷成绿色的花费，以此类推。

请计算出粉刷完所有房子最少的花费成本。

 

**示例 1：**

```
输入: costs = [[17,2,17],[16,16,5],[14,3,19]]
输出: 10
解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
     最少花费: 2 + 5 + 3 = 10。
```

-----

dp[i]表示第0~i个刷成三种颜色之一且相邻不相同的最小花费

![image-20230403234444001](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230403234444001.png)

go:

```go
func minCost(costs [][]int) int {

	var dp =make([]int,3)
    dp=costs[0]
	for i :=1;i< len(costs);i++{
		var temp=make([]int,3)
		for j:=0;j<3;j++{
			temp[j]=min(dp[(j+1)%3],dp[(j+2)%3])+costs[i][j]
		}
		dp=temp
	}
	return min(min(dp[0],dp[1]),dp[2])
}
func min(i int,j int) int {
	if(i<j){
		 return i
	}
	return j;
}
```

java:

```java
public int minCost(int[][] costs) {
        int n = costs.length;
        int[] dp = new int[3];
        for (int j = 0; j < 3; j++) {
            dp[j] = costs[0][j];
        }
        for (int i = 1; i < n; i++) {
            int[] dpNew = new int[3];
            for (int j = 0; j < 3; j++) {
                dpNew[j] = Math.min(dp[(j + 1) % 3], dp[(j + 2) % 3]) + costs[i][j];
            }
            dp = dpNew;
        }
        return Math.min(Math.min(dp[0],dp[1]),dp[2]);
    }
```



# [数据里有{1,2,3,4,5,6,7,8,9}，请随机打乱顺序，生成一个新的数组（请以代码实现）

```java
//随机打乱
public static int[] srand(int[] a) {
int[] b = new int[a.length];
for(int i = 0; i < a.length;i++) {
//随机获取下标
int tmp = (int)(Math.random()*(a.length - i)); //随机数:[ 0 ，a.length - i )
b[i] = a[tmp];
//将此时a[tmp]的下标移动到靠后的位置
int change = a[a.length - i - 1];
a[a.length - i - 1] = a[tmp];
a[tmp] = change;
}
return b;
}
```









# BFS算法（广度优先）

本质上就是⼀幅「图」，让你从⼀个起点，⾛到终点，问最短路径。这就是 BFS 的本质，

```c
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node>q;//核心数据结构
    Set<Node>visited;
    q.offer(start);//起点加入队列
    visited.add(start);
    int step = 0;//记录扩散的步数
    while(q not empty){
int sz = q.size();
/* 将当前队列中的所有节点向四周扩散 */
for (int i = 0; i < sz; i++) {
Node cur = q.poll();
/* 划重点：这⾥判断是否到达终点 */
    if (cur is target)
return step;
/* 将 cur 的相邻节点加⼊队列 */
for (Node x : cur.adj())
if (x not in visited) {
q.offer(x);
visited.add(x);
}
}
        /* 划重点：更新步数在这⾥ */
step++;
    }
    
}
```

队列 q 就不说了，BFS 的核⼼数据结构； cur.adj() 泛指 cur 相邻的节
点，⽐如说⼆维数组中， cur 上下左右四⾯的位置就是相邻节点； visited 的主要作⽤是防⽌⾛回头路，⼤部分时候都是必须的，但是像⼀般的⼆叉树结构，没有⼦节点到⽗节点的指针，不会⾛回头路就不需要visited 。

## 752打开转盘锁



![image-20210828001328401](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210828001328401.png)



-----



```java

    String plusOne(String s, int j) {
char[] ch = s.toCharArray();
if (ch[j] == '9')
ch[j] = '0';
else
ch[j] += 1;
return new String(ch);
}
// 将 s[i] 向下拨动⼀次
String minusOne(String s, int j) {
char[] ch = s.toCharArray();
if (ch[j] == '0')
ch[j] = '9';
else
ch[j] -= 1;
return new String(ch);
}

    public int openLock(String[] deadends, String target) {
        Set<String>sr = new HashSet<>();
        for(String s:deadends) sr.add(s); 
Queue<String>q = new LinkedList<>();
Set<String>visited = new HashSet<>();
q.offer("0000");visited.add("0000");
int step = 0;
while(!q.isEmpty())
{
    int si = q.size();
    for(int i = 0;i < si;i++)
    {
 String str = q.poll();
 if(sr.contains(str))continue;
if(str.equals(target)) return step;
 for(int m = 0;m < 4;m++)
 {
String up = minusOne(str,m);
String down = plusOne(str,m);
if (!visited.contains(up)){
q.offer(up);
visited.add(up);
}
if(!visited.contains(down)){
q.offer(down);
visited.add(down);
}
 }

    }
   step++;
}
return -1;
    }
```

BFS 算法还有⼀种稍微⾼级⼀点的优化思路：双向 BFS，可以进⼀步提⾼算法的效率。
篇幅所限，这⾥就提⼀下区别：传统的 BFS 框架就是从起点开始向四周扩
散，遇到终点时停⽌；⽽双向 BFS 则是从起点和终点同时开始扩散，当两
边有交集的时候停⽌。

不过，双向 BFS 也有局限，因为你必须知道终点在哪⾥。⽐如我们刚才讨
论的⼆叉树最⼩⾼度的问题，你⼀开始根本就不知道终点在哪⾥，也就⽆法
使⽤双向 BFS；但是第⼆个密码锁的问题，是可以使⽤双向 BFS 算法来提
⾼效率的，代码稍加修改即可

广度：用队列 深度：用递归

## [1306. 跳跃游戏 III](https://leetcode-cn.com/problems/jump-game-iii/)

难度中等

这里有一个非负整数数组 `arr`，你最开始位于该数组的起始下标 `start` 处。当你位于下标 `i` 处时，你可以跳到 `i + arr[i]` 或者 `i - arr[i]`。

请你判断自己是否能够跳到对应元素值为 0 的 **任一** 下标处。

注意，不管是什么情况下，你都无法跳到数组之外。

 

**示例 1：**

```
输入：arr = [4,2,3,0,3,1,2], start = 5
输出：true
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 5 -> 下标 4 -> 下标 1 -> 下标 3 
下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 
```

-----

```java
 public boolean canReach(int[] arr, int start) {
if(arr.length==1&&arr[0]!=0) return false;
if(arr[start]==0) return true;
Queue<Integer>myque = new LinkedList<>();
boolean[]vis = new boolean[arr.length];
myque.offer(start);
while(!myque.isEmpty())
{
    int index=myque.poll();
    if(!vis[index]&&index+arr[index]<arr.length)
    {
if(arr[index+arr[index]]==0) return true;
myque.offer(index+arr[index]);
    }
    if(!vis[index]&&index-arr[index]>=0)
    {
if(arr[index-arr[index]]==0) return true;
myque.offer(index-arr[index]);
    }
    vis[index]=true;
}
return false;
    }
```

也可以用深度优先的办法：

```java
   boolean flag;
    boolean[] visited;

    public boolean canReach(int[] arr, int start) {
        int n = arr.length;

        this.flag = false;
        this.visited = new boolean[n];

        dfs(arr, start);

        return flag;
    }

    private void dfs(int[] arr, int start) {
        if (arr[start] == 0) flag = true;

        if (flag) return;

        if (visited[start]) return;

        visited[start] = true;

        if (start - arr[start] >= 0) {
            dfs(arr, start - arr[start]);
        }

        if (start + arr[start] < arr.length) {
            dfs(arr, start + arr[start]);
        }
    }
```

## 跳跃游戏2

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

----



在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。

在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。



```
public int jump(int[] nums) {
    int length = nums.length;
    int end = 0;
    int maxPosition = 0;
    int steps = 0;
    for (int i = 0; i < length - 1; i++) {
        maxPosition = Math.max(maxPosition, i + nums[i]);
        if (i == end) {
            end = maxPosition;
            steps++;
        }
    }
    return steps;
}
```

## (难）状态压缩：

![image-20220217222248546](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220217222248546.png)

## [面试题 17.22. 单词转换](https://leetcode-cn.com/problems/word-transformer-lcci/)

难度中等51

给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。

编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。

**示例 1:**

```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出:
["hit","hot","dot","lot","log","cog"]
```

-----

```java
  public List<String> findLadders(String beginWord, String endWord, List<String> wordList) {
        //定义BFS的队列
        Queue<String> queue = new LinkedList<String>();
        //ans存放答案
        List<String> ans = new LinkedList<String>();
        //标记是否被访问过
        boolean[] visited = new boolean[wordList.size()];
        //存放每个单词的前驱，比如hot的前驱可以是hit,lot等；
        HashMap<String,String> map = new HashMap<String,String>();
        //初步判断
        if(!wordList.contains(endWord)){
            return ans;
        }
        //将第一个单词加入队列
        queue.add(beginWord);
        boolean flag = false;
        //BFS主要操作
        while(queue.size() != 0){
            //先将头取出
            String queueHead = queue.poll();
            //如果队列头元素等于endword，代表已经找到，break同时设置flag = true;
            if(queueHead.equals(endWord)){
                flag = true;
                break;
            }
            //寻找可能的元素加入队列，并且设置对应的前驱。
            for(int i = 0;i < wordList.size();i ++){
                //如果未被访问过并且可以直接转换，则加入队列，compare()函数用来判断是否可以转换。
                if(visited[i] == false && compare(wordList.get(i),queueHead) == true){
                    queue.add(wordList.get(i));
                    visited[i] = true;
                    //存储前驱
                    map.put(wordList.get(i), queueHead);
                }
            }
        }
        if(flag == false){
            return ans;
        } 

        //遍历答案
        String key = endWord;
        while(map.get(key) != beginWord){
            ans.add(key);
            key = map.get(key);
        }
        ans.add(key);
        ans.add(map.get(key));
        Collections.reverse(ans);
        return ans;
    }
    public static boolean compare(String word1,String word2){
        int diff = 0;
        for(int i = 0;i < word1.length();i ++){
            if(word1.charAt(i) != word2.charAt(i)){
                diff ++;
                if(diff >= 2){
                    return false;
                }
            }
        }
        return true;
    }
```

## [310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

难度中等686

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。

给你一棵包含 `n` 个节点的树，标记为 `0` 到 `n - 1` 。给定数字 `n` 和一个有 `n - 1` 条无向边的 `edges` 列表（每一个边都是一对标签），其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 `x` 作为根节点时，设结果树的高度为 `h` 。在所有可能的树中，具有最小高度的树（即，`min(h)`）被称为 **最小高度树** 。

请你找到所有的 **最小高度树** 并按 **任意顺序** 返回它们的根节点标签列表。

树的 **高度** 是指根节点和叶子节点之间最长向下路径上边的数量。

![image-20220823230243896](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220823230243896.png)

------------------

首先，我们看了样例，发现这个树并不是二叉树，是多叉树。
然后，我们可能想到的解法是：根据题目的意思，就挨个节点遍历bfs，统计下每个节点的高度，然后用map存储起来，后面查询这个高度的集合里最小的就可以了。
但是这样会超时的。
于是我们看图（题目介绍里面的图）分析一下，发现，越是靠里面的节点越有可能是最小高度树。
所以，我们可以这样想，我们可以倒着来。
我们从边缘开始，先找到所有出度为1的节点，然后把所有出度为1的节点进队列，然后不断地bfs，最后找到的就是两边同时向中间靠近的节点，那么这个中间节点就相当于把整个距离二分了，那么它当然就是到两边距离最小的点啦，也就是到其他叶子节点最近的节点了。
然后，就可以写代码了。



```java

    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> res = new ArrayList<>();
        /*如果只有一个节点，那么他就是最小高度树*/
        if (n == 1) {
            res.add(0);
            return res;
        }
        /*建立各个节点的出度表*/
        int[] degree = new int[n];
        /*建立图关系，在每个节点的list中存储相连节点*/
        List<List<Integer>> map = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            map.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            degree[edge[0]]++;
            degree[edge[1]]++;/*出度++*/
            map.get(edge[0]).add(edge[1]);/*添加相邻节点*/
            map.get(edge[1]).add(edge[0]);
        }
        /*建立队列*/
        Queue<Integer> queue = new LinkedList<>();
        /*把所有出度为1的节点，也就是叶子节点入队*/
        for (int i = 0; i < n; i++) {
            if (degree[i] == 1) queue.offer(i);
        }
        /*循环条件当然是经典的不空判断*/
        while (!queue.isEmpty()) {
            res = new ArrayList<>();/*这个地方注意，我们每层循环都要new一个新的结果集合，
            这样最后保存的就是最终的最小高度树了*/
            int size = queue.size();/*这是每一层的节点的数量*/
            for (int i = 0; i < size; i++) {
                int cur = queue.poll();
                res.add(cur);/*把当前节点加入结果集，不要有疑问，为什么当前只是叶子节点为什么要加入结果集呢?
                因为我们每次循环都会新建一个list，所以最后保存的就是最后一个状态下的叶子节点，
                这也是很多题解里面所说的剪掉叶子节点的部分，你可以想象一下图，每层遍历完，
                都会把该层（也就是叶子节点层）这一层从队列中移除掉，
                不就相当于把原来的图给剪掉一圈叶子节点，形成一个缩小的新的图吗*/
                List<Integer> neighbors = map.get(cur);
                /*这里就是经典的bfs了，把当前节点的相邻接点都拿出来，
                * 把它们的出度都减1，因为当前节点已经不存在了，所以，
                * 它的相邻节点们就有可能变成叶子节点*/
                for (int neighbor : neighbors) {
                    degree[neighbor]--;
                    if (degree[neighbor] == 1) {
                        /*如果是叶子节点我们就入队*/
                        queue.offer(neighbor);
                    }
                }
            }
        }
        return res;/*返回最后一次保存的list*/
    }

```

## [1162. 地图分析](https://leetcode.cn/problems/as-far-from-land-as-possible/)

难度中等313

你现在手里有一份大小为 `n x n` 的 网格 `grid`，上面的每个 单元格 都用 `0` 和 `1` 标记好了。其中 `0` 代表海洋，`1` 代表陆地。

请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 `-1`。

我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：`(x0, y0)` 和 `(x1, y1)` 这两个单元格之间的距离是 `|x0 - x1| + |y0 - y1|` 。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex1.jpeg)**

```
输入：grid = [[1,0,1],[0,0,0],[1,0,1]]
输出：2
解释： 
海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。
```

---------------------------

方法1：bfs(普通的bfs会超时，代码如下：)

```java
   static int[] dx = {-1, 0, 1, 0};
    static int[] dy = {0, 1, 0, -1};
    int n;
    int[][] grid;

    public int maxDistance(int[][] grid) {
        this.n = grid.length;
        this.grid = grid;
        int ans = -1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 0) {
                    ans = Math.max(ans, findNearestLand(i, j));
                }
            }
        }
        return ans;
    }

    public int findNearestLand(int x, int y) {
        boolean[][] vis = new boolean[n][n];
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[]{x, y, 0});
        vis[x][y] = true;
        //这里对每一个点都进行了bfs 有很多重复的
        while (!queue.isEmpty()) {
            int[] f = queue.poll();
            for (int i = 0; i < 4; ++i) {
                int nx = f[0] + dx[i], ny = f[1] + dy[i];
                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {
                    continue;
                }
                if (!vis[nx][ny]) {
                    queue.offer(new int[]{nx, ny, f[2] + 1});
                    vis[nx][ny] = true;
                    if (grid[nx][ny] == 1) {
                        return f[2] + 1;
                    }
                }
            }
        }
        return -1;
    }


```

方法二：多源最短路

![image-20230116152007709](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230116152007709.png)

![image-20230116152024847](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230116152024847.png)

代码：

```java
  public int maxDistance(int[][] grid) {
           final int INF = 1000000;
        int[] dx = {-1, 0, 1, 0};
        int[] dy = {0, 1, 0, -1};
        int n = grid.length;
        int[][] d = new int[n][n];
        PriorityQueue<int[]> queue = new PriorityQueue<int[]>((o1,o2)->o1[0]-o2[0]);

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                //源点是陆地 陆地点集到某个海洋的最近距离 不能是海洋点集到某个陆地的最近距离，因为这种方法无法找到最近距离最大的那个海洋 因为海洋点集与某个陆地的最近距离只会去找这个海洋点集中那个离这个陆地最近的点 
                d[i][j] = INF;
            }
        }

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 1) {
                    d[i][j] = 0;
                    queue.offer(new int[]{0, i, j});
                }
            }
        }

        while (!queue.isEmpty()) {
         int[]temp=queue.poll();
         for(int i = 0;i<4;i++){
             int nx=temp[1]+dx[i],ny=temp[2]+dy[i];
             if(nx<0||ny<0||nx>=grid.length||ny>=grid.length) continue;//如果四周有墙，则continue
             int dis=temp[0];
             //这种情况说明遇到了海洋，因为d[i][j]如果[i,j]是陆地的话为0
             if(dis+1<d[nx][ny]){
                 d[nx][ny]=dis+1;//则陆地点集到[nx,ny]这个海洋点的最近距离发生修改
                 queue.offer(new int[]{dis+1,nx,ny});//这个海洋点放入队列中去,然后会继续查找它四周的点，使用优先级队列才会优先判断距离陆地点集最近的点
             }
         }
        }

        int ans = -1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 0) {
                    ans = Math.max(ans, d[i][j]);
                }
            }
        }

        return ans == INF ? -1 : ans;

    }

```

法三：动态规划
思路

。我们知道对于每个海洋区域 (x,y)，离它最近的陆地区域到它的路径要么从上方或者左方来，要么从右方或者下方来。考虑做两次动态规划，第一次从左上到右下，第二次从右下到左上，记 f(x,y) 为 (x,y) 距离最近的陆地区域的曼哈顿距离，我们初始化的时候把陆地的 f 值全部预置为 0，海洋的 f 全部预置为 INF，做完两个阶段的动态规划后，我们在所有的不为零的 f\[i][j] 中比一个最大值即可，如果最终比较出的最大值为 INF，就返回 -1。这里仍然源点集是陆地，f\[x][y]是源点到x y点的最近距离

代码：

```java
  public int maxDistance(int[][] grid) {
        final int INF = 1000000;
        int n = grid.length;
        int[][] f = new int[n][n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                f[i][j] = grid[i][j] == 1 ? 0 : INF;
            }
        }

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 1) {
                    continue;
                }
                if (i - 1 >= 0) {
                    f[i][j] = Math.min(f[i][j], f[i - 1][j] + 1);
                }
                if (j - 1 >= 0) {
                    f[i][j] = Math.min(f[i][j], f[i][j - 1] + 1);
                }
            }
        }

        for (int i = n - 1; i >= 0; --i) {
            for (int j = n - 1; j >= 0; --j) {
                if (grid[i][j] == 1) {
                    continue;
                }
                if (i + 1 < n) {
                    f[i][j] = Math.min(f[i][j], f[i + 1][j] + 1);
                }
                if (j + 1 < n) {
                    f[i][j] = Math.min(f[i][j], f[i][j + 1] + 1);
                }
            }
        }

        int ans = -1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 0) {
                    ans = Math.max(ans, f[i][j]);
                }
            }
        }

        if (ans == INF) {
            return -1;
        } else {
            return ans;
        }


```

## [面试题 04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/)

难度中等75

节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

**示例1:**

```
 输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2
 输出：true
```

**示例2:**

```
 输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4
 输出 true
```

**提示：**

1. 节点数量n在[0, 1e5]范围内。
2. 节点编号大于等于 0 小于 n。
3. 图中可能存在自环和平行边。

-------------------------





这里采用一个map表示每个结点可以到达哪些结点，然后再bfs的方法，又注意题目中说了是有向图，因此是单方向的

```java
  public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {

Map<Integer,List<Integer>>map=new HashMap<>();
for(int[]g:graph){
    if(map.containsKey(g[0])){
        //注意题目中说了是有向图
        List<Integer>temp=map.get(g[0]);
        temp.add(g[1]);
        map.put(g[0],temp);
    }else{
         List<Integer>temp=new ArrayList<>();
        temp.add(g[1]);
        map.put(g[0],temp);
    }
}
boolean[]vis=new boolean[100000];
Queue<Integer>queue=new LinkedList<>();
queue.add(start);
while(!queue.isEmpty()){
    int poll=queue.poll();
    List<Integer>get=map.get(poll);
    if(get==null) continue;
    for(int i = 0;i<get.size();i++){
        if(get.get(i)==target) return true;
        if(vis[get.get(i)]) continue;
        vis[get.get(i)]=true;
        queue.add(get.get(i));
    }
}
return false;
    }
```

## [1091. 二进制矩阵中的最短路径](https://leetcode.cn/problems/shortest-path-in-binary-matrix/)

难度中等245

给你一个 `n x n` 的二进制矩阵 `grid` 中，返回矩阵中最短 **畅通路径** 的长度。如果不存在这样的路径，返回 `-1` 。

二进制矩阵中的 畅通路径 是一条从 **左上角** 单元格（即，`(0, 0)`）到 右下角 单元格（即，`(n - 1, n - 1)`）的路径，该路径同时满足下述要求：

- 路径途经的所有单元格都的值都是 `0` 。
- 路径中所有相邻的单元格应当在 **8 个方向之一** 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。

**畅通路径的长度** 是该路径途经的单元格总数。

 ![image-20230130162731634](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230130162731634.png)

------

因为题目是最短路径，用bfs更合适（用dfs尝试了之后结果并不一定是最短的）

```java
 boolean[][]vis;

    public int shortestPathBinaryMatrix(int[][] grid) {
        int[][]turn=new int[][]{{1,1},{1,-1},{-1,1},{-1,-1},{1,0},{0,1},{-1,0},{0,-1}};
if(grid[0][0]!=0||grid[grid.length-1][grid.length-1]!=0) return -1;
if(grid.length==1) return 1;
vis=new boolean[grid.length][grid[0].length];


Deque<int[]>queue=new LinkedList<>();
queue.offer(new int[]{0,0});
int step=1;
while(!queue.isEmpty()){
    int size=queue.size();
for(int i = 0;i<size;i++){
int[]temp=queue.poll();
//vis只放在这里修改超时了,也可以两个地方都修改vis
vis[temp[0]][temp[1]]=true;
//
  for(int[]turnOne:turn){
      int x=temp[0],y=temp[1];
      
 if(x+turnOne[0]>=0&&x+turnOne[0]<grid.length&&y+turnOne[1]>=0&&y+turnOne[1]<grid.length&&grid[x+turnOne[0]][y+turnOne[1]]==0&&!vis[x+turnOne[0]][y+turnOne[1]])
 {
     if(x+turnOne[0]==grid.length-1&&y+turnOne[1]==grid.length-1) return step+1;
     //vis只有放在这个位置才不会超时，如果在最前面的地方修改vis结果超时了
vis[x+turnOne[0]][y+turnOne[1]]=true;
queue.offer(new int[]{x+turnOne[0],y+turnOne[1]});


 }
  }
}
//注意step+1的位置
step++;
}
return -1;
    }
```

## [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

难度中等894

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

 

**示例 1：**

```
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
```

---------------------

我们可以将整个问题建模成一张图：给定图中的一些点（变量），以及某些边的权值（两个变量的比值），试对任意两点（两个变量）求出其路径长（两个变量的比值）。

因此，我们首先需要遍历 equations 数组，找出其中所有不同的字符串，并通过哈希表将每个不同的字符串映射成整数。

在构建完图之后，对于任何一个查询，就可以从起点出发，通过广度优先搜索的方式，不断更新起点与当前点之间的路径长度，直到搜索到终点为止。



```java
public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int nvars = 0;
        //这是字符和对应的结点编号
        Map<String, Integer> variables = new HashMap<String, Integer>();

        int n = equations.size();
        for (int i = 0; i < n; i++) {
            if (!variables.containsKey(equations.get(i).get(0))) {
                variables.put(equations.get(i).get(0), nvars++);
            }
            //结点编号不能重复
            if (!variables.containsKey(equations.get(i).get(1))) {
                variables.put(equations.get(i).get(1), nvars++);
            }
        }

        // 对于每个点，存储其直接连接到的所有点及对应的权值，这是一个list数组，数组中的每个值都是一个list，数组中的索引对应的就是结点编号
        List<Pair>[] edges = new List[nvars];
        for (int i = 0; i < nvars; i++) {
            edges[i] = new ArrayList<Pair>();
        }
        for (int i = 0; i < n; i++) {
            int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));
            //表示va与vb连接了一条，从va到vb如果va/vb>1那么结点路径就为va/vb,否则为vb/va，这里value[i]就是一个点到另一个点的距离，注意不同方向距离不同
            edges[va].add(new Pair(vb, values[i]));
            edges[vb].add(new Pair(va, 1.0 / values[i]));
        }

        int queriesCount = queries.size();
        double[] ret = new double[queriesCount];
        for (int i = 0; i < queriesCount; i++) {
            List<String> query = queries.get(i);
            double result = -1.0;
            if (variables.containsKey(query.get(0)) && variables.containsKey(query.get(1))) {
                int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));
                if (ia == ib) {
                    result = 1.0;
                } else {
                    Queue<Integer> points = new LinkedList<Integer>();
                    points.offer(ia);
                    double[] ratios = new double[nvars];
                    Arrays.fill(ratios, -1.0);
                    ratios[ia] = 1.0;
                    

                    while (!points.isEmpty() && ratios[ib] < 0) {
                        int x = points.poll();
                        for (Pair pair : edges[x]) {
                            int y = pair.index;
                            double val = pair.value;
                            if (ratios[y] < 0) {
                                ratios[y] = ratios[x] * val;
                                points.offer(y);
                            }
                        }
                    }
                    result = ratios[ib];
                }
            }
            ret[i] = result;
        }
        return ret;
    }
}

class Pair {//inde编号 value是距离
    int index;
    double value;

    Pair(int index, double value) {
        this.index = index;
        this.value = value;
    }
}
```

方法二：
Floyd 算法
对于查询数量很多的情形，如果为每次查询都独立搜索一次，则效率会变低。为此，我们不妨对图先做一定的预处理，随后就可以在较短的时间内回答每个查询。

在本题中，我们可以使用 Floyd 算法，预先计算出任意两点之间的距离。

```java
 public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int nvars = 0;
        Map<String, Integer> variables = new HashMap<String, Integer>();

        int n = equations.size();
        for (int i = 0; i < n; i++) {
            if (!variables.containsKey(equations.get(i).get(0))) {
                variables.put(equations.get(i).get(0), nvars++);
            }
            if (!variables.containsKey(equations.get(i).get(1))) {
                variables.put(equations.get(i).get(1), nvars++);
            }
        }
        double[][] graph = new double[nvars][nvars];
        for (int i = 0; i < nvars; i++) {
            Arrays.fill(graph[i], -1.0);
        }
        for (int i = 0; i < n; i++) {
            int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));
            graph[va][vb] = values[i];
            graph[vb][va] = 1.0 / values[i];
        }

        for (int k = 0; k < nvars; k++) {
            for (int i = 0; i < nvars; i++) {
                for (int j = 0; j < nvars; j++) {
                    if (graph[i][k] > 0 && graph[k][j] > 0) {
                        graph[i][j] = graph[i][k] * graph[k][j];
                    }
                }
            }
        }

        int queriesCount = queries.size();
        double[] ret = new double[queriesCount];
        for (int i = 0; i < queriesCount; i++) {
            List<String> query = queries.get(i);
            double result = -1.0;
            if (variables.containsKey(query.get(0)) && variables.containsKey(query.get(1))) {
                int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));
                if (graph[ia][ib] > 0) {
                    result = graph[ia][ib];
                }
            }
            ret[i] = result;
        }
        return ret;
    }


```



# dfs/回溯

```
回溯搜索是深度优先搜索（DFS）的一种
对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。
```

**回溯 = dfs + 剪枝，**

## [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

难度中等717

给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

![image-20220201221324721](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220201221324721.png)

输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]

--------------

![image-20220201221420497](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220201221420497.png)

```java
 public void solve(char[][] board) {
for(int i = 0;i< board.length;i++)
{
    dfs(board,i,0);
    dfs(board,i,board[0].length-1);
}

for(int i = 0;i<board[0].length;i++)
{
    dfs(board,0,i);
    dfs(board,board.length-1,i);   
}
for(int i = 0;i < board.length;i++)
{
    for(int j = 0;j < board[0].length;j++)
    if(board[i][j]=='A')
    board[i][j]='O';
    else
    board[i][j]='X';
}
    }
    public void dfs(char[][]board,int i,int j)
    {
        if(i<0||i>=board.length||j<0||j>=board[0].length||board[i][j]!='O')
        return;
        board[i][j]='A';
        dfs(board,i+1,j);
        dfs(board,i,j+1);
        dfs(board,i-1,j);
        dfs(board,i,j-1);
    }

```



## 岛屿面积

给你一个大小为 m x n 的二进制矩阵 grid 。

岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

岛屿的面积是岛上值为 1 的单元格的数目。

计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。

![image-20220126231139775](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220126231139775.png)



注意：这里是要得到dfs遍历到的格子总数，因此需要得到返回值，与岛屿数量有差别，岛屿数量只需要把所有一堆的1集合起来再得到总数就行，且这里需要遍历所有的岛屿，得到每个岛屿的面积，计算出最大的那个

```java
    public int maxAreaOfIsland(int[][] grid) {
   int tot = 0;
for(int i=0;i < grid.length;i++)
{
for(int j =0;j < grid[0].length;j++)
{
 
// if(grid[i][j] == 1 )
    tot = Math.max(dfs(grid,i,j),tot);
}

}
return tot;

    }
    public int dfs(int[][]grid,int i,int j)
    {
        if(i <0||j < 0|| i==grid.length||j==grid[0].length||grid[i][j] == 0) return 0;
     
           // grid[i][j]=0;

int area = 1;
int[]d = new int[]{0,0,1,-1};
int[]z = new int[]{1,-1,0,0};
 grid[i][j] = 0;//对于是1的格子设置为0防止重复
  for(int row = 0;row < 4;row++)
  {
          area += dfs(grid,i+d[row],j+z[row]);//这里的总面积是所有的格子个数，向四面八方全部遍历，得到从一个格子出发的全部格子
      
  }
  return area;


    }
```



岛屿数量：

```java
    public int numIslands(char[][] grid) {
               if (grid == null || grid.length == 0) {
            return 0;
        }
int row = grid.length;
int col = grid[0].length;

int total = 0;
for(int i = 0;i < row;i++)
{
    for(int j = 0;j < col;j++)
    {
        if(grid[i][j] == '1' )
      {
          total++;
          dfs(i,j,grid);
      }  
    }
}
return total;
    }
    public void dfs(int row,int cal,char[][]grid)
    {
if(row >=0 && cal >= 0 && row <=grid.length-1 && cal <= grid[0].length -1 && grid[row][cal]=='1')
{
  grid[row][cal] ='0';
    dfs(row+1,cal,grid);
    dfs(row-1,cal,grid);
    dfs(row,cal-1,grid);
    dfs(row,cal+1,grid);
}
else
return;
    }
```

## 封闭岛屿数量

#### 

难度中等166

二维矩阵 `grid` 由 `0` （土地）和 `1` （水）组成。岛是由最大的4个方向连通的 `0` 组成的群，封闭岛是一个 `完全` 由1包围（左、上、右、下）的岛。

请返回 *封闭岛屿* 的数目。

 ![image-20221117180844344](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221117180844344.png)

----

dfs返回结果为：是否为封闭岛屿，两个终止条件

如果能够触及边界外，说明不是封闭岛屿，return false
如果g\[i][j]为水域，说明被阻拦了，return true



```java
    int row,col;
    int[][]array;
    public int closedIsland(int[][] grid) {
row = grid.length;col = grid[0].length;
array = grid;
int ans = 0;
for(int i = 0;i <row;i++){
    for(int j = 0;j < col;j++){
if(array[i][j]==0 && dfs(i,j))
    ans++;
    }
}
return ans;
    }
boolean dfs(int i,int j){
 
    if(i <0||i>=row||j<0||j>=col) return false;
       if(array[i][j] == 1) return true;
    array[i][j] = 1;
    //这里注意，如果写成&&会出错，必须是&，其中&&如果前面的条件不满足则直接不会计算后面的条件，而&是所有条件都会计算，这里如果使用&&会影响修改Array[i][j]=1的情况
    return dfs(i+1,j)&dfs(i,j+1)&dfs(i-1,j)&dfs(i,j-1);
}
也可以这样写：
    boolean b1 = dfs(i + 1, j);
        boolean b2 = dfs(i - 1, j);
        boolean b3 = dfs(i, j + 1);
        boolean b4 = dfs(i, j - 1);

        return b1 && b2 && b3 && b4;
```



## [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

难度中等707

有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

 [[1,0,0,1],[0,1,1,0],[0,1,1,1],[1,0,1,1]]

输出1

----

```java
   //深度优先搜索的思路是很直观的。遍历所有城市，对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索，通过矩阵isConnected 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量，然后对这些城市继续深度优先搜索，直到同一个连通分量的所有城市都被访问到，即可得到一个省份。遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。


int tot=0;
    public int findCircleNum(int[][] isConnected) {
        boolean[]vis=new boolean[isConnected.length];
for(int i=0;i<isConnected.length;i++)
{
    if(!vis[i])
    {
        dfs(isConnected,vis,i);
        tot++;
    }
}

return tot;
        
    }
    public void dfs(int[][]isConnected,boolean[]vis,int row)
    {
       
        for(int i=0;i<isConnected.length;i++)
        {
            if(isConnected[i][row]==1&& !vis[i])
            {
                vis[i]=true;
                dfs(isConnected,vis,i);
            }
        }

return;
    }
```

## 拓扑排序/循环依赖：课程表

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

 

示例 1：

输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。



----



![image-20220212213738920](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220212213738920.png)

在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。由于我们只需要判断是否存在一种拓扑排序，而栈的作用仅仅是存放最终的拓扑排序结果，因此我们可以只记录每个节点的状态，而省去对应的栈。

在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n*n* 个节点，从栈顶到栈底的顺序即为一种拓扑排序。

```java
 List<List<Integer>>mylist = new ArrayList<>();
    boolean valid = true;//注意初始设置为true
    public boolean canFinish(int numCourses, int[][] prerequisites) {
for(int i = 0;i<numCourses;i++)
mylist.add(new ArrayList<>());//每个结点对应一个搜索序列
int[]vis = new int[numCourses];//搜索状态
for(int i =0;i<prerequisites.length;i++)
{
    mylist.get(prerequisites[i][0]).add(prerequisites[i][1]);
}
for(int i = 0;i < numCourses;i++)
{
    if(vis[i]==0)
    dfs(vis,i);
}
return valid;
    }
    public void dfs(int[]vis,int coursenum)
    {
        vis[coursenum] = 1;
        for(int i = 0;i < mylist.get(coursenum).size();i++)
        {
            if(vis[mylist.get(coursenum).get(i)]==0 && valid)
            {
                dfs(vis,mylist.get(coursenum).get(i));
                if(!valid)
                return;
            }
            else if(vis[mylist.get(coursenum).get(i)]==1)//这种情况是一共搜索中的点在寻找其他点时又找到了自己，出现了环，即Valid置为False
            {
                valid = false;
                return;}
        }
        vis[coursenum] = 2;
    }
```

## [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

难度中等574

现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。

- 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。

与上面的题目唯一区别是，这个题目要求输出顺序（即不仅找到是否符合条件，还要输出符合条件的顺序）

---

```java
    boolean valid = true;
     int[]ans;//答案数组
     int[]vis;//用来表示访问的状态 0 未搜索 1 搜索中 2 搜索完
int tot;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
       ans = new int[numCourses];
       vis = new int[numCourses];
       tot = numCourses-1;//总量,用来得出数组下标
       List<List<Integer>>mylist = new ArrayList<>();
       for(int i = 0;i <numCourses;i++)
       mylist.add(new ArrayList<>());//每个点都是一个链表
       for(int i = 0;i <prerequisites.length;i++)
       mylist.get(prerequisites[i][1]).add(prerequisites[i][0]);//[i][1]在[i][0]的前面
       for(int i = 0;i <numCourses && valid;i++)
       {
           if(vis[i] == 0)
           dfs(i,mylist);
       }
       if(!valid) return new int[]{};
       return ans;

}
public void dfs(int index,List<List<Integer>>mylist )
{
vis[index] = 1;        // 将节点标记为「搜索中」
for(int i = 0;i <mylist.get(index).size();i++)
{
           // 搜索其相邻节点
        // 只要发现有环，立刻停止搜索
    int u = mylist.get(index).get(i);
    if(vis[u] == 0)
   { dfs(u,mylist);
   if(!valid)
   return;}
    else if(vis[u] == 1) {
        valid = false;
        return;
    } 
}
vis[index] = 2;
ans[tot--] = index;
}
    
```



## [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

难度困难594

给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。

 ![image-20220213182456969](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220213182456969.png)

-------------------

![image-20220213182618979](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220213182618979.png)

方法：记忆化搜索

```java
 public int longestIncreasingPath(int[][] matrix) {
         if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        vis = new boolean[matrix.length][matrix[0].length];
int[][]dp = new int[matrix.length][matrix[0].length];
int row = matrix.length,col = matrix[0].length;
for(int i = 0;i < row ;i++)
{
    for(int j = 0;j < col;j++ )
    {    
      maxlen = Math.max( maxlen,dfs(matrix,i,j,dp));
    }
}
return maxlen;
    }
    public int dfs(int[][]matrix,int i,int j,int[][]dp)
    {
 if(dp[i][j] != 0) return dp[i][j];
        int []row = new int[]{1,-1,0,0};
        int[]col = new int[]{0,0,1,-1};
        dp[i][j]++;
        for(int num = 0;num < 4;num++)
        {
            int ichange = i+row[num],jchange = j + col[num];
if(ichange>=0 && ichange< matrix.length && jchange>=0 && jchange < matrix[0].length && matrix[ichange][jchange]>matrix[i][j])
{
    dp[i][j] = Math.max(dp[i][j],dfs(matrix,ichange,jchange,dp)+1);

}
        }
    return dp[i][j];
    }
```





## 回溯法

其核⼼就是 for 循环⾥⾯的递归，在递归调⽤之前「做选择」，在递归调⽤之后「撤销选择」

代码⽅⾯，回溯算法的框架：
result = []
def backtrack(路径, 选择列表):
if 满⾜结束条件:
result.add(路径)
return
for 选择 in 选择列表:
做选择
backtrack(路径, 选择列表)
撤销选择

其核⼼就是 for 循环⾥⾯的递归，在递归调⽤之前「做选择」，在递归调⽤之后「撤销选择」

## 回溯之单词搜索

[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 ![image-20220128030623000](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220128030623000.png)

```java
 public boolean exist(char[][] board, String word) {
boolean[][]visited = new boolean[board.length][board[0].length];
for(int i = 0;i < board.length;i++)
{
    for(int j = 0;j < board[0].length;j++)
    {
        boolean flag = dfs(visited,board,i,j,word,0);
        if(flag) return true;
    }

}
return false;

    }
public boolean dfs(boolean[][]visited,char[][]board,int row,int col,String word,int k)
{
    if(board[row][col] != word.charAt(k)) return false;
    if(k == word.length()-1) return true;
    
visited[row][col] = true;

int[]d1 = new int[]{-1,1,0,0};
int[]d2 = new int[]{0,0,1,-1};
boolean res = false;
for(int i =0;i < 4;i++)
{
int newrow = row+d1[i];
int newcol = col+d2[i];

if(newrow<board.length&&newcol<board[0].length&&newrow>=0&&newcol>=0&&!visited[newrow][newcol])
{
boolean flag = dfs(visited,board,newrow,newcol,word,k+1);
if(flag) {
    res = true;
    break;
}
}
   
}
visited[row][col] = false;
return res;
}
```



多叉树的遍历框架就是这样：
void traverse(TreeNode root) {
for (TreeNode child : root.childern)
// 前序遍历需要的操作
traverse(child);
// 后序遍历需要的操作
}

##  数组全排列：

![](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211205085327074.png)

java实现的代码：

```java
   List<List<Integer>> ans = new ArrayList<>();
public List<List<Integer>> permute(int[] nums) {
if(nums== null||nums.length==0)
{
    return ans;
}
List<Integer> str= new ArrayList<>();
int len = nums.length;

 List<Integer> output = new ArrayList<Integer>();
        for (int num : nums) {
            output.add(num);
        }
allsort(len,0,output,ans);

return ans;
    }

    private void allsort(int len, int i, List<Integer> str, List<List<Integer>> ans) {
        if(i == len)
        {
            ans.add(new ArrayList<Integer>(str));
            
        }
        else {
            for (int j = i; j <len ; j++) {
                Collections.swap(str,i,j);
                allsort(len,i+1,str,ans);
                Collections.swap(str,i,j);
            }
        }
    }
```

也可以这样写：

输⼊⼀组不重复的数字，返回它们的全排列

注意这里回溯的时候遍历，是从0开始遍历的

```java
public class Fullqueue {
   public static List<List<Integer>> res = new LinkedList<>();
    /* 主函数，输⼊⼀组不重复的数字，返回它们的全排列 */
   public static List<List<Integer>> permute(int[] nums) {
LinkedList<Integer> li = new LinkedList<>();
backtrack(nums,li);
return res;
    }
    // 路径：记录在 track 中
// 选择列表：nums 中不存在于 track 的那些元素
// 结束条件：nums 中的元素全都在 track 中出现
  public static void backtrack(int[] nums, LinkedList<Integer> track) {
        if(nums.length == track.size())
        {
            System.out.println(track);
            res.add(track);
            System.out.println(res);
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if(track.contains(nums[i]))
            continue;
                track.add(nums[i]);//LinkedList add(E e)将指定元素添加到此列表的结尾。
                backtrack(nums, track);
                track.removeLast();

        }
    }

    public static void main(String[] args) throws InterruptedException {
        permute(new int[]{1,3,2});
      
        System.out.println(res);//不知道为什么这个输出的是空
    }
}

```

## [60. 排列序列/第k个排列](https://leetcode-cn.com/problems/permutation-sequence/)

难度困难643

给出集合 `[1,2,3,...,n]`，其所有元素共有 `n!` 种排列。

按大小顺序列出所有排列情况，并一一标记，当 `n = 3` 时, 所有排列如下：

1. `"123"`
2. `"132"`
3. `"213"`
4. `"231"`
5. `"312"`
6. `"321"`

给定 `n` 和 `k`，返回第 `k` 个排列。

----

这里必须用剪枝的办法，否则会超时

![image-20220319235045757](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220319235045757.png)

![image-20220319235704289](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220319235704289.png)

![image-20220319235724799](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220319235724799.png)

![image-20220319235748294](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220319235748294.png)

![image-20220319235809779](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220319235809779.png)

![image-20220319235837906](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220319235837906.png)

![image-20220319235850862](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220319235850862.png)

注意：0!=1，它表示了没有数可选的时候，即表示到达叶子结点了，排列数只剩下 1 个；
题目中说「给定 n 的范围是 [1, 9]」，可以把从 0 到 9 的阶乘计算好，放在一个数组里，可以根据索引直接获得阶乘值；





```java
StringBuilder str=new StringBuilder();
int index=0;
 int[] factorial;
  /**
     * 记录数字是否使用过
     */
    private boolean[] used;
    public String getPermutation(int n, int k) {
        factorial = new int[n+1];
        factorial[0]=1;
for(int i = 1;i <= n;i++)
factorial[i] = factorial[i-1] * i;

used = new boolean[n+1];
Arrays.fill(used,false);
backtrack(n,k,0);
return str.toString();
    }
    public void backtrack(int n,int k,int index)
    {
     
        if(index == n)
        {
return;
        }
           int num = factorial[n-1-index];//在这里每次递归的时候index的值+1，因此num也是越来越小，而且这里是已经选了index以后剩下的数排列的数量，比如说4个数，选了1，剩下三个数有3!种方案
     
        for(int i = 1;i<=n;i++)
        {
         if(used[i]) continue;//要记得用一个数组标记是否访问过，因为递归时每次循环都是从1开始，会经过已经访问的数字
         if(k > num) {
          k -=num;//注意这里k要减去剪完枝的num，标志前面num个排列要跳过
             continue;
         }
         str.append(i);//如果k<num,则所求的排列在这一个分支中
         used[i] = true;
         backtrack(n,k,index+1);
                     // 注意 1：不可以回溯（重置变量），算法设计是「一下子来到叶子结点」，没有回头的过程
            // 注意 2：这里要加 return，后面的数没有必要遍历去尝试了
            return;
        }
```

## 判断4个数能否凑成24

给出4个1-10的数字，通过加减乘除运算，得到数字为24就算胜利,除法指实数除法运算,运算符仅允许出现在两个数字之间,本题对数字选取顺序无要求，但每个数字仅允许使用一次，且需考虑括号运算

此题允许数字重复，如3 3 4 4为合法输入，此输入一共有两个3，但是每个数字只允许使用一次，则运算过程中两个3都被选取并进行对应的计算操作。

### 

读入4个[1,10]的整数，数字允许重复，测试用例保证无异常数字。

### 

对于每组案例，输出一行表示能否得到24点，能输出true，不能输出false

------

这里其实类似全排列的思路，同样是每个元素都需要进行选择，但是这里还多了一个运算操作，且注意只能用一次，只能用一次这里可以用一个vis数组来判断，利用索引来获得是否已经访问过该元素，同时除法要注意能够整除的时候才进行除法运算

```java
 public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
   
       int[]nums=new int[4];
       for(int i=0;i<4;i++)
       nums[i]=in.nextInt();
       boolean[]vis=new boolean[4];
       boolean ans=false;
 if(dfs(vis,nums,0))
    System.out.println(true);
    else System.out.println(false);
    }
    public static boolean dfs(boolean[]vis,int[]nums,int cur)
    {
        boolean four=true;
for(int i=0;i<4;i++)
{
    //判断是否四个数都访问完了
    if(!vis[i]){
        four=false;
        break;
    }
}
if(four)
return cur==24;//返回是否为24

for(int i=0;i<nums.length;i++)
{
    if(!vis[i])
    {
        vis[i]=true;//标记这个数字为已经访问
        if(dfs(vis,nums,cur+nums[i])||
        dfs(vis,nums,cur-nums[i])||dfs(vis,nums,cur*nums[i])
    ||nums[i]!=0&&cur%nums[i]==0&& dfs(vis,nums,cur/nums[i]))
    return true;
   vis[i]=false;//回溯
    }
}
return false;//如果走出了所有的，说明不存在24点，返回false
    }
```



## 含有重复元素的全排列

![image-20211218003213867](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211218003213867.png)

```java
   boolean[] vis;
    List<List<Integer>> theans= new ArrayList<List<Integer>>();
    public List<List<Integer>> permuteUnique(int[] nums) {
    Arrays.sort(nums);
List<List<Integer>> res = new ArrayList<>();
//boolean数组，used[i]表示元素nums[i]是否被访问过
boolean[] used = new boolean[nums.length];
//执行回溯算法
backtrack(nums, used, new ArrayList<>()list, res);
return res;
    }

   public void backtrack(int[] nums, boolean[] used, List<Integer> tempList, List<List<Integer>> res) {
//如果数组中的所有元素都使用完了，类似于到了叶子节点，
//我们直接把从根节点到当前叶子节点这条路径的元素加入
//到集合res中
if (tempList.size() == nums.length) {
res.add(new ArrayList<>(tempList));
return;
}
//遍历数组中的元素，注意是从0开始遍历的
for (int i = 0; i < nums.length; i++) {
//如果已经被使用过，则直接跳过
if (used[i])
continue;
//注意，这里要剪掉重复的组合 否则会有大量的重复排列 比如1223和1223两个相同的组合
    
//如果当前元素和前一个一样，并且前一个没有被使用过，我们也跳过
if (i > 0 && nums[i - 1] == nums[i] && !used[i - 1])
continue;
//否则我们就使用当前元素，把他标记为已使用
used[i] = true;
//把当前元素nums[i]添加到tempList中
tempList.add(nums[i]);
//递归，类似于n叉树的遍历，继续往下走
backtrack(nums, used, tempList, res);
//递归完之后会往回走，往回走的时候要撤销选择
used[i] = false;
tempList.remove(tempList.size() - 1);
}
}
```

## 按照进站顺序出站的全排列：火车进站



给定一个正整数N代表火车数量，0<N<10，接下来输入火车入站的序列，一共N辆火车，每辆火车以数字1-9编号，火车站只有一个方向进出，同时停靠在火车站的列车中，只有后进站的出站了，先进站的才能出站。

要求输出所有火车出站的方案，以字典序排序输出。

数据范围：1≤*n*≤10 

第一行输入一个正整数N（0 < N <= 10），第二行包括N个正整数，范围为1到10。



输出以字典序从小到大排序的火车出站序列号，每个编号以空格隔开，每个输出序列换行，具体见sample。



-------

```java
  static List<String>ans=new ArrayList<>();
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
       int n=in.nextInt();
       int[]arr=new int[n];
       for(int i=0;i<n;i++)
       arr[i]=in.nextInt();
     Stack<Integer>st=new Stack<>();
       dfs(arr,0,"",st,0);
    Collections.sort(ans);
    for(String s:ans)
    {
    
        System.out.println(s);
         
    }
    }
   public static void dfs(int[]arr, int begin, String cur, Stack<Integer> st,int len)
    {
        if(len==arr.length)
            ans.add(cur.toString());
    if(!st.isEmpty())
    {
        int temp=st.pop();
     //   cur.append(String.valueOf(temp)).append(" ");
     //注意这里不能修改cur,因为后面的判断还会用到cur变量，因此只能在参数里面修改
        dfs(arr,begin,cur+temp+" ",st,len+1);
        st.push(temp);
    }
    if(begin<arr.length)
    {
        st.push(arr[begin]);
        dfs(arr,begin+1,cur,st,len);
        st.pop();
    }
    }
    
```



## 回溯之寻找一个数组的所有子集

一个数组的所有子集，n个元素有2的n次方个子集

![image-20220126202232146](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220126202232146.png)

![image-20220126202304018](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220126202304018.png)

```java
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsets(int[] nums) {
        dfs(0, nums);
        return ans;
    }

    public void dfs(int cur, int[] nums) {
        if (cur == nums.length) {
            ans.add(new ArrayList<Integer>(t));
            return;
        }
        t.add(nums[cur]);
        dfs(cur + 1, nums);
        t.remove(t.size() - 1);
        dfs(cur + 1, nums);
    }
}


```



## 回溯之找到所有递增子序列 491

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

-----

```java
List<List<Integer>> ans = new ArrayList<List<Integer>>();
List<Integer> temp = new ArrayList<Integer>();
public void dfs(int cur, int[] nums) {
    if (cur == nums.length) {
        // 判断是否合法，如果合法判断是否重复，将满足条件的加入答案
        if (isValid() && notVisited()) {
            ans.add(new ArrayList<Integer>(temp));
        }
        return;
    }
    // 如果选择当前元素
    temp.add(nums[cur]);
    dfs(cur + 1, nums);
    temp.remove(temp.size() - 1);
    // 如果不选择当前元素
    dfs(cur + 1, nums);
}
```

这是一个递归枚举子序列的通用模板，即用一个临时数组 temp 来保存当前选出的子序列，使用 cur 来表示当前位置的下标，在 dfs(cur, nums) 开始之前，\[0,cur−1] 这个区间内的所有元素都已经被考虑过，而 \[cur,n] 这个区间内的元素还未被考虑。在执行 dfs(cur, nums) 时，我们考虑 cur 这个位置选或者不选，如果选择当前元素，那么把当前元素加入到 temp 中，然后递归下一个位置，在递归结束后，应当把temp 的最后一个元素删除进行回溯；如果不选当前的元素，直接递归下一个位置。

![image-20220209131721041](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220209131721041.png)

完整代码：

```java
  List<List<Integer>>  ans = new ArrayList<>();
    List<Integer>temp = new ArrayList<>();

    public List<List<Integer>> findSubsequences(int[] nums) {
dfs(nums,0,Integer.MIN_VALUE);
return ans;
    }
    public void dfs(int[]nums,int cur,int last)
    {
        if(cur == nums.length)
        {
            if(temp.size()>=2)
            ans.add(new ArrayList<>(temp));
            return;
        }

        if(nums[cur]>=last)
        {
            temp.add(nums[cur]);
            dfs(nums,cur+1,nums[cur]);
            temp.remove(temp.size()-1);
        }
        // 如果不选择当前元素
        if(nums[cur]!=last)//关键是这个，既要防止出现重复，又要做到不选择nums[cur]进行下一轮选择
        dfs(nums,cur+1,last);
    }
```





## 回溯之八皇后问题：



在棋盘上放置8个皇后，使得它们互不攻击，此时每个皇后的攻击范围为同行同列和同对角线，要求找出所有解

最简单的思路是把问题转化为“从64个格子中选一个子集”，使得“子集中恰好有8个格子，且任意两个选出的格子都不在同一行、同一列或同一个对角线上”。这正是子集枚举问题。然而，64个格子的子集有264个，太大了，这并不是一个很好的模型。
第二个思路是把问题转化为“从64个格子中选8个格子”，这是组合生成问题。根据组合数学，有![image-20210730145359444](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210730145359444.png)种方案，比第一种方案优秀，但仍然不够好。
经过思考，不难发现以下事实：恰好每行每列各放置一个皇后。如果用C[x]表示第x行皇后的列编号，则问题变成了全排列生成问题。而0～7的排列一共只有8!=40320个，枚举量不会超过它。



![image-20210730144315485](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210730144315485.png)

图7-5中给出了四皇后问题的完整解答树。它只有17个结点，比4!=24小。为什么会这样呢？这是因为有些结点无法继续扩展。例如，在(0,2,*,*)中，第2行无论将皇后放到哪里，都会和第0行和第1行中已放好的皇后发生冲突，其他还未放置的皇后更是如此。

**在这种情况下，递归函数将不再递归调用它自身，而是返回上一层调用，这种现象称为回溯（backtracking）。**

提示7-10：当把问题分成若干步骤并递归求解时，如果当前步骤没有合法选择，则函数将返回上一级递归调用，这种现象称为回溯。正是因为这个原因，递归枚举算法常被称为回溯法，应用十分普遍。

下面的程序简洁地求解了八皇后问题。在主程序中读入n，并为tot清零，然后调用search(0)，即可得到解的个数tot。



注意：既然是逐行放置的，则皇后肯定不会横向攻击，因此只需检查是否纵向和斜向攻击即可。条件“cur-C[cur] == j-C[j] || cur+C[cur] == j+C[j]”用来判断皇后(cur,C[cur])和(j,C[j])是否在同一条对角线上。其原理可以用图来说明。

![image-20210730152120304](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210730152120304.png)

程序效率可以继续提高：利用二维数组vis\[2][ ]直接判断当前尝试的皇后所在的列和两个对角线是否已有其他皇后。注意到主对角线标识y-x可能为负，存取时要加上n。

```c
void search(int cur) {
if(cur == n) tot++;
else for(int i = 0; i < n; i++) {
if(!vis[0][i] && !vis[1][cur+i] && !vis[2][cur-i+n]) {
//利用二维数组直接判断
C[cur] = i; //如果不用打印解，整个C数组都可以省略
vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 1; //修改全局变量
search(cur+1);
vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 0; //切记！一定要改回来
}
}
```

**一般地，如果在回溯法中修改了辅助的全局变量，则一定要及**
**时把它们恢复原状（除非故意保留所做修改）**

另一种写法：（java版本）

```c++
 List<List<String>> res = new ArrayList<>();

    /* 输入棋盘的边长n，返回所有合法的放置 */
    public List<List<String>> solveNQueens(int n) {
  char[][] board = new char[n][n];
        for (char[] c : board) {
            Arrays.fill(c, '.');
        }
           backtrack(board, 0);
        return res;
    }
      public void backtrack(char[][] board, int row) {
        // 每一行都成功放置了皇后，记录结果
        if (row == board.length) {
            res.add(charToList(board));  
            return;
        }
    int n = board[row].length;
        // 在当前行的每一列都可能放置皇后
        for (int col = 0; col < n; col++) {
            // 排除可以相互攻击的格子
            if (!isValid(board, row, col)) {
                continue;
            }
            // 做选择
            board[row][col] = 'Q';
            // 进入下一行放皇后
            backtrack(board, row + 1);
            // 撤销选择
            board[row][col] = '.';
        }
      }
  /* 判断是否可以在 board[row][col] 放置皇后 */
    public boolean isValid(char[][] board, int row, int col) {
        int n = board.length;
        // 检查列是否有皇后冲突
        for (int i = 0; i < n; i++) {
            if (board[i][col] == 'Q') {
                return false;
            }
        }

        // 检查右上方是否有皇后冲突
        for (int i = row - 1, j = col + 1; i >=0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }

        // 检查左上方是否有皇后冲突
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
    public List charToList(char[][] board) {
        List<String> list = new ArrayList<>();

        for (char[] c : board) {
            list.add(String.copyValueOf(c));
        }//这种写法比两个For循环要快很多
        return list;
    }
```

public static *String* *copyValueOf*(char[] data): 返回指定数组中表示该字符序列的字符串。 

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置
做⼀些操作，算法框架如下：
def backtrack(...):
for 选择 in 选择列表:
做选择
backtrack(...)
撤销选择

写 backtrack 函数时，需要维护⾛过的「路径」和当前可以做的「选择列
表」，当触发「结束条件」时，将「路径」记⼊结果集。

![image-20211213204802151](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211213204802151.png)

}

}

return true;}

##  40.组合总和II和为k的所有组合

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。

- 示例 1:
- 输入: candidates = [10,1,2,7,6,1,5], target = 8,
- 所求解集为:

```text
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

--------

注意这里题目中说了每个数字只能用一次，因此只需要判断这个数字跟前一个是否相等就行，不需要判断是否已经使用过

递归逻辑：

```java
  private  void backtrack(
        List<Integer>temp,int[]candidates,int target,int start)
        {
          if(target == 0)
          {
              result.add(new ArrayList<>(temp));
          }
          for(int i = start;i < candidates.length;i++)
          {
              if(candidates[i] > target) continue;//这个判断一定要加，不然会超时
              if(i > start && candidates[i] == candidates[i-1])
              continue;
              temp.add(candidates[i]);
              backtrack(temp,candidates,target-candidates[i],i+1);
              temp.remove(temp.size()-1);
          }

        }
```





## 素数环（Prime Ring Problem, UVa 524） 

样例输入：
6
样例输出：
1 4 3 2 5 6
1 6 5 2 3 4



```c
void dfs(int cur){
if(cur == n && isp[A[0]+A[n-1]]){ //递归边界。别忘了测试第一个数和最后一个数
for(int i = 0; i < n; i++) printf("%d ", A[i]); //打印方案
printf("\n");
}
else for(int i = 2; i <= n; i++) //尝试放置每个数i
if(!vis[i] && isp[i+A[cur-1]]){ //如果i没有用过，并且与前一个数之和为素数
A[cur] = i;
vis[i] = 1; //设置使用标志
dfs(cur+1);
vis[i] = 0; //清除标志
}
}
```

回溯法比生成-测试法快了很多，即使n=18速度也不错。将上面的函数名设为dfs并不是巧合——从解答树的角度讲，回溯法正是按照深度优先的顺序在遍历解答树。在后面的内容中，还将学习更多遍历解答树的方法。

## [剑指 Offer II 085. 生成匹配的括号](https://leetcode-cn.com/problems/IDBivT/)

![image-20211210153326059](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211210153326059.png)





代码：

```java
   List<String> ansstr = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
  List<String> ansstr = new ArrayList<>();
        StringBuilder sb = new StringBuilder("(");


        backtrack(sb,n-1,n,ansstr);
        return ansstr;
    }

    private void backtrack(StringBuilder sb, int leftcount,int rightcount, List<String> ansstr) {
        if(leftcount == 0 && rightcount == 0)
            ansstr.add(sb.toString());
        if(leftcount >0)
        {
           sb.append("(");
               backtrack(sb,leftcount-1,rightcount,ansstr);
sb.deleteCharAt(sb.length()-1);
        }
        if(leftcount <rightcount)
        {
            sb.append(")");
            backtrack(sb,leftcount,rightcount-1,ansstr);
            sb.deleteCharAt(sb.length()-1);
        }
        }
```



## [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![image-20211214110722798](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211214110722798.png)



回溯法：

```java
public List<String> letterCombinations(String digits) {
   List<String> combinations = new ArrayList<String>();
        if (digits.length() == 0) {
            return combinations;
        }
        Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};

backtrack(combinations,phoneMap,digits,0,new StringBuilder());
return combinations;
    }

    private void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits,int index, StringBuilder stringBuilder) {
   if(index == digits.length())
   {
       combinations.add(stringBuilder.toString());
   }
   else {
       char arr = digits.charAt(index);//第index位置上的数字
       String letters = phoneMap.get(arr);//这个数字对应的字母
       for (int i = 0; i < letters.length(); i++) {
           stringBuilder.append(letters.charAt(i));//获得这个字符串第i位置的字母
           backtrack(combinations,phoneMap,digits,index+1,stringBuilder);//递归
           stringBuilder.deleteCharAt(stringBuilder.length()-1);//移除最后一个字母
       }

   }
       


```



## 火柴拼正方形

![image-20211224011531282](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211224011531282.png)





```java

public boolean makesquare(int[] matchsticks) {

int total = 0;
  for(int i:matchsticks)

{
 total += i;
}
if(total% 4 != 0) {
//如果所有火柴的长度不是4的倍数，直接返回false
  return false;
    }
   int[]size = new int[4];

   Arrays.sort(matchsticks);
    return backtrack(matchsticks,matchsticks.length-1,total>>2,size);

  }

   private boolean backtrack(int[] matchsticks, int index, int total, int[] size) {
    if(index== -1) {
//如果火柴都访问完了，并且size的4个边的长度都相等，说明是正方形，直接返回true，
//否则返回false
      if (size[1] == size[0] && size[1] == size[2] && size[2] == size[3])

       return true;
    return false;
  }
 for (int i = 0; i < size.length; i++) {
 if(size[i]+matchsticks[index] > total)
  continue;
  size[i] += matchsticks[index];
 if( backtrack(matchsticks,index-1,total,size))
 return true;
 size[i] -=matchsticks[index];
}
 return false;

  }


```

![image-20211224011813902](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211224011813902.png)

-----

注意，也可以用下面的方法，且下面的方法更好理解：

```java
boolean[]used;
    public boolean makesquare(int[] matchsticks) {
int[]nums = matchsticks;
        int sum=0;
        int k = 4;
       used=new boolean[nums.length];
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++)
        {
            sum+=nums[i];
        }
        if(sum%k!=0)
            return false;
        int target=sum/k;
        if(nums[nums.length-1]>target)
            return false;
        return dfs(nums,nums.length-1,target,k,0);
    }
public boolean dfs(int[]nums,int index,int sum,int k,int cursum)
    {
        if(k==1) return true;
      
        if(sum == cursum)
        {
          return  dfs(nums, nums.length-1,sum,k-1,0);//仍然要从num.length-1开始递归，因为并不是用过的元素都集中到最后几个了，也有可能最前面的与最后面的进行组合
        }
        for(int i = index;i>=0;i--)
        {
              if(used[i]) continue;//如果用过这个元素就跳过，不选这个
            if(cursum+nums[i]>sum)
            continue;
         
            used[i] = true;
            if(dfs(nums,i-1, sum ,k, cursum +nums[i]))
            return true;
            used[i] = false;
        
        }
        return false;
      
    }
```



## [698. 划分为k个相等的子集](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/)

难度中等497

给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

 

**示例 1：**

```
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
```

---

这个题跟火柴题基本是完全一样的，代码都不用改

```java
public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum=0;
       used=new boolean[nums.length];
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++)
        {
            sum+=nums[i];
        }
        if(sum%k!=0)
            return false;
        int target=sum/k;
        if(nums[nums.length-1]>target)
            return false;
        return dfs(nums,nums.length-1,target,k,0);
    }
public boolean dfs(int[]nums,int index,int sum,int k,int cursum)
    {
        if(k==1) return true;
      
        if(sum == cursum)
        {
          return  dfs(nums, nums.length-1,sum,k-1,0);//仍然要从num.length-1开始递归，因为并不是用过的元素都集中到最后几个了，也有可能最前面的与最后面的进行组合
        }
        for(int i = index;i>=0;i--)
        {
              if(used[i]) continue;//如果用过这个元素就跳过，不选这个
            if(cursum+nums[i]>sum)
            continue;
         
            used[i] = true;
            if(dfs(nums,i-1, sum ,k, cursum +nums[i]))
            return true;
            used[i] = false;
        
        }
        return false;
      
    }
```



## 字符的全部排列数

![image-20211224015553477](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211224015553477.png)

![image-20211224015734538](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211224015734538.png)

前面介绍的几个组合的回溯算法， 因为结果不能有重复的（ 比如[ 1 ， 3 ] 和[ 3 ， 1 ] 被认为
是重复的结果） ， 所以每次选择的时候都只能从前往后选。但这题中子集[ A ， B ] 和[ B ，
A ] 被认为是两种不同的结果， 所以每次都要从头开始选择， 因为每个字符只能被使用一
次， 所以如果使用之后下次就不能再使用了， 这里可以使用一个数组v i s i t 来标记有没有
被使用。
但这里有个难点就是怎么过滤掉上面图中灰色的部分（ 也就是重复的部分） 。举个例
子， 比如A B B C D ， 如果我们选择了第1 个B ， 那么剩余的字符就变成了A B C D ， 这个时
候我们再选择第2 个B 是可以的。但如果我们没选择第1 个B ， 直接选择第2 个B ， 那么剩
余的字符就是A B C D ， 和上面重复了。所以代码大致是这样的
 if (i - 1 >= 0 && chars[i] == chars[i - 1] && !used[i - 1])
continue;

![image-20211224015848797](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211224015848797.png)

## [842. 将数组拆分成斐波那契序列](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/)

难度中等

给定一个数字字符串 `num`，比如 `"123456579"`，我们可以将它分成「斐波那契式」的序列 `[123, 456, 579]`。

形式上，**斐波那契式** 序列是一个非负整数列表 `f`，且满足：

- `0 <= f[i] < 231` ，（也就是说，每个整数都符合 **32 位** 有符号整数类型）
- `f.length >= 3`
- 对于所有的`0 <= i < f.length - 2`，都有 `f[i] + f[i + 1] = f[i + 2]`

另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 `0` 本身。

返回从 `num` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]`。

 

**示例 1：**

```
输入：num = "1101111"
输出：[11,0,11,11]
解释：输出[110,1,111]也可以。(110+1=111)
```

----

用回溯法，每个字符都进行试验

```java
 List<Integer>ans = new ArrayList<>();

  public List<Integer> splitIntoFibonacci(String num) {
    dfs(ans,num.length(),0,0,0,num);
     return ans;
  }
  public boolean dfs(List<Integer>ans,int len,int index,int sum,int prev,String num)
  {
   if(index == len)
    {
      return ans.size()>=3;
    }
   long curlong = 0;

   for(int i = index;i <len;i++)

   {

      if(i >index && num.charAt(index)=='0') break;//每个块的数字一定不要以零开头，除非这个块是数字 0 本身。

curlong= curlong*10+num.charAt(i) - '0';

if(curlong >Integer.MAX_VALUE)//判断值是否溢出
break; 
int cur = (int)curlong;
if(ans.size()>=2)//结果集中元素个数是否达到要求

{
if(cur > sum)

break;

else if(cur<sum)
continue;
}
 ans.add(cur);

 //注：sum=此时的数+上一个数字，而不是之前的所有数字

if(dfs(ans,len,i+1,prev+cur,cur,num))

return true;

else

ans.remove(ans.size()-1);    

    }

  return false;

  }
```

## 组合总数

注意下面这个题中数字不可以重复使用

![image-20211224134952304](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211224134952304.png)





解答：

```java
 public List<List<Integer>> combinationSum2(int[] candidates, int target) {
   List<List<Integer>> result = new ArrayList<>();
   Arrays.sort(candidates);//记得要先排序
            backtrack(result, new ArrayList<>(), candidates, target,0);
            return result;
        }
        private static void backtrack(List<List<Integer>> result,
        List<Integer>temp,int[]candidates,int target,int start)
        {
            if(target == 0)
            {
                result.add(new ArrayList<>(temp));//尤其注意这里要记得new一个数组，否则删除的全是空数组
                return;
            }
            for(int i = start;i < candidates.length;i++)
            {
                  //如果当前节点大于target我们就不要选了
                if(target < candidates[i])
                continue;
                if(i > start && candidates[i] ==candidates[i-1])//如果不加这个判断的话会出现相同的组合数，答案不对
                continue;
               
                temp.add(candidates[i]);
 
                backtrack(result,temp, candidates, target - candidates[i],i+1);
                    //回到当前节点的时候我们把当前节点给移除,
     // 然后通过循环走同一层的其他节点。
       //举个例子，比如上面图中，最开始的时候
       // 我们先选择2，然后沿着这个分支走下去，
       //当回到当前分支的时候我们把2给移除，然后
        // 选择同一层的下一个3，沿着这个节点
    //分支走下去……
                temp.remove(temp.size()-1);//注意这里相当于进行了回溯
            }
        }
```

组合数字2：



![image-20211224135421252](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211224135421252.png)

![image-20211224135608431](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211224135608431.png)



这个题中每个数字可以重复使用，这与上面题目的区别在于：不需要进行 if(i > start && candidates[i] ==candidates[i-1])这个判断，且递归时  backtrack(result,temp, candidates, target - candidates[i],i+1);不再是i+1而是i(这样下次的时候可以再次把i加入到数组中)

为什么要加一个变量start,用来从这个位置进行访问：如果不加start而是用  for (int i = 0; i < candidates.length; i++) 会出现[2,3,3],[3,2,3],[3,3,2]

出现了重复的数据，[2,3,3],[3,2,3],[3,3,2]其实应该只算一个。在上面的图中我们分析过，如果选择了后面的数字就不能再选择前面的了，因为这样会出现重复，所以我们可以添加一个变量start表示访问的数组中元素的位置，我们只能访问start和start后面的数字

## [77. 组合](https://leetcode-cn.com/problems/combinations/)

难度中等890

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

 

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

-----

```java
 List<List<Integer>>ans = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        
backtrack(n,k,1,new ArrayList<>());

return ans;
    }
    public void backtrack(int n,int k,int indexnow,List<Integer>temp)
    {
         if (temp.size() + (n - indexnow + 1) < k) {
            return;//利用这个条件来判重
        }
        if(temp.size() == k)
        {
           
            if(!ans.contains(temp))
            ans.add(new ArrayList<>(temp));
            return;
        }
  
                temp.add(indexnow);//选择当前位置
                backtrack(n,k,indexnow+1,temp);
                temp.remove(temp.size()-1);
             backtrack(n,k,indexnow+1,temp);//不选择当前位置
        
    }

```

## 78.子集

给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

 

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：

输入：nums = [0]
输出：[[],[0]]



----

![image-20230408223636453](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230408223636453.png) 

```java
List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsets(int[] nums) {

        for (int i = 0; i < (1<<nums.length); i++) {
            t.clear();
            for (int j = 0; j < nums.length; j++) {
                if((i&(1<<j))!=0)
                    t.add(nums[j]);
            }//这里一定要改成new ArrayList,不能直接add(t)
            ans.add(new ArrayList<Integer>(t));
        }
      return ans;
    }
```



## [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

难度中等

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如："0.1.2.201" 和 "192.168.1.1" 是 **有效** IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你不能重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

```java
   List<String>str = new LinkedList<>();
     int[]segement =new int[4];//存放四个ip地址，每个ip对应每一个数组元素
    public List<String> restoreIpAddresses(String s) {
segement =new int[4];
dfs(s,0,0);
return str;
    }
    public void dfs(String s,int segmentid,int start)
    //segmentid对应的是上面Segement数组中的下标，Start对应的是字符串s中的下标，s.charat(start)表明索引为Start的字符
    {
        //     // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
if(segmentid==4)
{
    if(start==s.length()){
    StringBuilder temp=new StringBuilder();
    
for(int i = 0;i<4;i++)
{
    temp.append(segement[i]);
    if(i!=3)
    temp.append(".");
}
str.add(temp.toString());
}
return;
}
 // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
if(start==s.length())
return;
if(s.charAt(start)=='0')
{
    segement[segmentid]=0;
    dfs(s,segmentid+1,start+1);
}
int addr=0;
for(int i = start;i<s.length();i++)
{
addr = addr*10+s.charAt(i)-'0';
if(addr>0&&addr<=255)
{
segement[segmentid]=addr;
dfs(s,segmentid+1,i+1);
}
else
break;//如果没有这个else break答案是错的
}
    }
```



## [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

难度困难

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。

字符串的一个 **子序列** 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是 `"ABCDE"` 的一个子序列，而 `"AEC"` 不是）

题目数据保证答案符合 32 位带符号整数范围。

 

**示例 1：**

```
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabbbit
rabbbit
rabbbit
```

抓住 “选”，s 要照着 t 来挑选，逐字符考察选或不选，分别来到什么状态？

举例，s 为babgbag，t 为bag，末尾字符相同，于是 s 有两种选择：

用s[s.length-1]去匹配掉t[t.length-1]，问题规模缩小：继续考察babgba和ba
不这么做，但t[t.length-1]仍需被匹配，于是在babgba中继续挑，考察babgba和bag

![image-20220205114824432](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220205114824432.png)



## [44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)



给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

-----

![image-20220205120314173](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220205120314173.png)

```java
 public boolean isMatch(String s, String p) {
int len1=s.length(),len2=p.length();
boolean[][]dp=new boolean[len1+1][len2+1];
for(int i =1;i<=len2;i++)
if(p.charAt(i-1)=='*')
dp[0][i]=true;

else break;
dp[0][0]=true;
for(int i=1;i<=len1;i++)
{
    for(int j=1;j<=len2;j++)
    {
        if(p.charAt(j-1)=='*')
        dp[i][j]=dp[i-1][j]||dp[i][j-1];
     else   if(p.charAt(j-1)=='?'||s.charAt(i-1)==p.charAt(j-1))
        dp[i][j] = dp[i-1][j-1];
      
    }
}
return dp[len1][len2];
    }
```

## [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

难度中等1031

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 **示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

---

```java
   int total=0;
    public int findTargetSumWays(int[] nums, int target) {
backtrack(nums,target,0,0);
return total;
    }
    public void backtrack(int[]nums,int target,int index,int sum)
    {
         if(index==nums.length){
        if(sum==target)
        {
            total++;
            return;
        }
         }
        else{
        backtrack(nums,target,index+1,sum+nums[index]);
          backtrack(nums,target,index+1,sum-nums[index]);
        }
    }
```

## [386. 字典序排数](https://leetcode-cn.com/problems/lexicographical-numbers/)

给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。

你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。

 

示例 1：

输入：n = 13
输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]

----



```java
  public List<Integer> lexicalOrder(int n) {
List<Integer>ans = new ArrayList<>();
dfs(ans,0,1,n);//第一轮Start是1
return ans;
    }
    public void dfs(List<Integer>ans,int base,int start,int n)
    {
        if(base>n) return;
        for(int i =start;i<10;i++)
        {
            int num = i+base;
            if(num<=n)
            {
                ans.add(num);
                dfs(ans,num*10,0,n); //这里start是0
            } 
        }
    }
```





## [440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

难度困难275

给定整数 `n` 和 `k`，返回 `[1, n]` 中字典序第 `k` 小的数字。

 

**示例 1:**

```
输入: n = 13, k = 2
输出: 10
解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

----

算法需要用到递归，实际上是多叉树（字典树）问题

![image-20230219224417807](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230219224417807.png)

```java
 public int findKthNumber(int n, int k) {
int cur = 1;//第1个字典序最小的是1
int prefix = 1;//字典序从1开始
while(cur < k)
{
    int temp = getcount(n,prefix);
    if(temp+cur > k)
    {
prefix *=10;
cur++;
    }
    else
    {
        prefix++;
        cur+=temp;//比方说从1前缀到了2前缀
    }
}
return prefix;
    }
   
    public int getcount(int n,int prefix)
    {
        long cur = prefix;
        long next = cur+1;//1的下一个前缀是2
        int count = 0;
        while(cur <= n)
        {
count += Math.min(n+1,next) - cur;//一开始cur =1,next = 2,count = 0+1=1,比如n=12 next = 100,则count+=13-cur = 3
next*=10;
cur*=10;
        }
        return count;
    }
```

也可以这样写：

```java
 public int findKthNumber(int n, int k) {
        int curr = 1;
        k--;
        while (k > 0) {
            int steps = getSteps(curr, n);
            if (steps <= k) {//不在cur的子树中，k要减去step,cur+1表示变为兄弟节点
                k -= steps;
                curr++;
            } else {  //k在cur的子树中，k减一
                curr = curr * 10;
                k--;
            }
        }
        return curr;
    }

    public int getSteps(int curr, long n) {
        int steps = 0;
        long first = curr;
        long last = curr;
        while (first <= n) {
            steps += Math.min(last, n) - first + 1;
            first = first * 10;
            last = last * 10 + 9;
        }
        return steps;
    }


```





## [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

难度困难1141

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

board.length == 9
board[i].length == 9
board[i][j] 是一位数字或者 '.'
题目数据 保证 输入数独仅有一个解



------------

我们可以考虑按照「行优先」的顺序依次枚举每一个空白格中填的数字，通过递归 + 回溯的方法枚举所有可能的填法。当递归到最后一个空白格后，如果仍然没有冲突，说明我们找到了答案；在递归的过程中，如果当前的空白格不能填下任何一个数字，那么就进行回溯。

由于每个数字在同一行、同一列、同一个九宫格中只会出现一次，因此我们可以使用line[i]，column[j]，block\[x][y] 分别表示第 i 行，第 j 列，第 (x,y) 个九宫格中填写数字的情况。在下面给出的三种方法中，我们将会介绍两种不同的表示填写数字情况的方法。

九宫格的范围为 0≤x≤2 以及0≤y≤2。
具体地，第 i 行第 j 列的格子位于第i/3, j/3  个九宫格中，其中

最容易想到的方法是用一个数组记录每个数字是否出现。由于我们可以填写的数字范围为 [1, 9][1,9]，而数组的下标从 00 开始，因此在存储时，我们使用一个长度为 99 的布尔类型的数组，其中 ii 个元素的值为 \text{True}True，当且仅当数字 i+1i+1 出现过。例如我们用 \textit{line}[2][3] = \text{True}line[2][3]=True 表示数字 44 在第 22 行已经出现过，那么当我们在遍历到第 22 行的空白格时，就不能填入数字 44。

算法

我们首先对整个数独数组进行遍历，当我们遍历到第 ii 行第 jj 列的位置：

如果该位置是一个空白格，那么我们将其加入一个用来存储空白格位置的列表中，方便后续的递归操作；

如果该位置是一个数字 xx，那么我们需要将line\[i][x−1]，column\[j][x−1] 以及block\[⌊i/3⌋]\[⌊j/3⌋][x−1] 均置为 True。

当我们结束了遍历过程之后，就可以开始递归枚举。当递归到第 i行第 j 列的位置时，我们枚举填入的数字 x。根据题目的要求，数字 xx 不能和当前行、列、九宫格中已经填入的数字相同，因此 line\[i][x−1]，column\[j][x−1] 以及 block\[⌊i/3⌋]\[⌊j/3⌋][x−1] 必须均为False。

当我们填入了数字 x 之后，我们要将上述的三个值都置为True，并且继续对下一个空白格位置进行递归。在回溯到当前递归层时，我们还要将上述的三个值重新置为 False。

```java
boolean[][]lines;
boolean[][]rows;
boolean[][][]newbools;
boolean valid;
List<int[]>mylist = new ArrayList<>();
    public void solveSudoku(char[][] board) {
lines = new boolean[board.length][9];
rows = new boolean[9][9];

newbools = new boolean[3][3][9];
for(int i = 0;i < board.length;i++)
{
    for(int j = 0;j < board[0].length;j++)
    {
        if(board[i][j] == '.')
        {
            mylist.add(new int[]{i,j});
          
        }
        else
        {
            int number = board[i][j]-'0'-1;
            lines[i][number] = true;
            rows[j][number] = true;
            newbools[i/3][j/3][number] = true;
        }
    }
}
dfs(board,0);
    }
    public void dfs(char[][]board,int tot)
    {
        if(tot == mylist.size()) {//如果所有为'.'的点都填完了，返回true
            valid = true;
return;
        }
        int[]space = mylist.get(tot);//目前要填的格子
        int row = space[0],col = space[1];
        for(int i = 0;i <9&&!valid;i++)
        {
if(!lines[row][i] && !rows[col][i]  && !newbools[row/3][col/3][i])
{
    lines[row][i] =rows[col][i]=newbools[row/3][col/3][i]=true;
    board[row][col] =(char)( i+'0'+1);
    dfs(board,tot+1);
      lines[row][i] =rows[col][i]=newbools[row/3][col/3][i]=false;
}
        }
    }
```

## [面试题 08.02. 迷路的机器人](https://leetcode.cn/problems/robot-in-a-grid-lcci/)(从左上角到右下角的路径)

难度中等103

设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]
解释: 
输入中标粗的位置即为输出表示的路径，即
0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角）





-------------------

思路：这里为了提高效率，需要用一个状态来判断是否走过这个格子，这里可以直接用给定的数组，用状态2表示已经走过，因为是递归，可以逆向思维，从终点开始走到起点，这样答案列表就已经是从起点开始的了，然后注意边界条件，比如数组\[i][j]这种地方是要不能越界的

```java
       static List<List<Integer>> result = new ArrayList<>();

  public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {
        result.clear();
        if (obstacleGrid[0][0] == 1) return result;
dfs(obstacleGrid,obstacleGrid.length-1,obstacleGrid[0].length-1);

return result;
    }
    public boolean dfs(int[][] obstacleGrid, int i, int j){
       if (i==0 && j==0) {
            add(i, j);
            return true;
        }

        if (obstacleGrid[i][j] > 0) return false;
        obstacleGrid[i][j] = 2;
        if (i>0 && dfs(obstacleGrid, i-1, j)) {
            //如果从这个i点的左边的路径最终可以到达起始点，记得把(i,j)这个点加入队列中去，由于dfs判断为true时已经是到了起始点了，所以这里加入队列的坐标点都是路径上的点
            add(i, j);
            return true;
        }
        if (j>0 && dfs(obstacleGrid, i, j-1)) {
            add(i, j);
            return true;
        }
        //不取消标记

        return false;
    }
      public void add(int i,int j){
         List<Integer> list = new ArrayList<>();
        list.add(i);
        list.add(j);
        result.add(list);


    }
```

## [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

难度中等337

给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）

 `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。

-------------------

![image-20220921135427846](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220921135427846.png)

```java
 List<List<Integer>> ans = new ArrayList<List<Integer>>();
    Deque<Integer> stack = new ArrayDeque<Integer>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        stack.push(0);
        dfs(graph, 0, graph.length - 1);
        return ans;
    }

    public void dfs(int[][] graph, int x, int n) {
      if(x==n){
          ans.add(new ArrayList<>(stack));
      }
      for(int i:graph[x]){
          //因为是有向图，不会出现重复的情况，这里i是x可以到达的结点，采用深度优先遍历的方法，遍历每一个结点可以到达的结点
          //注意这里要用offerlast,插入指定元素到双端队列的末尾处
stack.offerLast(i);
dfs(graph,i,n);
stack.pollLast();
      }
```

## [529. 扫雷游戏](https://leetcode.cn/problems/minesweeper/)

难度中等315

让我们一起来玩扫雷游戏！

给你一个大小为 `m x n` 二维字符矩阵 `board` ，表示扫雷游戏的盘面，其中：

- `'M'` 代表一个 **未挖出的** 地雷，
- `'E'` 代表一个 **未挖出的** 空方块，
- `'B'` 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 **已挖出的** 空白方块，
- **数字**（`'1'` 到 `'8'`）表示有多少地雷与这块 **已挖出的** 方块相邻，
- `'X'` 则表示一个 **已挖出的** 地雷。

给你一个整数数组 `click` ，其中 `click = [clickr, clickc]` 表示在所有 **未挖出的** 方块（`'M'` 或者 `'E'`）中的下一个点击位置（`clickr` 是行下标，`clickc` 是列下标）。

根据以下规则，返回相应位置被点击后对应的盘面：

1. 如果一个地雷（`'M'`）被挖出，游戏就结束了- 把它改为 `'X'` 。
2. 如果一个 **没有相邻地雷** 的空方块（`'E'`）被挖出，修改它为（`'B'`），并且所有和其相邻的 **未挖出** 方块都应该被递归地揭露。
3. 如果一个 **至少与一个地雷相邻** 的空方块（`'E'`）被挖出，修改它为数字（`'1'` 到 `'8'` ），表示相邻地雷的数量。
4. 如果在此次点击中，若无更多方块可被揭露，则返回盘面。

![image-20221003190320927](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221003190320927.png)

------------------



```java
 public char[][] updateBoard(char[][] board, int[] click) {

    if(board[click[0]][click[1]]=='M') {
           board[click[0]][click[1]] = 'X';
       }
       else{
           dfs(board,click[0],click[1]);
       }
       return board;

    }
    public void dfs(char[][]board,int x,int y){
       int cnt = 0;
       int[]arr1 = new int[]{0,1,-1,0,1,-1,1,-1};
       int[]arr2 = new int[]{1,0,0,-1,1,-1,-1,1};
        for (int i = 0; i < 8; i++) {
            int newX = x+arr1[i];
            int newY = y+arr2[i];
            if(newX<0||newY<0||newX>=board.length||newY>=board[0].length){
                continue;
            }
            else if (board[newX][newY]=='M')
                cnt++;
        }
        if(cnt>0){
            //这是用来修改附件地雷的数量
            board[x][y] = (char)(cnt+'0');
        }
        else{
            //代表这个格子附近没有任何一个地雷，改为B，然后进行递归
            board[x][y]='B';
            for (int i = 0; i < 8; i++) {
                int newX = x+arr1[i];
                int newY = y+arr2[i];
                if(newX<0||newY<0||newX>=board.length||newY>=board[0].length||board[newX][newY] != 'E'){
                    continue;
                }
                else{
                    dfs(board,newX,newY);
                }
            }

        }

    }
```

## [1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)

难度中等191

给你一个大小为 `m x n` 的二进制矩阵 `grid` ，其中 `0` 表示一个海洋单元格、`1` 表示一个陆地单元格。

一次 **移动** 是指从一个陆地单元格走到另一个相邻（**上、下、左、右**）的陆地单元格或跨过 `grid` 的边界。

返回网格中 **无法** 在任意次数的移动中离开网格边界的陆地单元格的数量。

 ![image-20221216223225810](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221216223225810.png)

--------------------

解题思路：从四个边界开始遍历，从外往里进行深度优先，如果格子为1那么将访问标记设置为True,最后判断所有未访问的且格子为1的数量，也可以去掉vis数组，直接将访问过的格子设置为0，最后判断为1的格子数量

```java
 boolean[][]vis ;
    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int numEnclaves(int[][] grid) {
   vis = new boolean[grid.length][grid[0].length];
   for (int i = 0; i < grid.length; i++){
      dfs(grid,i,0);
      dfs(grid,i,grid[0].length-1);
        }
        for (int i = 0; i < grid[0].length; i++) {
            dfs(grid,0,i);
            dfs(grid, grid.length-1,i );
        }
int sum=0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if(!vis[i][j]&&grid[i][j]==1)
                {
                    sum++;
                }
            }
        }
        return sum;

    }
     public void dfs(int[][] grid, int row, int col) {
        if(row<0||col<0||row==grid.length||col==grid[0].length||grid[row][col]==0||vis[row][col]){
            return;
        }
        vis[row][col]=true;
         //也可以写成  grid[row][col]=0;
        for(int[]dir:dirs){
            dfs(grid,row+dir[0],col+dir[1]);
        }
    }

```

## [1110. 删点成林](https://leetcode.cn/problems/delete-nodes-and-return-forest/)

难度中等199

给出二叉树的根节点 `root`，树上每个节点都有一个不同的值。

如果节点值在 `to_delete` 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。

返回森林中的每棵树。你可以按任意顺序组织答案。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/05/screen-shot-2019-07-01-at-53836-pm.png)**

```
输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]
输出：[[1,2,null,4],[6],[7]]
```

------------------



思路：根据父亲与孩子关系进行递归，参数要包括当前结点和它的父节点，根节点的父节点为null

```java
    List<TreeNode>ans=new ArrayList<>();
     Set<Integer>set=new HashSet<>();
    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
       if(root==null) return ans;
        for(int i:to_delete)
        set.add(i);
        dfs(root,null);
return ans;
    }
    public TreeNode dfs(TreeNode root,TreeNode parent){
        if(root==null) return null;
       TreeNode left=root.left;
       TreeNode right=root.right;
       if(set.contains(root.val)) root=null;
       else{
           if(parent==null) ans.add(root);
          
       }
        TreeNode newleft=dfs(left,root);
           TreeNode newright=dfs(right,root);
           //如果Root不为null,把左右两边连接起来 ，如果root为null,因为前面一步中判断了是否parent为null 此时left和Right也已经加进去了
           if(root!=null) root.left=newleft;
           if(root!=null) root.right=newright;
       return root;
        
    }
```



## 递归：括号的分数



给定一个平衡括号字符串 `S`，按下述规则计算该字符串的分数：

- `()` 得 1 分。
- `AB` 得 `A + B` 分，其中 A 和 B 是平衡括号字符串。
- `(A)` 得 `2 * A` 分，其中 A 是平衡括号字符串。

 

**示例 1：**

```
输入： "()"
输出： 1
```

**示例 2：**

```
输入： "(())"
输出： 2
```

------------------------

解答：一共就两种形式，一种是A+B一种是（A)

因此递归的时候也需要按照这两种情况进行判断，这里可以采用计数的方式，用一个分数代表当前遇到(还是)，遇到(分数+1，否则分数-1，如果分数为0退出循环，然后判断是否已经走完了字符串，如果已经走完了，说明是(A) 的形式，否则是A+B的形式

```java
 public int scoreOfParentheses(String s) {
      if(s.length()==2){
            return 1;
        }
        int score = 0,len = 0;
        for (int i = 0; i < s.length(); i++)
        {
            score +=s.charAt(i)=='('?1:-1;
            if(score==0){
                len = i+1;
                break;
            }
        }
        if(len == s.length()){
            return 2*scoreOfParentheses(s.substring(1,s.length()-1));
        }
        else{
            return scoreOfParentheses(s.substring(0,len))+scoreOfParentheses(s.substring(len,s.length()));
        }
    }
```

## [1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)

难度中等195

给你一个大小为 `m x n` 的二进制矩阵 `grid` ，其中 `0` 表示一个海洋单元格、`1` 表示一个陆地单元格。

一次 **移动** 是指从一个陆地单元格走到另一个相邻（**上、下、左、右**）的陆地单元格或跨过 `grid` 的边界。

返回网格中 **无法** 在任意次数的移动中离开网格边界的陆地单元格的数量。

 

**示例 1：**

![image-20230325204953658](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230325204953658.png)

```
输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
```

-------------------



```java
//整体思路：从四个边开始向内dfs（如果遇到了1 那么就对这个格子往四周进行dfs）,让所有遍历到的都变成0，最后判断1的个数
    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int numEnclaves(int[][] grid) {
   for (int i = 0; i < grid.length; i++){
      dfs(grid,i,0);
      dfs(grid,i,grid[0].length-1);
        }
        for (int i = 0; i < grid[0].length; i++) {
            dfs(grid,0,i);
            dfs(grid, grid.length-1,i );
        }
int sum=0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if(grid[i][j]==1)
                {
                    sum++;
                }
            }
        }
        return sum;

    }
     public void dfs(int[][] grid, int row, int col) {
        if(row<0||col<0||row==grid.length||col==grid[0].length||grid[row][col]==0){
            return;
        }
        grid[row][col]=0;
        for(int[]dir:dirs){
            dfs(grid,row+dir[0],col+dir[1]);
        }
    }
```

## 用递归减少问题规模：[779. 第K个语法符号](https://leetcode.cn/problems/k-th-symbol-in-grammar/)

难度中等282

我们构建了一个包含 `n` 行( **索引从 1 开始** )的表。首先在第一行我们写上一个 `0`。接下来的每一行，将前一行中的`0`替换为`01`，`1`替换为`10`。

- 例如，对于 `n = 3` ，第 `1` 行是 `0` ，第 `2` 行是 `01` ，第3行是 `0110` 。

给定行数 `n` 和序数 `k`，返回第 `n` 行中第 `k` 个字符。（ `k` **从索引 1 开始**）


**示例 1:**

```
输入: n = 1, k = 1
输出: 0
解释: 第一行：0
```

**示例 2:**

```
输入: n = 2, k = 1
输出: 0
解释: 
第一行: 0 
第二行: 01
```

---------------------



先找规律：

![image-20230119111330290](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230119111330290.png)

```java
   public int kthGrammar(int n, int k) {
        //n=1 一个元素 n=2 二个元素 n=3 四个元素 n=4八个元素
if(k==1) return 0;
if(k>(1<<(n-2))){
    //1<<(n-1)是总共的元素个数 1<<(n-2)是总共元素个数的一半
    //如果k在右半部分，则转化为求前半部分的翻转（注意，如果k在右半部分，则答案为k-n/2的位置处的翻转，又因为前半部分每一行都与上一行相同，所以可以n-1,翻转这里可以用异或 0异或1为1  1异或1为0，实现了翻转的效果）
    return 1^kthGrammar(n-1,k-(1<<(n-2)));
}
//如果在前半部分 直接递归
return kthGrammar(n-1,k);
    }
```

## 棋盘格有多少种走法

n*m的棋盘格子（n为横向的格子数，m为竖向的格子数）从棋盘左上角出发沿着边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。

-------

![image-20230202130753458](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230202130753458.png)

![image-20230202130817289](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230202130817289.png)

```java
  public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        int n = scanner.nextInt();
        System.out.println(run(m, n));
    }
    private static int run(int m, int n) {
        if ((m >= 1 && n == 1) || (m == 1 && n >= 1)) {
            return m+n;
        }
        return run(m - 1, n) + run(m, n - 1);
    }

```

## [301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)

难度困难813

给你一个由若干括号和字母组成的字符串 `s` ，删除最小数量的无效括号，使得输入的字符串有效。

返回所有可能的结果。答案可以按 **任意顺序** 返回。

 

**示例 1：**

```
输入：s = "()())()"
输出：["(())()","()()()"]
```

**示例 2：**

```
输入：s = "(a)())()"
输出：["(a())()","(a)()()"]
```

--------------------

![image-20230207145314077](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230207145314077.png)

![image-20230207144824063](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230207144824063.png)

```java
 private List<String> res = new ArrayList<String>();
     Set<String>set=new HashSet<>();
    public List<String> removeInvalidParentheses(String s) {
        int lremove = 0;
        int rremove = 0;
for(int i =0;i<s.length();i++)
{
    if(s.charAt(i)=='(')
    lremove++;
    else if(s.charAt(i)==')'){
if(lremove>0) lremove--;
else rremove++;
    }
}
help(s,0,lremove,rremove);
for(String temp:set)
res.add(temp);
return res;
    }
    public void help(String s,int start,int lremove,int rremove)
    {
       if(lremove==0&&rremove==0)
       {
           if(valid(s))
           set.add(s);
       } 
       for(int i = start;i<s.length();i++)
       {
           //注意这一步，如果没有这一步的话会有重复的结果，如果加上这一步，可以不用set，且这一步会使执行速度快很多
           //if(i!=start&&s.charAt(i)==s.charAt(i-1)) continue;
           if(lremove>0&&s.charAt(i)=='(')
           {
               //尝试去掉左括号，递归 注意拼接的时候第二个开头是i+1
              help(s.substring(0,i)+s.substring(i+1,s.length()),i,lremove-1,rremove);
           }
           if(rremove>0&&s.charAt(i)==')')
           {
                help(s.substring(0,i)+s.substring(i+1,s.length()),i,lremove,rremove-1);
           }
       }
    }
    public boolean valid(String s)
    {
        Stack<Character>stack=new Stack<>();

        int cnt=0;
    for(int i =0;i<s.length();i++)
{
    if(i==0&&s.charAt(i)==')') return false;
    if(s.charAt(i)=='(') stack.push(s.charAt(i));
    else if(s.charAt(i)==')'){
        if(stack.isEmpty()) return false;
        stack.pop();
    }
    }
    return stack.isEmpty();

}
判断括号的有效性可以这样写：
    
    private boolean isValid(String str) {
        int cnt = 0;
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '(') {
                cnt++;
            } else if (str.charAt(i) == ')') {
                cnt--;
                if (cnt < 0) {
                    return false;
                }
            }
        }

        return cnt == 0;
    }
```

## 430.扁平化双向链表

你会得到一个双链表，其中包含的节点有一个下一个指针、一个前一个指针和一个额外的 子指针 。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的 多层数据结构 。

给定链表的头节点 head ，将链表 扁平化 ，以便所有节点都出现在单层双链表中。让 curr 是一个带有子列表的节点。子列表中的节点应该出现在扁平化列表中的 curr 之后 和 curr.next 之前 。

返回 扁平列表的 head 。列表中的节点必须将其 所有 子指针设置为 null 。

![image-20230216141810134](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230216141810134.png) 

------

这里还要注意因为是双向链表，所以next和prev指针都要设置

```java
 public Node flatten(Node head) {
        dfs(head);
        return head;
    }
    public Node dfs(Node head)
    {
        if(head==null) return null;
        Node ans=head;
        Node last=null;
        while(ans!=null)
        {
Node next=ans.next;

if(ans.child==null)
{
    //如果没有子节点，那么last直接设置为当前结点即可
last=ans;
}else{
    Node childLast=dfs(ans.child);
    ans.next=ans.child;
    ans.child.prev=ans;

     childLast.next=next;
if(next!=null)
   {
        next.prev=childLast;
       
   }
   //last要设置为子节点的最后一个，因为next可能为空
last=childLast;
//这里记得处理完child要置空
ans.child=null;
}
ans=next;
        }
 return last;      
    }
```

## 将真分数化为埃及分数

埃及分数：分子为1的数



![image-20230313093948846](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230313093948846.png)

因为a*p+r=b 也可以写成：

![image-20230313100038644](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230313100038644.png)

u最后可以这样写：(有一个用例一直通不过，不知道为什么)

```java
  public  static void dfs(int a,int b,StringBuilder sb)
          {
              if(a==1||b%a==0) {
                  sb.append(1).append("/").append(b/a);
                  return;
              }
              else{
                  int remain=b%a;//余数
                  int div=b/a;//商
                  sb.append(1).append("/").append(div+1).append("+");
                  dfs(a-remain,b*(div+1),sb);
              }
          }
```

ye可以用这种类似贪心的方法,每次都找能减去的最大的分数的分母，然后减去这个分数，再继续处理：

```java
  String[] split = in.nextLine().split("/");
            long a = Long.parseLong(split[0]);
            long b = Long.parseLong(split[1]);
            StringBuilder res = new StringBuilder(); //存结果的

            while (true){
                //先找到一个能减去的最大埃及分数的分母 ，结果是 1/ c 比如说 8/11,就是减去1/2,那么a=8*2-11,b=b*c
                long c =  b / a + 1;
                // a/b减去 1/c 之后的分子分母如下
                a = a * c - b;
                b = b * c;

                res.append(1).append('/').append(c).append('+');

                if (a == 1 || b % a == 0){
                    res.append(1).append('/').append(b/a);
                    break;
                }
            }
            System.out.println(res.toString());
```

## 数组分组(求一个数组中是否能找出一些数和为x)

![image-20230317230723970](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230317230723970.png)

-------

求出5的倍数的和，再求出3的倍数的和，再递归计算剩余的数能否凑成sum/2-sum5

```java

        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            LinkedList<Integer> list = new LinkedList<>();
            int n = in.nextInt();
            int sum5 = 0;
            int sum3 = 0;
            int sum = 0;
            for (int i = 0; i < n; i++){
                int cur = in.nextInt();
                if (cur % 5 == 0){
                    sum5 += cur;
                }else if (cur % 3 == 0){
                    sum3 += cur;
                }else{
                    list.add(cur);
                }
                sum += cur;
            }
            //target可以是sum/2-sum5也可以是sum/2-sum3
            int target = sum/2 - sum5;
            if (sum % 2 != 0) System.out.println("false");
            else System.out.println(helper(list, target));
        }
    }
    private static boolean helper(LinkedList<Integer> list, int target){
        return helper(0, list, target);
    }
    private static boolean helper(int l, LinkedList<Integer> list, int target){
        if (l == list.size()) return target == 0;
        return helper(l + 1, list, target - list.get(l)) || helper(l + 1, list, target);
    }
其中递归也可以这样写：
    .....
      else System.out.println(backtrack(list, target,0));
        }
    }
    private static boolean backtrack(List<Integer> nums, int target, int start) {
   if(start==nums.size()) return target==0;
    if(backtrack(nums, target - nums.get(start), start + 1)) {
        return true;
    }
    return backtrack(nums, target, start + 1);
}
   
```

## 记忆化：[剑指 Offer II 112. 最长递增路径](https://leetcode.cn/problems/fpTFWP/)

#### 

难度困难37

给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。

![image-20230226215240878](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230226215240878.png)

-----------





![image-20230226214533627](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230226214533627.png) 

```java
  int [][]memo;
    int ans=0;
    public int longestIncreasingPath(int[][] matrix) {
memo=new int[matrix.length][matrix[0].length];
for(int i=0;i<matrix.length;i++)
for(int j=0;j<matrix[0].length;j++)
ans=Math.max(ans,dp(i,j,matrix));
return ans;
    }
    public int dp(int row,int col,int[][]matrix)
    {
        if(memo[row][col]!=0) return memo[row][col];
        ++memo[row][col];//注意是在这里进行加一操作的，如果它四个方向都不能延申，那么值就是1
        int[]lr=new int[]{0,0,1,-1};
        int[]wp=new int[]{1,-1,0,0};
        
        for(int i=0;i<4;i++)
        {
            int newr=row+lr[i];
            int newc=col+wp[i];
            if(newr>=0&&newc>=0&&newr<matrix.length&&newc<matrix[0].length&& matrix[newr][newc]>matrix[row][col])
            //因为这里向四个方向都延申了，所以需要得到四个方向上哪个方向是最大的
         memo[row][col]=Math.max(memo[row][col],dp(newr,newc,matrix)+1);//注意这里还要加一
            
        }
        return memo[row][col];
    }
```



# 汉诺塔问题

汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有N层的时候，打印最优移动过程和最优移动总步数。 例如，当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印： 

Move 1 from left to mid
Move 1 from mid to right
Move 2 from left to mid

Move 1 from right to mid
Move 1 from mid to left
Move 2 from mid to right
Move 1 from left to mid
Move 1 from mid to right

用以下两种方法解决。 方法一：递归的方法； 方法二：非递归的方法，用栈来模拟汉诺塔的三个塔。 

【难度】 校　★★★☆ 

【解答】 方法一：递归的方法。 首先，如果只剩最上层的塔需要移动，则有如下处理：

 1.如果希望从“左”移到“中”，打印“Move 1 from left to mid”。 

2.如果希望从“中”移到“左”，打印“Move 1 from mid to left”。

 3.如果希望从“中”移到“右”，打印“Move 1 from mid to right”。 

4.如果希望从“右”移到“中”，打印“Move 1 from right to mid”。 

5.如果希望从“左”移到“右”，打印“Move 1 from left to mid”和“Move 1 from mid to right”。 

6.如果希望从“右”移到“左”，打印“Move 1 from right to mid”和“Move 1 from mid to left”。 以上过程就是递归的终止条件，也就是只剩上层塔时的打印过程。 接下来，我们分析剩下多层塔的情况。 如果剩下N层塔，从最上到最下依次为1~N，则有如下判断： 1.如果剩下的N层塔都在“左”，希望全部移到“中”，则有三个步骤。 1）将1~N-1层塔先全部从“左”移到“右”，明显交给递归过程。 2）将第N层塔从“左”移到“中”。 3）再将1~N-1层塔全部从“右” 移到“中”，明显交给递归过程。 2.如果把剩下的N层塔从“中”移到“左”，从“中”移到“右”，从“右”移到“中”，过程与情况1同理，一样是分解为三步，在此不再详述。 3.如果剩下的N层塔都在“左”，希望全部移到“右”，则有五个步骤。 

1）将1~N-1层塔先全部从“左”移到“右”，明显交给递归过程。 

2）将第N层塔从“左”移到“中”。 

3）将1~N-1层塔全部从“右”移到“左”，明显交给递归过程。 

4）将第N层塔从“中”移到“右”。 

5）最后将1~N-1层塔全部从“左”移到“右”，明显交给递归过程。 

4.如果剩下的N层塔都在“右”，希望全部移到“左”，过程与情况3同理，一样是分解为五步，在此不再详述。 

```java
    public static int hanoPro(int num,String left,String mid,String right){
    if(num < 1) return 0;
    return process(num,left,mid,right,left,right);
    }
    public static int process(int num,String left,String mid,String right,String from,String to){
    if(num == 1) {
        if (from.equals(mid) || to.equals(mid)) {
            System.out.println("move 1 from" + from + "to " + to);
            return 1;
        }

    else{
            System.out.println("move 1 from" + from + "to mid");
            System.out.println("move 1 from mid" + "to " + to);
            return 2;
        }
    }//递归结束条件
    if (from.equals(mid) || to.equals(mid))
    {
        String another = (from.equals(left)|| to.equals(left))?right:left;
        int part1 = process(num-1,left,mid,right,from,another);
        int part2 = 1;
        System.out.println("move num" + num+"from" + from + "to" + to);
        int part3 = process( num-1,left,mid,right,another,to);
        return part1+part2+part3;
    }
    else {
        int part1 = process(num-1,left,mid,right,from,to);
        int part2 = 1;
        System.out.println("move num" + num + "from" + from + "to" + mid);
        int part3 = process(num -1 ,left,mid,right,to,from);
        int part4 = 1;
        System.out.println("move num" + num + "from" + mid + "to" + to);
        int part5 = process(num-1,left,mid,right,from,to);
        return part1+part2+part3+part4+part5;
    }
    }
public static void main(String[] args) {
    hanoPro(2,"left","mid","right");
}
```

下面是力扣上面的一道题：

## [面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

难度简单143

在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

你需要原地修改栈。

**示例1:**

```
 输入：A = [2, 1, 0], B = [], C = []
 输出：C = [2, 1, 0]
```

----------

```java
public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
    int n = A.size();
    move(n,A,B,C);

    }
void move(int n,List<Integer> A, List<Integer> B, List<Integer> C)
{
    if(n == 1)
    {
        int num = A.get(A.size()-1); //如果只剩1个，A直接移动到C
        C.add(num);
        A.remove(A.size()-1);
        return;
    }
    move(n-1,A,C,B);//A上的n-1根柱子通过C移动到B
    C.add(A.get(A.size()-1));//将A上的最后一个移动到C
    A.remove(A.size()-1);//A上的最后一个柱子被移动走了
    move(n-1,B,A,C); //B上的柱子通过A移动到C
}
```



# 链表



## 链表划分

```java
//以一个Val为划分点，让链表数组的左边全为小于val的结点，右边全为大于val的结点
public void partition(Node[]arr,int val)
{
    int small = -1;//注意初始值
    int index = 0,big = arr.length ;
    while(index != big)
    {
        if(arr[index] < val)
            swap(arr[++small],arr[index++]);
        else if(arr[index] == val) index++;
        else swap(arr[--big],arr[index++]);
    }
}

```

## 尾插和头插添加元素

```java
//添加节点到单向链表
//思路，当不考虑编号顺序时
//1. 找到当前链表的最后节点
//2. 将最后这个节点的next 指向新的节点
public void add(HeroNode heroNode) {
//因为head 节点不能动，因此我们需要一个辅助遍历temp
HeroNode temp = head;
//遍历链表，找到最后
while(true) {
//找到链表的最后
if(temp.next == null) {//
    break;
}
//如果没有找到最后, 将temp 后移
temp = temp.next;
}
//当退出while 循环时，temp 就指向了链表的最后
//将最后这个节点的next 指向新的节点
temp.next = heroNode;
}
```

头插：

```java
   //为属性赋值
            newnode.data=temp;
            //判断当前链表是否第一次赋值
            if(header==null){
                header=newnode;
            }else{
                //将新节点连接到链表的头部
                newnode.next=header;
                //header永远存储第一个节点的地址
                header=newnode;
            }

```

## 删除元素

```java
//删除节点
//1. head 不能动，因此我们需要一个temp 辅助节点找到待删除节点的前一个节点
//2. 说明我们在比较时，是temp.next.no 和需要删除的节点的no 比较
public void del(int no) {
HeroNode temp = head;
boolean flag = false; // 标志是否找到待删除节点的
while(true) {
if(temp.next == null) { //已经到链表的最后
break;
}
if(temp.next.no == no) {
//找到的待删除节点的前一个节点temp
flag = true;
break;
}
temp = temp.next; //temp 后移，遍历
}
//判断flag
if(flag) { //找到
    //可以删除
temp.next = temp.next.next;
}else {
System.out.printf("要删除的%d 节点不存在\n", no);
}
}
```

## 将单链表的每k个结点逆序

如果最后不够k个结点，则不调整

如1-2-3-4-5-6-7-8-null，k=3

调整后为 3-2-1-6-5-4-7-8-null

关键是要注意将逆序后的结点与后面的结点连接上

```java
public void reverseNode(Node head,int k)
{
    if(k < 2) return ;
    Node cur = head;
    Node start = null;
    Node end = null;
    Node next = null;
    Node pre = null;
    int count = 1;
    while(cur != null)
    {
       next = cur.next;
 
        if(count == k)
        {
     start = pre== null?head:pre.next;
        head = pre == null?cur:head;
            resign2(pre,start,cur,next);
            pre = start;
            count = 0;
        }
        
        cur =next;
        count++;
    }
}

public void resign2(Node left,Node start,Node end,Node right){
    Node pre = start;
    Node cur = start.next;
    Node next = null;
    while(cur != null)
    {
        next = cur.next;
        cur.next = pre;
        pre= cur;
        cur = next;
    }
    if(left != null) left.next = end;
    start.next = right;
 
}
```



## 删除倒数第k个节点

利用哑节点来避免对头结点分情况讨论，且只需要找到被删除节点的上一个节点即可，不用单独再找到需要被删除的节点

```java
 public ListNode removeNthFromEnd(ListNode head, int n) {
if(head == null)return head;
   ListNode dummy = new ListNode(0, head);
ListNode pre=dummy,next,cur=head;
int co=0;
while(co < n)
{
cur=cur.next;
co++;
}
while(cur!=null)
{
pre= pre.next;
cur=cur.next;
}
pre.next = pre.next.next;
ListNode ans = dummy.next;
return ans;
  }
```

## 单链表选择排序

初始节点的值如果不正确会得到错误结果！！！

```java
   public ListNode sortList(ListNode head) {
ListNode pre=  head;
ListNode tail = null;
ListNode curr = head;

ListNode small = head;
ListNode smallpre = null;
if(head == null||head.next == null) return head;

while (curr != null)
{
small = curr;
    smallpre = smallNodePre(curr);
    //small = smallNodePre(curr).next;
  
    if(smallpre != null)
    {
        small = smallpre.next;
        smallpre.next = small.next;
    }
     curr = curr==small?curr.next:curr;
     if(tail == null)
        head = small;
    else tail.next = small;
    tail = small;
}
return head;
    }

     public ListNode smallNodePre(ListNode cur)
    {
         ListNode pre = cur;//注意初始值
        ListNode small = cur;
        ListNode smallpre = null;
        ListNode current = cur.next;
        while (current != null)
        {
            if(current.val<small.val)
            {
                smallpre = pre;
                small = current;
            }
            pre = current;
            current = current.next;
        }
        return  smallpre;
    }
```

## 单链表归并排序

```java
 public ListNode sortList(ListNode head) {
       if(head == null||head.next == null) return head;
         ListNode fast = head.next,slow = head;
while(fast!=null&&fast.next!=null)
{
    fast = fast.next.next;
    slow = slow.next;
}
//到这里slow是中间节点，一定要记得中间断开
ListNode cur = slow.next;
slow.next = null;//这里断开
     ListNode left = sortList(head);//现在递归对左半边和右半边分别排序，注意是先递归然后再合并，这样最先合并的是最少的两个节点
        ListNode right = sortList(cur);
ListNode dummpy = new ListNode(0);
ListNode temp = dummpy;//哑节点
while(left!= null && right != null)
{
    if(left.val < right.val)
    {
        dummpy.next = left;
        dummpy = left;
        left = left.next;
    }
    else
    {
          dummpy.next = right;
          dummpy = right;
           right = right.next;
    }
  
}
if(left!=null) dummpy.next = left;
if(right != null) dummpy.next = right;
return temp.next;
    

    }
```



## 如何从尾到头输出单链表 

从头到尾输出单链表比较简单，于是很自然地想把链表中链接结点的指针反转过来，改变链表的方向，然后就可以从尾到头输出了，但该方法需要额外的操作，是否还有更好的方法呢？答案是肯定的。 接下来的想法是从头到尾遍历链表，每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始输出结点的值，此时输出的结点的顺序已经反转过来了。该方法虽然没有只需要遍历一遍链表，但是需要维护一个额外的栈空间，实现起来会比较麻烦。 是否还能有更高效的方法？于是我们想到了第三种方法，既然想到了栈来实现这个函数，而递归本质上就是一个栈结构，于是很自然地又想到了用递归来实现。要实现反过来输出链表，每访问到一个结点的时候，先递归输出它后面的结点，再输出该结点自身，这样链表的输出结果就反过来了。 具体实现如下：

```java
void printListRevrsely(Node head)
{
    if(head != null)
    {
        printListRevrsely(head.next);
        system.out.println(head.val);
}
}
```



## 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。

请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

```java
 public ListNode oddEvenList(ListNode head) {
int i = 1;
if(head == null||head.next==null) return  head;
ListNode even = head.next;
ListNode cur = head;
        ListNode temp = even;
while (even != null&&even.next!=null)
{
cur.next = even.next;
cur = cur.next;
even.next=cur.next;
even=even.next;


}
cur.next=temp;

return head;

```



## 不用额外开辟空间的链表合并



```java
       public Node merge(Node head1, Node head2) {
              if (head1 == null || head2 == null) {
                     return head1 != null ? head1 : head2;
              }
              Node head = head1.value < head2.value ? head1 : head2;
              Node cur1 = head == head1 ? head1 : head2;
              Node cur2 = head == head1 ? head2 : head1;
              Node pre = null;
              Node next = null;
              while (cur1 != null && cur2 != null) {
                     if (cur1.value <= cur2.value) {
                            pre = cur1;
                            cur1 = cur1.next;
                     } else {
                            next = cur2.next;
                            pre.next = cur2;
                            cur2.next = cur1;
                            pre = cur2;
                            cur2 = next;
                     }
              }
              pre.next = cur1 == null ? cur2 : cur1;
       }
```

## 2.递归合并两个升序链表：

递归法：

```cpp
   ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
if(l1 == nullptr)
return l2;
else if(l2 == nullptr)
return l1;
else if(l1->val < l2->val){
l1->next = mergeTwoLists(l1->next,l2);
return l1;}
else 
{
    l2->next = mergeTwoLists(l1,l2->next);
    return l2;
}
    }
```
迭代法:
设置一个哨兵节点，用来返回最后合并的链表

```cpp
if(list1==null) return list2;
if(list2==null) return list1;
ListNode head = new ListNode(-1);
ListNode p =head;
while(list1!=null && list2 != null)
{
    if(list1.val < list2.val)
    {
        p.next = list1;
        list1 =list1.next;
    }
    else
    {
        p.next = list2;
        list2 = list2.next;
    }
    p = p.next;
}
p.next = list2==null?list1:list2;
return head.next;
```
注意使用三目运算符减小代码量：p->next=l1==nullptr?l2:l1;



## 合并k个已排序的链表

思路是采用一个优先级队列，先把链表的第一个元素都放到优先级队列中，然后再串起来

```java
 PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>((o1,o2)->o1.val-o2.val);
    public ListNode mergeKLists(ListNode[] lists) {
        for(int i=0;i<lists.length;i++)
        if(lists[i]!=null)
        queue.offer(lists[i]);
           ListNode head = new ListNode(0);
        ListNode tail = head;
        while(!queue.isEmpty())
        {
            ListNode st=queue.poll();
            tail.next=st;
            tail=tail.next;
            if(st.next!=null)
            queue.offer(st.next);
        }
        return head.next;
    }
```



## 单链表反转（利用头结点）

```java
public static void reversetList(HeroNode head) {
//如果当前链表为空，或者只有一个节点，无需反转，直接返回
if(head.next == null || head.next.next == null) {
return ;
}
//定义一个辅助的指针(变量)，帮助我们遍历原来的链表
HeroNode cur = head.next;
HeroNode next = null;// 指向当前节点[cur]的下一个节点
HeroNode reverseHead = new HeroNode(0, "", "");
//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端
//动脑筋
while(cur != null) {
    next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用
    cur.next = reverseHead.next;//将cur 的下一个节点指向新的链表的最前端
reverseHead.next = cur; //将cur 连接到新的链表上
cur = next;//让cur 后移
}
//将head.next 指向reverseHead.next , 实现单链表的反转
head.next = reverseHead.next;
}
```





## 设计LRU(最近最少使用)缓存结构



该结构在构造时确定大小，假设大小为 k ，并有如下两个功能

\1. set(key, value)：将记录(key, value)插入该结构

\2. get(key)：返回key对应的value值

提示:

1.某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的，然后都会刷新缓存。

2.当缓存的大小超过k时，移除最不经常使用的记录。

3.输入一个二维数组与k，二维数组每一维有2个或者3个数字，第1个数字为opt，第2，3个数字为key，value

若opt=1，接下来两个整数key, value，表示set(key, value)
若opt=2，接下来一个整数key，表示get(key)，若key未出现过或已被移除，则返回-1
对于每个opt=2，输出一个答案

4.为了方便区分缓存里key与value，下面说明的缓存里key用""号包裹

要求：set和get操作复杂度均为 O(1)*O*(1)

示例1

输入：

```
[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3
```

复制

返回值：

```
[1,-1]
```

复制

说明：

```
[1,1,1]，第一个1表示opt=1，要set(1,1)，即将(1,1)插入缓存，缓存是{"1"=1}
[1,2,2]，第一个1表示opt=1，要set(2,2)，即将(2,2)插入缓存，缓存是{"1"=1,"2"=2}
[1,3,2]，第一个1表示opt=1，要set(3,2)，即将(3,2)插入缓存，缓存是{"1"=1,"2"=2,"3"=2}
[2,1]，第一个2表示opt=2，要get(1)，返回是[1]，因为get(1)操作，缓存更新，缓存是{"2"=2,"3"=2,"1"=1}
[1,4,4]，第一个1表示opt=1，要set(4,4)，即将(4,4)插入缓存，但是缓存已经达到最大容量3，移除最不经常使用的{"2"=2}，插入{"4"=4}，缓存是{"3"=2,"1"=1,"4"=4}
[2,2]，第一个2表示opt=2，要get(2)，查找不到，返回是[1,-1] 
```

```java

public class Solution {
    private Map<Integer, Node> map = new HashMap<>();
    private Node head = new Node(-1,-1);
    private Node tail = new Node(-1,-1);
    private int k;
    public int[] LRU (int[][] operators, int k) {//f
        this.k = k;
        head.next = tail;
        tail.prev = head;
        int len = (int)Arrays.stream(operators).filter(x -> x[0] == 2).count();
        int[] res = new int[len];
        for(int i = 0, j = 0; i < operators.length; i++) {
            if(operators[i][0] == 1) {
                set(operators[i][1], operators[i][2]);
            } else {
                res[j++] = get(operators[i][1]);
            }
        }
        return res;
    }
 
    private void set(int key, int val) {
        if(get(key) > -1) {
            map.get(k).val = val;
        } else {
            if(map.size() == k) {
                int rk = tail.prev.key;
                tail.prev.prev.next = tail;
                tail.prev = tail.prev.prev;
                map.remove(rk);
            }
            Node node = new Node(key, val);
            map.put(key, node);
            moveToHead(node);
        }
    }
 
    private int get(int key) {
        if(map.containsKey(key)) {
            Node node = map.get(key);
            node.prev.next = node.next;
            node.next.prev = node.prev;
            moveToHead(node);
            return node.val;
        }
        return -1;
    }
 
    private void moveToHead(Node node) {
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
        node.prev = head;
    }
 
    static class Node{
        int key, val;
        Node prev, next;
        public Node(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }
}
```

版本二：带哨兵结点的双向链表+map

```java
class LRUCache {
class Node{
            //这个代码中tail head都是哨兵结点 无数据
        int key;
        int val;
        Node prev;
        Node next;
        Node(){

        }
        Node(int key,int value)
        {
            this.key = key;
            this.val = value;
        }
    }
    int capacity;
    Node head;
    Node tail;

    public LRUCache(int capacity) {
this.capacity = capacity;
head = new Node();
tail = new Node();
head.next = tail;
tail.prev = head;
    }
    private Map<Integer, Node> mymap = new HashMap<>();
    public int get(int key) {
if(mymap.containsKey(key) )
{
    Node node = mymap.get(key);
    node.prev.next = node.next;
    node.next.prev = node.prev;
    moveToHead(node);
    return node.val;
}
return -1;
    }

    public void moveToHead(Node node) {
      node.next=   head.next ;
        head.next.prev = node;
        head.next = node;
        node.prev = head;
    }

    public void put(int key, int value) {
 if(get(key) > -1) {
            mymap.get(key).val = value;
     //也可以直接写：
     if(get(key) > -1)
{
 map.get(key).value = value;
return;
}
        } else {//尤其注意这个put方法的else!!!!因为没有写Else结果检查了半小时也没通过！！！！！注意：put方法并不会让已有的结点更新到前面去!
            if(mymap.size() == capacity) {
                int rk = tail.prev.key;
                tail.prev.prev.next = tail;
                tail.prev = tail.prev.prev;
                mymap.remove(rk);
            }
            Node node = new Node(key, value);
            mymap.put(key, node);
            moveToHead(node);
}
    }
}

```

## LFU

请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。

实现 LFUCache 类：

LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。
void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。
为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。



----

```java
  // 缓存容量，时间戳
    int capacity, time;
    Map<Integer,Node>map =new HashMap<>();
        TreeSet<Node> S;
    public LFUCache(int capacity) {
       this.capacity = capacity;
        this.time = 0;
        S = new TreeSet<>();
    }
    
    public int get(int key) {
if(capacity == 0) return -1;
if(!map.containsKey(key)) return -1;
Node node = map.get(key);
S.remove(node);
node.cnt +=1;
node.time = ++time;
S.add(node);
return node.value; 
    }
    
    public void put(int key, int value) {
         if (capacity == 0) {
            return;
        }
          if (!map.containsKey(key)) {
            // 如果到达缓存容量上限
            if (map.size() == capacity) {
                // 从哈希表和平衡二叉树中删除最近最少使用的缓存 这里treeset从小到大，第一个是最小的,这里记得是从treeset中取得最小的使用频率的结点，删除的时候需要map和Set同时把结点删除，不可遗漏
                map.remove(S.first().key);
                S.remove(S.first());
            }
             // 创建新的缓存
            Node cache = new Node(1, ++time, key, value);
            // 将新缓存放入哈希表和平衡二叉树中
          map.put(key, cache);
            S.add(cache);
            }
            else//如果这个键已经存在
            {
Node oldnode = map.get(key);//取出存在的结点，更新时间戳和使用频率
S.remove(oldnode);
oldnode.cnt+=1;
oldnode.time = ++time;//time越小时间越早 所以首先被删除
oldnode.value = value;
map.put(key,oldnode);//更新它的值
S.add(oldnode);

            }

    }
    class Node implements  Comparable<Node>
    {
        int cnt,time,key,value;
            Node(int cnt, int time, int key, int value) {
        this.cnt = cnt;
        this.time = time;
        this.key = key;
        this.value = value;
    }

       public int compareTo(Node node)
       {
return this.cnt == node.cnt?this.time - node.time:this.cnt - node.cnt;
       } 
       public boolean equals(Object anObject )
       {
  if (this == anObject) {
            return true;
        }
        if (anObject instanceof Node) {
            Node rhs = (Node) anObject;
            return this.cnt == rhs.cnt && this.time == rhs.time;
        }
        return false;
       }
       public int hashCode() {
        return cnt * 1000000007 + time;
    }
    }
```



## [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

难度中等816

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

-----

方法一：

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
    Map<Node,Node>mymap=new HashMap<>();
    Node cur=head;
    while(cur!= null)
    {
        mymap.put(cur,new Node(cur.val));
        cur=cur.next;

    }    
    cur = head;
    while(cur!=null)
    {
        mymap.get(cur).next=mymap.get(cur.next);
        mymap.get(cur).random = mymap.get(cur.random);
    cur=cur.next;
    }
    return mymap.get(head);
    }
```

方法二：回溯+哈希表

```java
    HashMap<Node,Node> map = new HashMap<>();
    public Node copyRandomList(Node head) {
 
if(head==null) return head;
if(map.get(head)==null)
{
      Node newnode = new Node(head.val);
map.put(head,newnode);
newnode.next = copyRandomList(head.next);
newnode.random = copyRandomList(head.random);
}
return map.get(head);
    }
```

## 链表内指定区间反转

![image-20230208110050066](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230208110050066.png)



输入：

```
{1,2,3,4,5},2,4
```

复制

返回值：

```
{1,4,3,2,5}
```

```java
public ListNode reverseBetween (ListNode head, int m, int n) {
        // write code here
        if(m==n) return head;
        ListNode temp=head,pre=null,prem=null,nodem=null,nNext=null;
        int index=1;

        while(temp!=null){

if(index==m-1)
{
//m位置的前一个结点
    prem=temp;
    

}
if(index==n)
{
    //n位置的下一个结点
    nNext=temp.next;
}
index++;

temp=temp.next;
        }
        if(prem==null) temp=head;
        else temp=prem.next;
        ListNode tempNext=temp.next;
    //temp是m位置的结点 它的next指向n位置的下一个
temp.next=nNext;
while(tempNext!=nNext)
{
    //theNext是用于反转之后向前移动的
    ListNode theNext=tempNext.next;
    tempNext.next=temp;
    temp=tempNext;
    tempNext=theNext;
}
    //注意这里，如果m位置不是第一个结点，那么返回head
if(prem!=null) {
    prem.next= temp;
    return head;
}
        //reverse(prem,nodem,noden,m-n);
        return temp;
    }
```

## [剑指 Offer II 022. 链表中环的入口节点](https://leetcode.cn/problems/c32eOV/)

难度中等93

给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 `next` 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意，`pos` 仅仅是用于标识环的情况，并不会作为参数传递到函数中。**

**说明：**不允许修改给定的链表。



 

**示例 1：**

![image-20230214225100801](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230214225100801.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```



-----

![image-20230214225546503](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230214225546503.png) 

![image-20230214225735388](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230214225735388.png)  

```java
 public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (fast == slow) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;


       
    }
```



# 重点 KMP算法

有一个字符串s,下标从0开始，以i号位结尾的子串就是s[0..i],定义一个int next数组，其中next[i]存放使前缀s[0..k]与后缀s[i-k..i]相等的最大k值，（前缀与后缀可以部分重叠，但不能是i本身，若找不到 相等的前后缀，令next[i] = -1;显然next[i]就是所求最长相等前后缀中的前缀最后一位的下标，

![](C:\Users\14172\OneDrive\图片\屏幕快照\2020-12-12.png)

## 统计后者是否是子串

代码：

```c++
int nextt[maxn];
void getnext(char s[], int len)
{
	int j = -1;
	nextt[0] = -1;
	for (int i = 1; i < len; i++)
	{
		//求解next[1~len-1]
		while (j != -1 && s[i] != s[j + 1])
			j = nextt[j];// j一直回退 直到j为-1或s[i]==s[j+1]
		if (s[i] == s[j + 1])
		{
			j++;

		}
		
			nextt[i] = j;
			//如果不满足s[i]==s[j+1]则直接next[i]=j 如果满足则next[i]=j+1;
	}
	
}

bool kmp(char text[], char pattern[])
{
	//判断后者是否是前者的子串
	int m = strlen(text);
	int n = strlen(pattern);
	int j = -1;
	getnext(pattern, n);
	for (int i = 0; i < m; i++)
	{
		while (j != -1 && text[i] != pattern[j + 1])
			j = nextt[j];
		if (text[i] == pattern[j + 1])
			j++;
		if (j == n - 1)
		return true;//完全匹配

	}
	return false;//执行完循环还没匹配成功说明pattern不是子串
}
int main()
{
	char* m = new char[200];
	char* pat = new char[200];
	cin >> m;
	cin >> pat;
	cout<<kmp(m, pat);
	delete m;
	delete pat;
}
```

## //计算子串在字符串中出现次数

```c++
int countkmp(char text[], char  pattern[])
{
	int i, j = -1,m = strlen(pattern),n = strlen(text);//求字符串长度
	getnext(pattern, m);
	int ans = 0;//一开始的次数是0
	nextt[0] = -1;
	for (i = 0; i < n; i++)
	{
		while (j != -1 && text[i] != pattern[j + 1])
			j = nextt[j];//回退
		if (text[i] == pattern[j + 1])
			j++;
		if (j == m - 1)
		{
			//此时已经判断出pa是text的一个子串
			ans++;
			j = nextt[j];//j进行回退 继续匹配 next[j]代表最长相等的前后缀，这样可以让j最大，即已经匹配的部分最长
			//这样省去下一次匹配的许多无意义的比较
		}
	}
	return ans;//返回比较次数
}
```



# 递归与分治

暴力递归：

![image-20211204210420465](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211204210420465.png)

二分查找(递归法)

递归求解 如果a[m] > x，那么元素只可能在a[l] ∼ a[m − 1]中；如果a[m] < x，那么元素只可能在a[m + 1] ∼ a[r]中。 合并 不需要合并。 这个算法称为二分查找(binary search) 。

```c++
int bsearch ( int l , int r , int x )
{
if ( l > r ) return -1;
int m = ( l + r ) > > 1;
if ( a [ m ] == x ) return m ;
else if ( a [ m ] > x ) return bsearch (l , m -1 , x );
else return bsearch ( m +1 , r , x );
}
递归程序一定要注意边界的处理
```



```c++
//元素个数更多时，转化成元素个数少的情况。由数学归纳法容易证明整个算法的
//正确性。这个算法往往被写成非递归的形式，即：
int bsearch ( int l , int r , int x )
{
int m ;
while ( l <= r )
{
m = ( l + r ) > > 1;
if ( a [ m ] == x ) return m ;
else if ( a [ m ] > x ) r = m– 1;
else l = m + 1;
}
}

```

把这种简单的递归转化成迭代的形式，通常是一个好主意。
下面进行时间复杂度分析。由于m = n/2，递归方程化成了T(n) = T(n/2) + 1。用
和刚才类似的方法有：
T(1) = 1
T(2) = T(1) + 1 = 2
T(4) = T(2) + 1 = 3
T(8) = T(4) + 1 = 4
归纳得：T(2n) = n + 1，即T(n) = log2n + 1。渐进分析给出：T(n) = O(log n)。

 ( n & 1) 等效于n%2==1

## 天平（Not so Mobile, UVa 839）

　 输入一个树状天平，根据力矩相等原则判断是否平衡。所谓力矩相等，就是W l D l =W r D r ，其中W l 和W r 分别为左右两边砝码的重量，D为距离。
　
思路：
**采用递归（先序）方式输入**：每个天平的格式为W l ，D l ，W r ，D r ，当W l 或W r 为0时，表示该“砝码”实际是一个子天平，接下来会描述这个子天平。当W l =W r=0时，会先描述左子天平，然后是右子天平。 样例：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210514203654577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU4NTc0,size_16,color_FFFFFF,t_70)
输入：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210514203207373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU4NTc0,size_16,color_FFFFFF,t_70)
输出“平衡”
代码：

```cpp
#include <iostream>

using namespace std;
bool solve(int& w) {
    int w1, d1, w2, d2;
    bool b1 = true, b2 = true;
    cin >> w1 >> d1 >> w2 >> d2;//b1 b2用于判断左子天平和右子天平是否平衡
    if (!w1) b1=solve(w1);
    if (!w2) b2 = solve(w2);
    w = w1 + w2;//w用于修改子天平的总重量
    return b1 && b2 && (w1 * d1 == w2 * d2);

}



int main()
{
    int T, W;
    cin >> T;//天平数量
    while (T--) {
        if (solve(W)) cout << "平衡";
        else cout << "不平衡";
    }
}

```

## 小球下落
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210514203742800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU4NTc0,size_16,color_FFFFFF,t_70)

有一棵二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右编号为1, 2, 3,…, 2* D-1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，初始全部关闭，当每次有小球落到一个开关上时，状态都会改变。当小球到达一个内结点时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所示。
样例输入：
4 2 
3 4 
10 1
 2 2
  8 128 


样例输出： 
12
 7 
 512
 3

分析：
对于每一个结点k 其左子节点 右子节点的编号分别是2k和2k+1

每次落到一个位置开关状态均变化，尤其注意第一个结点每次都会变化
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210514233440780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU4NTc0,size_16,color_FFFFFF,t_70)
4 2：
一共4层 有两个小球时，第二个小球最后下落的位置
输出12
代码：
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include<cstring>



using namespace std;


const int maxd = 20;//最大深度
int m[1 << maxd];//最大结点个数为2的maxd次方-1


int main()
{
	int d, n;//d 深度 n结点总个数
	while (scanf("%d%d", &d, &n) == 2) {
		memset(m, 0,sizeof(m));
		int k;
		for (int i =0;i<n;i++) {
			 k = 1;//每次从结点1开始掉落，k=1要写在外面，每次落一个小球第一个开关状态都会改变
	
			for (;;) {
				m[k] = !m[k];//注意这个写法，是m[k]，修改第k个开关的状态 k为此时下落的位置
				k = m[k] ? 2 * k : 2 * k + 1;
				if (k > ((1<<d)-1)) break;
			}
		}
		printf("%d\n", k / 2);
	}

}
```



## 整数拆分

![image-20211210024042434](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211210024042434.png)

 



![image-20211210024242717](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211210024242717.png)

public int integerBreak(int n) {

int[]dp = new int[n+1];

​    for (int i = 2; i <= n; i++) {

​      int curmax = 0;

​      for (int j = 1; j < i; j++) {

​        curmax = Math.max( curmax,Math.max(j *(i-j),dp[i-j]*j));

​      }

​      dp[i] = curmax;

​    }

​    return dp[n];

  }



## 整数划分2

问题：将给定正整数n表示成一系列正整数之和

n=n1+n2+…+nk，其中n1≥n2≥…≥nk≥1，k≥1。

求正整数n的不同划分个数p(n)。 

```java

public final class IntegerPartition
{
	public static int partition(int n, int m){

		if(n<1||m<1) return 0;
		
		if(m==1||n==1) return 1;
		
		if(m>n) return partition(n,n);
		
		if(m==n) return partition(n,m-1)+1;
		
		return partition(n,m-1)+partition(n-m,m);
	}

	public static void main(String[] args){
		int n=2;
		int m=2;
		System.out.println(partition(n,m));
	}
}
```







## [395. 至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

难度中等636

给你一个字符串 `s` 和一个整数 `k` ，请你找出 `s` 中的最长子串， 要求该子串中的每一字符出现次数都不少于 `k` 。返回这一子串的长度。

**示例 1：**

```
输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```

----

重点：我们在调用递归函数的时候，把递归函数当做普通函数（黑箱）来调用，即明白该函数的输入输出是什么，而不用管此函数内部在做什么。
下面是详细讲解。

递归最基本的是记住递归函数的含义（务必牢记函数定义）：本题的 longestSubstring(s, k) 函数表示的就是题意，即求一个最长的子字符串的长度，该子字符串中每个字符出现的次数都最少为 k。函数入参 s 是表示源字符串；k 是限制条件，即子字符串中每个字符最少出现的次数；函数返回结果是满足题意的最长子字符串长度。

递归的终止条件（能直接写出的最简单 case）：如果字符串 s 的长度少于 k，那么一定不存在满足题意的子字符串，返回 0；

调用递归（重点）：如果一个字符 c 在 s 中出现的次数少于 k 次，那么 s 中所有的包含 c 的子字符串都不能满足题意。所以，应该在 s 的所有不包含 c 的子字符串中继续寻找结果：把 s 按照 c 分割（分割后每个子串都不包含 c），得到很多子字符串 t；下一步要求 t 作为源字符串的时候，它的最长的满足题意的子字符串长度（到现在为止，我们把大问题分割为了小问题(s → t)）。此时我们发现，恰好已经定义了函数 longestSubstring(s, k) 就是来解决这个问题的！所以直接把 longestSubstring(s, k) 函数拿来用，于是形成了递归。

==未进入递归时的返回结果==：**如果 s 中的每个字符出现的次数都大于 k 次，那么 s就是我们要求的字符串，直接返回该字符串的长度**。

总之，通过上面的分析，我们看出了：我们不是为了递归而递归。而是因为我们把大问题拆解成了小问题，恰好有函数可以解决小问题，所以直接用这个函数。由于这个函数正好是本身，所以我们把此现象叫做递归。小问题是原因，递归是结果。而递归函数到底怎么一层层展开与终止的，不要用大脑去想，这是计算机干的事。我们只用把递归函数当做一个能解决问题的黑箱就够了，把更多的注意力放在拆解子问题、递归终止条件、递归函数的正确性上来。



```java
    public int longestSubstring(String s, int k) {
Map<Character,Integer>mymap=new HashMap<>();
for(char a:s.toCharArray())
mymap.put(a,mymap.getOrDefault(a,0)+1);
 int cnt=0;
for (char c : mymap.keySet()) {
if(mymap.get(c)<k)
{
   cnt=0;
    String[]newstr = s.split(String.valueOf(c));
    for(String str:newstr)
    {
        cnt=Math.max(cnt,longestSubstring(str,k));
    }
    return cnt;
}
}

return s.length();
    }
```

## 递归法：[95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

难度中等

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。

 ![image-20220210002804874](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220210002804874.png)

----

![image-20220210002932402](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220210002932402.png)

code

```java
 public List<TreeNode> generateTrees(int n) {
if(n== 0) return new LinkedList<TreeNode>();
return generate(1,n);
    }
    public List<TreeNode> generate(int begin,int end)
    {
          List<TreeNode>ans = new LinkedList<>();
        if(begin>end)
        {
            ans.add(null);
            return ans;

        }
        for(int i=begin;i<=end;i++)
        {
            List<TreeNode>leftnode = generate(begin,i-1);
           List<TreeNode>rightnode = generate(i+1,end);
for(int num=0;num<leftnode.size();num++)
for(int j=0;j<rightnode.size();j++)
{
    TreeNode node = new TreeNode(i);
    node.left = leftnode.get(num);
    node.right = rightnode.get(j);
    ans.add(node);
}
        }
        return ans;
    }
```

# 牛顿迭代：求立方根

![image-20230313231436954](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230313231436954.png) 

![image-20230313225517796](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230313225517796.png)

![image-20230313231305341](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230313231305341.png)  

![image-20230313225626549](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230313225626549.png) 

```java
  Scanner input = new Scanner(System.in);
        while(input.hasNextDouble())
        {
            double num=input.nextDouble();
            double x=1.0;
            //f(x)=x立方-y
            while(Math.abs(Math.pow(x,3)-num)>1e-3)//注意这里是取绝对值
            {
                x=x-((Math.pow(x,3)-num)/(3*Math.pow(x,2)));
                
            }
            //tips： 四舍五入保留1位小数位的做法可以利用String的静态方法format(“%.1f”, x)，其中%表示小数点前的位数，1表示保留小数点后1位，f表示转换位float型
            System.out.println(String.format("%.1f",x));
        }



```



# 并查集

## [990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

难度中等279

给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 `equations[i]` 的长度为 `4`，并采用两种不同的形式之一：`"a==b"` 或 `"a!=b"`。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。

只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 `true`，否则返回 `false`。 

 



**示例 1：**

```
输入：["a==b","b!=a"]
输出：false
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
```

**示例 2：**

```
输入：["b==a","a==b"]
输出：true
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。
```

-----------------------------

并查集的重要思想在于，**用集合中的一个元素代表集合**。我曾看过一个有趣的比喻，把集合比喻成**帮派**，而代表元素则是**帮主**。接下来我们利用这个比喻，看看并查集是如何运作的。

![image-20230120155726328](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230120155726328.png)

最开始，所有大侠各自为战。他们各自的帮主自然就是自己。*（对于只有一个元素的集合，代表元素自然是唯一的那个元素）*

现在1号和3号比武，假设1号赢了（这里具体谁赢暂时不重要），那么3号就认1号作帮主*（合并1号和3号所在的集合，1号为代表元素）*。

现在2号想和3号比武*（合并3号和2号所在的集合）*，但3号表示，别跟我打，让我帮主来收拾你*（合并代表元素）*。不妨设这次又是1号赢了，那么2号也认1号做帮主。

相信你已经觉察到，这是一个**树**状的结构，要寻找集合的代表元素，只需要一层一层往上访问**父节点**（图中箭头所指的圆），直达树的**根节点**（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树

查询

```c
int find(int x)
{
    if(fa[x] == x)
        return x;
    else
        return find(fa[x]);
}
```

我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。而根节点的父节点是它自己，所以找到父节点是它自己的结点即可

**合并**

```c
inline void merge(int i, int j)
{
    fa[find(i)] = find(j);
}
```

合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者，这里暂时不重要。

代码 :

```java
public boolean equationsPossible(String[] equations) {
//首先遍历所有的等式，构造并查集。同一个等式中的两个变量属于同一个连通分量，因此将两个变量进行合并。

//然后遍历所有的不等式。同一个不等式中的两个变量不能属于同一个连通分量，因此对两个变量分别查找其所在的连通分量，如果两个变量在同一个连通分量中，则产生矛盾，返回 false。

  int[] parent = new int[26];
        for (int i = 0; i < 26; i++) {
            parent[i] = i;
        }
        for (String str : equations) {
            if (str.charAt(1) == '=') {
                int index1 = str.charAt(0) - 'a';
                int index2 = str.charAt(3) - 'a';
                union(parent, index1, index2);
            }
        }
        for (String str : equations) {
            if (str.charAt(1) == '!') {
                int index1 = str.charAt(0) - 'a';
                int index2 = str.charAt(3) - 'a';
                if (find(parent, index1) == find(parent, index2)) {
                    return false;
                }
            }
        }
        return true;
    }

    public void union(int[] parent, int index1, int index2) {
        parent[find(parent, index1)] = find(parent, index2);
    }

    public int find(int[] parent, int index) {
       if(parent[index]==index) return index;
       return find(parent,parent[index]);
    }


```

## [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)

难度中等532

树可以看成是一个连通且 **无环** 的 **无向** 图。

给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的边。

 

**示例 1：**

![img](https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png)

```
输入: edges = [[1,2], [1,3], [2,3]]
输出: [2,3]
```



-------



思路：首先一开始所有的结点都是一个连通量，然后开始遍历所有的边，如果两个连通量之间是不连通的，那么它们可以加上这条边，也不会成环，如果已经连通了，则返回这条边，且这样返回的一定是最后出现的(题目说了只要去掉一条边)

如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。

如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。



```java
public int[] findRedundantConnection(int[][] edges) {
int n=edges.length+1;
int[]parent=new int[n+1];
for(int i=1;i<n;i++)
parent[i]=i;

for(int i=0;i<n;i++){
    int[]e=edges[i];
    if(find(parent,e[0])!=find(parent,e[1])){
        union(parent,e[0],e[1]);
    }else{
        return e;
    }
}
return null;
    }
public int find(int[]parent,int index)
    {
        if(parent[index]==index) return index;
        return find(parent,parent[index]);
    }
    public void union(int[]parent,int index1,int index2)
    {
        parent[find(parent,index1)]=find(parent,index2);
    }
```

## [1584. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

难度中等260

给你一个`points` 数组，表示 2D 平面上的一些点，其中 `points[i] = [xi, yi]` 。

连接点 `[xi, yi]` 和点 `[xj, yj]` 的费用为它们之间的 **曼哈顿距离** ：`|xi - xj| + |yi - yj|` ，其中 `|val|` 表示 `val` 的绝对值。

请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。

 

**示例 1：**

![image-20230131131308858](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230131131308858.png)

--------



能够满足任意两点之间有且仅有一条简单路径只有树，且这棵树包含 
n 个节点。我们称这棵树为给定的图的生成树，其中总权值最小的生成树，我们称其为最小生成树。

最小生成树有一个非常经典的解法：Kruskal
![image-20230131131458510](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230131131458510.png)

在实际代码中，我们首先将这张完全图中的边全部提取到边集数组中，然后对所有边进行排序，从小到大进行枚举，每次贪心选边加入答案。使用并查集维护连通性，若当前边两端不连通即可选择这条边。



```java
public int minCostConnectPoints(int[][] points) {
 int n = points.length;
        DisjointSetUnion dsu = new DisjointSetUnion(n);
        List<Edge> edges = new ArrayList<Edge>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                edges.add(new Edge(dist(points, i, j), i, j));
            }
        }
        Collections.sort(edges, new Comparator<Edge>() {
            public int compare(Edge edge1, Edge edge2) {
                return edge1.len - edge2.len;
            }
        });
         int ret = 0, num = 1;
        for (Edge edge : edges) {
            //x =1 y=2时就是表示第一个点和第二个点之间的边，边已经排好序了
            int len = edge.len, x = edge.x, y = edge.y;
            if (dsu.unionSet(x, y)) {
                ret += len;
                num++;
                if (num == n) {
                    break;
                }
            }
        }
        return ret;
    }
    //这里 xy 是表示索引，即第几个
    public int dist(int[][] points, int x, int y) {
        return Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);
    }
    class Edge{
          int len, x, y;

    public Edge(int len, int x, int y) {
        this.len = len;
        this.x = x;
        this.y = y;
    }
    }
    
class DisjointSetUnion {
    int[] f;

    int n;

    public DisjointSetUnion(int n) {
        this.n = n;
        this.f = new int[n];
        for (int i = 0; i < n; i++) {
            this.f[i] = i;
        }
    }

    public int find(int x) {
        return f[x] == x ? x : (f[x] = find(f[x]));
    }

    public boolean unionSet(int x, int y) {
        //这里先判断两者是不是在一个连通分量中，如果在的话返回false 否则将二者进行连通
        int fx = find(x), fy = find(y);
        if (fx == fy) {
            return false;
        }
//这里下面这两种写法都是对的
    //    f[fy] = fx;
      f[fx]=fy;
        return true;
    }
}
```

## [面试题 17.07. 婴儿名字](https://leetcode.cn/problems/baby-names-lcci/)

难度中等60

每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。

在结果列表中，选择 **字典序最小** 的名字作为真实名字。

 

**示例：**

```
输入：names = ["John(15)","Jon(12)","Chris(13)","Kris(4)","Christopher(19)"], synonyms = ["(Jon,John)","(John,Johnny)","(Chris,Kris)","(Chris,Christopher)"]
输出：["John(27)","Chris(36)"]
```



------

这里是有关字符串的并查集，而且发现出现在synonyms中的字符串可能并没有在names中出现过，可以用一个map来表示类似father,只有父节点不会出现在这个unionmap中

```java
 public String[] trulyMostPopular(String[] names, String[] synonyms) {
   Map<String, Integer> map = new HashMap<>();
        Map<String, String> unionMap = new HashMap<>();     //并查集， key(子孙)->value(祖宗)
        for (String name : names) {     //统计频率
            int idx1 = name.indexOf('(');
            int idx2 = name.indexOf(')');
            int frequency = Integer.valueOf(name.substring(idx1 + 1, idx2));
            map.put(name.substring(0, idx1), frequency);
        }

for(String pair:synonyms){
      int idx = pair.indexOf(',');
            String name1 = pair.substring(1, idx);
            String name2 = pair.substring(idx + 1, pair.length() - 1);

while(unionMap.containsKey(name1)){
    name1=unionMap.get(name1);
}
while(unionMap.containsKey(name2)){
    name2=unionMap.get(name2);
}
if(!name1.equals(name2)){
     int frequency = map.getOrDefault(name1, 0) + map.getOrDefault(name2, 0);    //出现次数是两者之和
                String trulyName = name1.compareTo(name2) < 0 ? name1 : name2;//这是字典序更小的名字
                String nickName = name1.compareTo(name2) < 0 ? name2 : name1;
                unionMap.put(nickName, trulyName);      //字典序最小的不会作为键，因此可以在while循环中找到最上层父节点
                map.remove(nickName);       //更新一下数据
                map.put(trulyName, frequency);//map中放的是字典序小的，把字典序大的那个字符串给删了


}
}
 String[] res = new String[map.size()];
        int index = 0;
        for (String name : map.keySet()) {
            StringBuilder sb = new StringBuilder(name);
            sb.append('(');
            sb.append(map.get(name));
            sb.append(')');
            res[index++] = sb.toString();
        }
        return res;



    }
```

## 最少需要建设的道路数量

某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？



**输入描述:**

```
测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( < 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 
       注意:两个城市之间可以有多条道路相通,也就是说
       3 3 1 2 1 2 2 1 
       这种输入也是合法的
       当N为0时，输入结束，该用例不被处理。
```

-------

这里用并查集将所有连通的城市串起来，最后判断有多少个点是不在这个连通的城市里面

```java
int p[1222];
int i;
int find(int x)
{
    if(x!=p[x])
        p[x]=find(p[x]);
    return p[x];
}
int hebing(int x,int y)
{
    return p[x]=y;
}
int main()
{
    int n,m,x,y,x1,y1;
    while(~scanf("%d%d",&n,&m)&&n)
    {
        for(i=1;i<=1222;i++)
            p[i]=i;
        for(i=1;i<=m;i++)
        {
            scanf("%d%d",&x,&y);
            x1=find(x);
            y1=find(y);
            if(x1!=y1)
                hebing(x1,y1);
        }
        int ans=0;
        for(i=1;i<=n;i++)
        {
            if(p[i]==i)
                ans++;
        }
        printf("%d\n",ans-1);
    }
    return 0;
}
```



## 信号覆盖



二维平面上有n*个基站，第i*个基站的坐标为(x**i*,*y**i*)。

所有的基站都有一个共同的信号强度w*(*w*≥0)，两个基站可以直接通信当且仅当他们之间的距离不超过*w*。

基站之间的通信也可以采用间接通信：当基站A,*B*之间可以通信，基站B*,*C*之间也可以通信的时候，我们认为基站*A*,*C*之间也可以通信。

现在我想知道，信号强度w*至少是多大，才能使得至少有k*个基站可以互相通信。

为了避免精度问题，你只需要输出最小的合法信号强度w*的平方即可。

### ![image-20230420214943589](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230420214943589.png) 

--------

采用并查集的思想，求出所有基站之间的距离，再从小到大遍历，如果不是连通的就进行合并

```java
public class Main {
    static class Vector{
        int u,v;
        int dis;
  public  Vector(int u,int v,int dis){
      this.u=u;
      this.v=v;
      this.dis=dis;
  }
    }
       static int maxn=2020;
    static int[]x=new int[maxn],y=new int[maxn];
 
    static int n,k;
    static int[]f=new int[maxn],sz=new int[maxn];
    public static int find(int x){
        return x==f[x]?f[x]:find(f[x]);
    }
    public static int dis(int i,int j){
        int xx=x[i]-x[j];
        int yy=y[i]-y[j];
        return xx*xx+yy*yy;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n=scanner.nextInt();
        k=scanner.nextInt();
        for(int i=1;i<=n;i++){
            f[i]=i;
            sz[i]=1;
        }
        for(int i=1;i<=n;i++){
            x[i]=scanner.nextInt();
            y[i]=scanner.nextInt();
        }
        List<Vector>list=new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i+1; j <=n; j++) {
                Vector v=new Vector(i,j,dis(i,j));
list.add(v);
            }
        }
        Collections.sort(list,(o1,o2)->o1.dis-o2.dis);
    if(k==1){
        System.out.println("0");
        return;
    }
    for(Vector v:list){
        int p=find(v.v),q=find(v.u);
        if(p!=q){
            f[p]=q;
            sz[q]+=sz[p];
            if(sz[q]>=k){
                //注意这里，因为距离是公用的，只要输出最大的距离就可以了
                System.out.println(v.dis);
                return;
            }
        }
    }
    }
}
```





# 路径问题算法

vector<int>pre[max]:pre数组的数据类型是vector，这样对于每个结点v来说pre[v]就是一个变长数组，也可设置为set<int> pre[max];这样使用pre[v].count(i)会比较方便



## 最短路径
图G采用邻接表存储，设计算法求不带权无向连通图G从顶点u到顶点v的一条最短路径
由于是不带权的图，采用广度优先，对于每一个结点，都需要将和它联通的所有结点访问，比较是否等于v
```cpp
//图G采用邻接表存储，设计算法求不带权无向连通图G从顶点u到顶点v的一条最短路径
//由于是不带权的无向连通图，一条边的长度为1，所以u和v的最短路径即距离u到v的边数最少的顶点序列
//利用队列结构输出最短路径（逆路径序列）
//设计非循环队列
#define maxn 100
typedef struct anode {
    int adjvex;//该边的邻接点编号
    struct anode* nexarc;//指向下一条边的指针
    int weight;//该边的相关信息，比如权值
}arcnode;//边结点类型
typedef struct vnode {
    //InfoTyoe info; 顶点的其他信息
    arcnode* firstarc;//指向第一个边结点
}Vnode;//邻接表头结点类型
typedef struct {
    vnode adjlist[10000];//邻接表头结点数组
    int n, e;//图中顶点数n和边数e
}adjgraph;
typedef struct {
	int data;
	int parent;//前一个顶点的位置
}Queue;
//用front和rear两个整型变量分别作为队列的头尾指针
void ShortPath(adjgraph* G, int u, int v) {
    int w, h;
    arcnode* p;
    Queue qu[maxn];
    int front = -1,rear=-1;
    int visited[maxn];

    rear++;//rear++表示有一个结点进队
    qu[rear].data = u;
    qu[rear].parent = -1;
 
    for (int i = 0; i < G->n; i++) {
        visited[i] = 0;
    }
      visited[u] = 1;//u结点入队 标记为已经访问过
    while(front!=rear){//队不空时循环
        front++;//出此时队的顶点
        w = qu[front].data;

   
      
        if (w == v) {
            h = front;//通过队列输出路径之逆
            cout << "path:";
            while (qu[h].parent != -1)
            {
     
                cout << "->" << qu[h].data;
                h = qu[h].parent;
           
            }
            break;
        }
        p = G->adjlist[w].firstarc;
   while(p!=NULL) {
            if (visited[p->adjvex] == 0)
            {
                visited[p->adjvex] = 1;
                rear++;//将未访问过的点加入邻接点
                qu[rear].data = p->adjvex;
                qu[rear].parent = front;
            }
            p = p->nexarc;

        }
    }
}
```
注意：
通过
       w = qu[front].data;
         p = G->adjlist[w].firstarc;
         来进行：出队一个结点（此结点为队列中最早入队的结点） 访问与这个结点相邻的所有结点
## 最远顶点

图G采用邻接表存储，设计算法求不带权无向连通图G从顶点u出发最远的一个顶点
思路：即求距离顶点u的边数最多的顶点，从u出发一层一层拓展，最后到达的一个顶点即为距离u最远的顶点
不需要求出具体路径，因此采用普通队列（STL中的queue)

```cpp
#define maxn 100
int Maxdist(adjgraph* G, int v) {
    arcnode* p;
    int visited[maxn];
    for (int i = 0; i < G->n; i++) {
        visited[i] = 0;
    }//也可以用memset(visited,0,sizeof(visited))
    queue<int>qu;
    qu.push(v);
    int m;
 
    while (!qu.empty()) {
        m = qu.front();
        qu.pop();
        p = G->adjlist[m].firstarc;//找第一个邻接点
        while (p != nullptr) {
            if (visited[p->adjvex] != 0) {
                qu.push(p->adjvex);
                //j = p->adjvex 邻接点为顶点j
                visited[p->adjvex] = 1;
            }
            p = p->nexarc;
        }
   //步骤为:先找第一个邻接点，再将所有未访问过的邻接点入队，且判断是否已经访问过，如果未访问过则进队改邻接点，然后找下一个邻接点
        
    }
    return m;
}
```


## 习题1.两个城市之间现在求一种乘坐方式，使得转机的次数最少
输入
5 7 1 5
1 2
1 3
2 3
2 4
3 4
3 5
4 5
输出2
![在这里插入图片描述](https://img-blog.csdnimg.cn/bc49af016f9844a890bc5021ab796c59.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU4NTc0,size_16,color_FFFFFF,t_70)

```cpp
//最少转机次数
#include <stdio.h> 
struct note 
{
int x;//城市编号 
int s;//转机次数
};

int main()
{
struct note que[2501]; 
int e[51][51]={0},visited[51]={0}; 
int head,tail; 
int i,j,n,m,a,b,cur,start,end,flag=0;
cin>>n>>m>>start>>end;//城市个数 航线数 起点 终点
for(i = 1;i <= n;i++)
{
for(j = 1;j <= n;j++)
if(i == j) e[i][j] = e[j][i] = 0;
else
e[i][j] = e[j][i] = 1e6;//初始化距离

}
for(i = 1;i <=m;i++)
{
	cin>>a>>b;
e[a][b] = e[b][a] = 1;
}
head = 1;
tail = 1;//队列初始化
que[tail].x = start;
que[tail].s = 0;
visited[start] = 1;
tail++;
while(tail > head)
{
	cur = que[head].x;//当前队列中首元素的编号
	for(i = 1;i <= n;i++)
	{
		if(visited[i] == 0 && e[cur][i] < 1e6)
		{
			que[tail].x = i;
			que[tail].s  = que[head].s +1;
			tail++;
			visited[i] = 1;//标记进入了队列
		}
		if(que[tail].x == end)
		{
			flag = 1;
			break;
		}

	}
	if(flag)
	 break;
	head++;//注意head++要写在后面，只有一个点拓展结束后才能进行出队，一开始自己写的是cur = que[head++].x;
}
cout<<que[tail-1].s;
}


```







# bf算法

![](C:\Users\14172\Pictures\最短路径树.png)



![](C:\Users\14172\Pictures\===.png)

## 无向图的邻接表创建

```c++
#include<iostream>
using  namespace std;

#define MAXVEX  100  /* 最大顶点数,应由用户定义 */
typedef  char VertexType;  /* 顶点类型应由用户定义 */
typedef  int EdgeType;  /* 边上的权值类型应由用户定义 */

typedef  struct EdgeNode /* 边表结点  */
{
     int adjvex; /* 邻接点域,存储该顶点对应的下标 */
    EdgeType weight; /* 用于存储权值,对于非网图可以不需要 */
     struct EdgeNode *next;  /* 链域,指向下一个邻接点 */
} EdgeNode;

typedef  struct VextexNode /* 顶点表结点 */
{
    VertexType data; /* 顶点域,存储顶点信息 */
    EdgeNode *firstedge; /* 边表头指针 */
} VextexNode, AdjList[MAXVEX];

typedef  struct
{
    AdjList adjList;
     int numNodes, numEdges;  /* 图中当前顶点数和边数 */
} GraphAdjList;


void CreateALGraph(GraphAdjList *Gp)
{
     int i, j, k;
    EdgeNode *pe;
    cout <<  "输入顶点数和边数(空格分隔）:" << endl;
    cin >> Gp->numNodes >> Gp->numEdges;

     for (i =  0 ; i < Gp->numNodes; i++)
    {
        cout <<  "输入顶点信息：" << endl;
        cin >> Gp->adjList[i].data;
        Gp->adjList[i].firstedge =  NULL; /* 将边表置为空表 */
    }

     for (k =  0; k <  Gp->numEdges; k++) /* 建立边表 */
    {
        cout <<  "输入边(vi,vj)的顶点序号i,j（空格分隔）:" << endl;
        cin >> i >> j;
        pe = (EdgeNode *)malloc( sizeof(EdgeNode));
        pe->adjvex = j; /* 邻接序号为j */
         /* 将pe的指针指向当前顶点上指向的结点 */
        pe->next = Gp->adjList[i].firstedge;
        Gp->adjList[i].firstedge = pe; /* 将当前顶点的指针指向pe */

        pe = (EdgeNode *)malloc( sizeof(EdgeNode));
        pe->adjvex = i;
        pe->next = Gp->adjList[j].firstedge;
        Gp->adjList[j].firstedge = pe;

    }
}

int main( void)
{
    GraphAdjList GL;
    CreateALGraph(&GL);

     return  0;
}
```



## spfa算法（bf算法优化

使用spfa可以判断是否存在从源点可以到达的负环，它期望的时间复杂度是o(ke),k是一个常数，E是图的边数，这个算法在大部分数据时异常高效，经常优于堆优化的dj算法。

进入循环之前执行：将起始点入队，vis[s]状态设置为true(在队列中)，num[s]++（起始点的访问次数加一),d[s]=0;//起始点到自身距离为0

- 循环条件:队列非空
- 依次执行：{取出队首顶点设置编号为u，队列pop使其出队,vis[u]状态设置为false即不在队列中}

spfa的bfs版本:(用队列实现)

也可用栈实现（DFS版本）

```c++
//bf算法同样设置一个数组d[],存放从源点到各个顶点的最短距离
//如果图中有负环，而且从源点可以到达，那么会影响最短路径的求解

const int maxn = 1000,inf=100000000;

int mincost=inf,num[maxn];//num[s]记录顶点的入队次数
int d[maxn];
bool inq[maxn];//判断顶点是否在队中
vector<node>adj[maxn];//图G的邻接表
int n;
bool spfa(int s)//s为起始点
{
	
	memset(inq, false, maxn);
	memset(num, 0, maxn);//初始化数组
	fill(d, d + maxn, inf);
	//源点入队部分
	queue<int>qu;
	qu.push(s);
	inq[s] = true;//入队后改变状态为true
	num[s]++;//入队次数加一
	d[s] = 0;
	while (!qu.empty())
	{
		int u = qu.front();//取出队首顶点设置编号为u
		qu.pop();//出队
		inq[u] = false;//设置u为不在队列中
		//遍历u的所有邻接边
		for (int i = 0; i < adj[u].size(); i++)
		{
			int v = adj[u][v].v;
			int dis = adj[u][v].dis;
			if (d[u] + dis < d[v])
			{
				
				d[v] = d[u]+dis;
				if (inq[v] == false)
				{
					qu.push(v);//v入队 v的入队次数加一 状态为在队列中
					num[v]++;
					inq[v] = true;
					if (num[v] >= n) return false;//有可到达的负环
				}
			}
		}
	}
	return true;//无可到达的负环

}
```





# 弗洛伊德算法



```c++
const int maxn = 200,inf=100000000;//最大顶点数为两百 由于顶点数少 可以用邻接矩阵法
int mincost=inf,num[maxn];//num[s]记录顶点的入队次数
int dis[maxn][maxn];//dis[i][j]表示从i到j的最短距离
int n,m;//n为顶点数，m为边数

void flod()
{
	for (int k = 0; k < n; k++)
	{
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
			{
				if (dis[i][k] != inf && dis[k][j] != inf &&dis[i][k] + dis[k][j] < dis[i][j])
				{
					dis[i][j] = dis[i][k] + dis[k][j];//找到了更短的路径 进行更新
				}
			}
	}
}
int main()
{
	int u, v, w;

	fill(dis[0], dis[0] + maxn * maxn, inf);
	for (int i = 0; i < n; i++)
	{
		dis[i][i] = 0;//顶点i到i的距离为0
	}
	cin >> n >> m;//输入顶点数和边数
	for (int i = 0; i < m; i++)
	{
		cin >> u >> v >> w;
		dis[u][v] = w;//有向图
	}
	flod();//算法入口
	for(int i = 0;i < n;i++)
		for (int j = 0; j < n; j++)
		{
			cout << dis[i][j] << " ";
		}
}
```

注意：不能将外层的k循环放到内层

# 普利姆算法

对图G(V,E)设置集合S，存放已经被访问的顶点然后每次从集合V-S中选择与集合S最短距离最小的一个顶点（记为u）访问并加入集合S，然后令顶点u为中介点优化所有从u能到达的顶点v与集合s之间的最短距离，执行n次这样的操作，直到集合S包含所有顶点。

- 这里生成的就是以v0为根结点的最小生成树。
- 记录vi与每个已攻占城市的最小距离。
- 与狄杰特斯拉算法的d[]区别：普利姆中d[]是顶点到集合s的最短距离，后者是起点s到顶点vi的最短距离。二者只有优化d[v]的部分不同。

邻接矩阵版本：

```c++
const int inf = 1000000;
const int maxn = 10000;

int n,G[maxn][maxn];//n为顶点数目
int d[maxn];
bool vis[maxn] = { false };
int prim()//默认0号为初始起始点，函数返回最小生成树的边权之和
{
	fill(d, d + maxn, inf);
	d[0] = 0;//只有0号顶点到集合S的距离为0，其余点距离均为INF
	int i, j, k,ans=0;//ans存放最小生成树的边权之和
	fill(G[0], G[0] + maxn * maxn, inf);
	for (i = 0; i < n; i++)//循环n次
	{
		int u = -1,min=inf;
		for (j = 0; j < n; j++)
		{
			if (vis[j]==false && d[j] < min)
			{
				u = j;
				min = d[j];//未访问的顶点中到集合S的距离最小的
			}
		}
		if (u == -1) return -1;//剩下的点和起始点不连通
		vis[u] = true;
		ans += d[u];//将与集合S距离最小的边加入最小生成树
		for (int v = 0; v < n; v++)
		{//v未访问 u v连通 从u到v的距离比从v到集合s距离更短
			if (vis[v] == false && G[u][v] != inf && G[u][v] < d[v])
			{
				d[v] = G[u][v];
				
			}
		}

	}
	return ans;
	
}

int main()
{
	int u, v, w;
	fill(G[0], G[0] + maxn * maxn, inf);
	cin >> n >> m;//顶点个数 边数
	for (int i = 0; i < m; i++)
	{
		cin >> u >> v >> w;//输入u v 边权
		G[u][v] = G[v][u] = w;//无向图
	}
	int ans = prim();
	cout << ans;
}
```





# 克鲁斯卡尔算法

!(C:\Users\14172\OneDrive\图片\屏幕快照\2020-12-02.png)![](C:\Users\14172\OneDrive\图片\屏幕快照\2020-12-02 (3).png)

```c++
int n,m,G[maxn][maxn];//n为顶点数目
struct edge
{
	int u, v;
	int cost;//边的两个端点和边权
}e[maxn];//最多有maxn条边 定义结构体表示一条边
bool cmp(edge a, edge b)
{
	return a.cost < b.cost;
}
int findfather(int x)
{
	int z = x;//因为x会发生变化先用Z保存
	while (x != father[x])
	{
		x = father[x];
	}
	//到这里，x存放的是根结点 下面把路径上所有节点的father结点改为x
	while (z != father[z])
	{
		int a = z;//因为Z要被父节点覆盖 先提前保存
		z = father[z];//回溯父亲结点
		father[a] = x;//将原先的结点z的父节点指向根结点
	}
	return x;//返回根结点
}
//该算法适合顶点数多，边数较少的情况，与prim正好相反，如果为稀疏图，则适合克鲁斯卡尔算法
//如果图本身连通，则每个顶点都会有边连接，且一开始都是一个单独的连通块，因此枚举过程中一定可以把每个顶点都访问到
//且只要是第一次访问某个顶点，对应的边一定会加入最小生成树中，故图中的顶点最后一定都会加入最小生成树中
int kluskar(int n, int m)//n为顶点数，m为图的边数
{
	//返回最小生成树的边权之和
	int ans = 0, num_t = 0;//ans为所求边权之和 num_t为当前生成树的边数
	for (int i = 0; i < n; i++)
		father[i] = i;//并查集初始化，假设顶点编号为1~n
	sort(e, e + m, cmp);//排序
	for (int i = 0; i < m; i++)//从小到大枚举所有边
	{
		int fav = findfather(e[i].v);
		int fau = findfather(e[i].u);//查询该边的两个端点是否在一个集合
		if (fav != fau)
		{
			father[fau] = fav;//如果不在一个集合，则合并，把测试边加入最小生成树中
			ans += e[i].cost;
			num_t++;
			if (num_t >= n -1)
				break;//如果边数等于顶点数减一时退出循环
		}
	}
	if (num_t != n - 1) return -1;//如果无法连通时返回-1
	return ans;//否则返回最小生成树的边权
}

int main()

{
	int u, v, k;
	cin >> n >> m;
	for (int i = 0; i < m; i++)
	{
		cin >> e[i].u >> e[i].v >> e[i].cost;
	}
	cout << kluskar(n, m);
}
```



# 暴力算法

## 枚举

给你一个数字n，用0~9,10个数字组成两个五位数，使得他们的商为n，按顺序输出所有结果。

```c++
int use[10] = { 0 };
bool solution(int a, int b)
{
	for (int i = 0; i < 10; i++)
		use[i] = 0;//很重要
	if (b > 98765 || a< 10000) return false;
	while (a)
	{
		use[a % 10] = 1;
		a /= 10;
	}
	while (b)
	{
		use[b % 10] = 1;
		b /= 10;
	}
	int sum = 0;
	for (int i = 0; i < 10; i++)
	{
		sum += use[i];
	}
	if (sum != 10) return false;
	else
		return true;

}
int main()
{
	int n;
	while (cin >> n && n > 0)
	{
		for (int a = 10000; a < 100000; a++)
		{
			if (solution(a, a * n))
				cout << a * n << "/" << a << "=" << n<<endl;
			else
			{
				continue;
			}
		}
	}
}
```



给定一个k，构造一个等式 `1/k = 1/x + 1/y` ，其中`x>=y`。

既然要求找出所有的x、y,枚举对象自然就是x、y了。可问题在于,枚举的范围如何?从1/12=1/156+1/13可以看出,x可以比y大很多。由于x≥y,有`1/x <= 1/y`，因此`1/k - 1/y <= 1/y`，所以`y >= 2k`，只需要在`k~2k`之间枚举y，由y计算x即可。

```c++
int main()
{
	int k;
	while (cin >> k && k < 10000)
	{
		for (int j = k+1; j <= 2 * k; j++)
		{
			if ((j*k) % (j - k) == 0 && j!=k)//如果==0则说明存在这样的整数x
				cout << "1/" << k << "=1/" << j << "+1/" << (j*k) / (j-k) << endl;
		}
	}
}
```



## 柠檬水找零

![image-20210905203221026](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210905203221026.png)

```java
public static boolean change(int[] bills)
{
    int five = 0,ten = 0;
    for(int bill:bills)
    {
        if(bill == 5)
            five++;
        else if(bill == 10)
        {
            if(five == 0) return false;
            else
            {
                five--;
                ten++;
            }
        }
        else
        {
            if(five > 0 && ten > 0)
            {
                five --;
                ten--;
            }
            else if(five > 3)
                five = five - 3;
            else return false;
        }
      
    }
    return true;
}
```



## 三角形最大周长



```java
Arrays.sort(a);
for(int i = a.length -1;i>=2;i--)
{
    if(a[i] < a[i-1]+a[i-2]) return a[i]+ a[i-1]+a[i-2];
    
}
return 0;//不能组成三角形
```





# 棋盘格问题（还未懂）UVa1343

![img](https://images2015.cnblogs.com/blog/832036/201511/832036-20151111124216212-1394497486.png)



题意：　　
有个＃字型的棋盘，2行2列，一共24个格。

如图：每个格子是1或2或3，一共8个1，8个2，8个3.
有A~H一共8种合法操作，比如A代表把A这一列向上移动一个，最上面的格会补到最下面。
求：使中心8个格子数字一致的最少步骤，要输出具体的操作步骤及最终中心区域的数字。如果有多个解，输出字典序最小的操作步骤。


分析：
很明显的一个状态空间搜索问题，不过可以注意到，虽然每一个状态有八个可能的后续状态，随着操作数n的增加，总状态数 8^n 还是大得可怕。比如当n＝11时，总状态为8^11 = 85亿。就算通过自己创建特制的哈希表进行状态判重，优化效果并不明显，因为最近一直在做状态空间搜索问题，即使用bfs＋剪枝＋哈希表，这些程序都无一例外的超时了，所以现在看到状态空间搜索问题，如果没有特别好的剪枝，我绝对不敢用bfs了.....
回到这道题，所有可以用bfs,回溯解决的问题，尤其是解答树的结点数没有明显上限的题，选择用迭代加深搜索算法都特别好用（原因可以参考我上一篇文章）。这里IDA*(迭代加深A*算法)其实说白了就是迭代加深+剪枝.

A*算法是对于每一步考虑 g(n) + h()和MAXD的关系。
稍微解释一下，g(n)是从起点到当前状态的总步数，MAXD是我们提前通过计算证明得到的最短路线总步数的上限，h()是启发函数，是整个算法的关键，我们设计的h()可以预估从当前状态到目标状态至少需要的步数。
这样，上面的关系式就很好理解了。g(n) + h() > MAXD 意味着当前已经走的步数＋至少还需要的步数 > 我可以走的步数上限，这种状态，必然已经没有继续的必要，回溯。
对于这道题，可以注意到，对于每一次操作，我们最多可以让中心格子多一个目标数字，如果当前中心格子待整理的数字个数大于我们还可以走的步数，回溯。
这样，就得到了
　　　　if (d + num_unordered() > MAXD) return false;
　　　　这一核心剪枝公式。 剩下的就简单了。
代码只有52行，还是很简洁的。而且运行速度很快。过30组数据只用了126ms.

```c++

 

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 24, LEN = 8;
int board[LEN][LEN - 1] = { {0, 2, 6, 11, 15, 20, 22}, {1, 3, 8, 12, 17, 21, 23},
                        {10, 9, 8, 7, 6, 5, 4}, {19, 18, 17, 16, 15, 14, 13},
                        {23, 21, 17, 12, 8, 3, 1}, {22, 20, 15, 11, 6, 2, 0},
                        {13, 14, 15, 16, 17, 18, 19}, {4, 5, 6, 7, 8, 9, 10} };
int check_order[] = {6, 7, 8, 11, 12, 15, 16, 17}, a[MAXN], maxd;
char order[30];

int unordered() {
    int n1 = 0, n2 = 0, n3 = 0;
    for (int i = 0; i < LEN; i++)
        if (a[check_order[i]] == 1)  n1++;
        else if (a[check_order[i]] == 2) n2++;
        else n3++;
    return LEN - max(max(n1, n2), n3);
}

void rotate(int di) {
    int t = a[board[di][0]];
    for (int i = 1; i < LEN - 1; i++) a[board[di][i - 1]] = a[board[di][i]];
    a[board[di][LEN - 2]] = t;
}

bool dfs(int d) {
    int cnt = unordered();
    if (!cnt) return true;
    if (cnt + d > maxd) return false;
    int temp[MAXN]; memcpy(temp, a, sizeof(a));
    for (int i = 0; i < LEN; i++) {
        rotate(i);
        order[d] = i + 'A';
        if (dfs(d + 1)) return true;
        memcpy(a, temp, sizeof(a));
    }
    return false;
}

int main() {
    freopen("in", "r", stdin);
    while (scanf("%d", &a[0]) && a[0]) {
        for (int i = 1; i < MAXN; i++) scanf("%d", &a[i]);
        if (!unordered()) { printf("No moves needed\n%d\n", a[6]); continue;}
        for (maxd = 1;; maxd++) if (dfs(0)) break;
        for (int i = 0; i < maxd; i++) printf("%c", order[i]);
        printf("\n%d\n", a[6]);
    }
    return 0;
}
```

# 拓扑排序

```c++
vector<int>G[maxn];//邻接表
bool topu()//一个重要应用：判断一个图是否是有向无环图
{
	int num = 0;//记录加入拓扑序列的顶点数
	queue<int>q;
	for (int i = 0; i < n; i++)
		if (degree[i] == 0)
			q.push(i);//n为顶点数 将所有入度为0的顶点入队

	while (!q.empty())
	{
		int u = q.front();//取队首结点
		q.pop();
		for (int i = 0; i < G[u].size(); i++)
		{
			int v = G[u][i];
			degree[v]--;//顶点v的入度减一
			if (degree[v] == 0)
				q.push(v);//v为u的后继结点
		}

		num++;//加入拓扑序列的顶点数加一
	}
	if (num == n)return true;
	else//返回true则为有向无环图
		return FALSE;

}

```

# 







# 排序算法

## 希尔排序 插入 归并 快速

一个h有序数组即由h个有序子数组组成的数组。

-  快速排序：一种基于分治的排序算法，将一个数组分成；两个子数组，两个子数组单独排序，快速排序将数组排序的方式是当两个子数组都有序时整个数组也就自然有序了。
- 我们就是通过递归地调用切分来排序的，



## 归并排序:

```java
 //原地归并的抽象方法
	    public static void merge(Comparable a[],int lo,int hi,int mid)
	    {
	    	int i = lo,j = mid+1;
	    	
	    	for(int k = lo;k <= hi;k++)
	    		aux[k] = a[k];//先将所有元素复制到aux中 再归并回a中
	    	for(int k = lo;k <= hi;k++)
	    	{
	    		if(i > mid)a[k] = aux[j++];
	    		else if(j >hi) a[k] = aux[i++];
	    		else if(less(aux[j],aux[i])) a[k] = aux[j++];
	    		else a[k] = aux[i++];
	    	}//进行了四个条件判断 即:左半边用尽，右半边用尽，右半边的当前元素小于左半边的当前元素
	    	//则取右半边的当前元素 左半边..小于右半边，则取左当前元素
	    }
	    private static Comparable[]aux;//辅助数组
	    public static void sort(Comparable []a)
	    {
	    	aux = new Comparable[a.length];
	    	sort(a,0,a.length-1);
	    	
	    }
	    private static void sort(Comparable[]a,int lo,int hi)
	    {
	    	if(hi <= lo) return;
	    	int mid = lo+(hi - lo)/2;
	    	sort(a,lo,mid);
	    	sort(a,mid+1,hi);
	    	merge(a,lo,hi,mid);
	    }

```

## 归并应用：[493. 翻转对](https://leetcode-cn.com/problems/reverse-pairs/)

难度困难331

给定一个数组 `nums` ，如果 `i < j` 且 `nums[i] > 2*nums[j]` 我们就将 `(i, j)` 称作一个***重要翻转对\***。

你需要返回给定数组中的重要翻转对的数量。

**示例 1:**

```
输入: [1,3,2,3,1]
输出: 2
```

----



```java
public int reversePairs(int[] nums) {
     if(nums.length==0||nums.length==1) return 0;
     return mergesort(nums,0,nums.length-1);

    }
    public int mergesort(int[]nums,int begin,int end)
    {
        if(begin==end) return 0;
        int ret=0;
        int mid = (end+begin)/2;
        int n1 = mergesort(nums,begin,mid);
        int n2 = mergesort(nums,mid+1,end);
        int i = begin,j = mid+1;
        ret +=n1+n2;
        while(i <=mid)
        {
while( j<=end &&(long)nums[i]>2 * (long) nums[j])//排序之前先计算翻转对
j++;
ret +=j-mid-1;
i++;
        }
        int[]sort = new int[end-begin+1];
             int p1 = begin, p2 = mid + 1;
             int index=0;
        while(p1<=mid || p2<=end )
        {
            if(p1>mid)
            {
                sort[index++] = nums[p2];
                p2++;
            }
            else if(p2 > end)
            {
sort[index++] = nums[p1];
                p1++;
            }
          else { if(nums[p1]<nums[p2])
            {
                sort[index++] = nums[p1];
                p1++;
            }
            else
           {
                sort[index++] = nums[p2];
                p2++;
           }
          }
        }
              for (int k = 0; k < sort.length; k++) {
                nums[begin + k] = sort[k];
            }
        return ret;
    }
```

## [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

难度困难620

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

 

**示例 1:**

```
输入: [7,5,6,4]
输出: 5
```

----



```java
 public int reversePairs(int[] nums) {
if(nums.length < 2) return 0;
int[]temp = new int[nums.length];
int[]copy = new int[nums.length];
System.arraycopy(nums,0,copy,0,nums.length);

return merge(copy,temp,0,nums.length-1);
    }
      private int merge(int[] nums, int[] temp,int left, int right ) {//这种方法只需要递归一个函数
        if (left == right) {
            return 0;
        }
int ans = 0;
        int mid = left + (right - left) / 2;
        int leftPairs = merge(nums,temp, left, mid );
        int rightPairs = merge(nums,  temp,mid + 1, right);

        if (nums[mid] <= nums[mid + 1]) {//如果左边最大的小于等于右边最小的说明左边到右边已经排好了
            return leftPairs + rightPairs;
        }
        ans+=leftPairs+rightPairs;
           int i = left;
            int j = mid + 1;
            while (i <= mid) {
                while (j <= right && (long) nums[i] >  (long) nums[j]) {//否则的话说明没排好，比如出现1，5，6 和2，4，6的情况，需要进行归并，在这个过程中会产生n
                    j++;
                }
            ans+= j - mid - 1;
                i++;
            }
int[]sort = new int[right-left+1];
          //在这里排序没有递归，而是创建了一共新数组，把原数组中的元素按顺序放到sorted,其中left~mid和mid+1~right是排好序的部分,之后注意将新数组中的元素放回原数组
       int[] sorted = new int[right - left + 1];
            int p1 = left, p2 = mid + 1;
            int p = 0;
            while (p1 <= mid || p2 <= right) {
                if (p1 > mid) {
                    sorted[p++] = nums[p2++];
                } else if (p2 > right) {
                    sorted[p++] = nums[p1++];
                } else {
                    if (nums[p1] < nums[p2]) {
                        sorted[p++] = nums[p1++];
                    } else {
                        sorted[p++] = nums[p2++];
                    }
                }
            }
            for (int k = 0; k < sorted.length; k++) {
                nums[left + k] = sorted[k];
            }
            return ans;
       
    }
```

## 桶排序

引入：

假设班上只有5 个同学，这5 个同学分别考了5 分、3 分、
5 分、2 分和8 分，现在想从小到大进行排序，
首先我们需要申请一个大小为11 的数组int a[11]。OK，现在你已经有了11 个变量，编号从a[0]-a[10]。刚开始的时候，我们将a[0]~a[10]都初始化为0，表示这些分数还都没有人
得过。例如a[0]等于0 就表示目前还没有人得过0 分，同理a[1]等于0 就表示目前还没有人得过1 分……a[10]等于0就表示目前还没有人得过10 分
下面开始处理每一个人的分数，第一个人的分数是5 分，我们就将相对应的a[5]的值在原来的基础增加1，即将a[5]的值从0 改为1，表示5分出现过了一次，，a[0]~a[10]中的数值其实就是0 分到10 分每个分数出现的次数。接下来，我们只需要将出现过的分数打印出来就可以了，出现几次就打印几次，具体如下。

```cpp
#include <stdio.h>
int main()
{
int a[11],i,j,t;
for(i=0;i<=10;i++)
a[i]=0; //初始化为0
for(i=1;i<=5;i++) //循环读入5个数
{
scanf("%d",&t); //把每一个数读到变量t中
a[t]++; //进行计数
}
for(i=0;i<=10;i++) //依次判断a[0]~a[10]
for(j=1;j<=a[i];j++) //出现了几次就打印几次
printf("%d ",i);
getchar();getchar();
//这里的getchar();用来暂停程序，以便查看程序输出的内容
//也可以用system("pause");等来代替
return 0;
}

```
只需要将for(i=0;i<=10;i++)改为for(i=10;i>=0;i--)就可以实现从大到小排序。
这个算法就好比有11 个桶，编号从0~10。每出现一个数，就在对应编号的桶中放一个小旗子，最后只要数数每个桶中有几个小旗子就OK 了。
如果需要对数据范围在0~1000 之间的整数进行排序，我们需要**1001 个桶**，（不是1000个）来表示0~1000之间每一个数出现的次数，这一点一定要注意。另外，此处的每一个桶的作用其实就是“标记”每个数出现的次数。

最终桶排序的时间复杂度为O(m+n)。还有一点，在表示时间复杂度的时候，n 和m通常用大写字母即O(M+N)。

稍加改动：用桶排序去重

```cpp
#include <stdio.h>
int main()
{
int a[1001],n,i,t;
for(i=1;i<=1000;i++)
a[i]=0; //初始化
scanf("%d",&n); //读入n
for(i=1;i<=n;i++) //循环读入n个图书的ISBN号
{
scanf("%d",&t); //把每一个ISBN号读到变量t中
a[t]=1; //标记出现过的ISBN号
}
for(i=1;i<=1000;i++) //依次判断1~1000这个1000个桶
{
if(a[i]==1)//如果这个ISBN号出现过则打印出来
printf("%d ",i);
}
getchar();getchar();
return 0;
}
```

法2

假设有n个元素m个桶，如果元素值是平均分布的，则每个桶里面平均有n/m个元素，如果对每个桶中的元素进行快速排序那么桶排序的时间复杂度=o(n+log2n-nlog2m) 当m接近n时桶排序的时间复杂度接近o(n)
一种更有效的方法是求出a中的最大元素max和最小元素min,设置桶个数num = (max-min+1)/10+1;然后对a数组从头到尾扫描一遍，把a[i]放入对应的桶B[K\](K=(a[i]-min+1)/10)再对这些桶进行排序，最后依次输出每个桶里的元素

```cpp
#define bsize 10 // 每个桶的大小
typedef {
int data[bsize];//桶中放的元素
int count;// 桶中元素个数
}BuckType;

void BuckSort(int a[], int n)
{
int min = a[0], max = a[0];
for(int i = 0;i < n; i++)
{
if(a[i] > max)
max = a[i];
if(a[i] < min)
min = a[i]; 
}
num = (max - min +1)/10;//桶个数
BuckType* pb=(BuckType*) malloc(sizof(BuckType)*num);
memset(0, pb, sizof(BuckType) *num);
for(int i = 0;i < n; i++)
{
k = (a[i] -min +1)/bsize;//将a的所有元素分配到对应桶中
(pb+k) ->data[(pb+k)->count] = a[i];//k是桶编号
(pb+k)->count++;
}
int t = 0;
for(int i = 0;i < num ;i++)
{
QickSort((pb+i)->data,0,(pb+i)->count - 1);//单个桶快速排序
for(int j = 0;j <(pb+i)->count; j++)
a[t++] = (pb+i)->data[j];

}
free(pb);//释放内存

}
```
上面的算法是基于输入的n个元素平均分布的假设，否则如果所有元素都落在一个桶中就退化成一般的排序了，且适合元素集并不大的情况


## 出牌游戏
将一副扑克牌平均分成两份，每人拿一份。小哼先拿出手中的
第一张扑克牌放在桌上，然后小哈也拿出手中的第一张扑克牌，并放在小哼刚打出的扑克牌的上面，就像这样两人交替出牌。出牌时，如果某人打出的牌与桌上某张牌的牌面相同，即可将两张相同的牌及其中间所夹的牌全部取走，并依次放到自己手中牌的末尾。当任意一人手中的牌全部出完时，游戏结束，对手获胜。
出牌和赢牌这恰好对应队列的两个操作，出牌就是出队，赢牌就是入队。小哈的操作和小哼是一样的。而桌子就是一个栈，每打出一张牌放到桌上就相当于入栈。当有人赢牌的时候，依次将牌从桌上拿走，这就相当于出栈。那如何解决赢牌的问题呢？赢牌的规则是：如果某人打出的牌与桌
上的某张牌相同，即可将两张牌以及中间所夹的牌全部取走。那如何知道桌上已经有哪些牌了呢？最简单的方法就是枚举桌上的每一张牌，当然也有更好的办法：是用一个数组来记录桌上有哪些牌。因为牌面只有1~9，因此只需开一个大小为10 的数组来记录当前桌上已经有哪些牌面就可以了。
初始化时
for(i=1;i<=9;i++)
book[i]=0;
如果桌面上增加了一张牌面为2 的牌，那就需要将book[2]设置为1，表示牌面为2 的牌桌上已经有了。当然如果这张牌面为2 的牌被拿走后，需要及时将book[2]重新设置为0，表示桌面上已经没有牌面为2 的牌了。

```cpp
struct card{
int tail;
int head;//队头和队尾用来入队和出队
int num[100];
};

struct tablecard {
  int data[10];
  int top;
};


    int main() 
{
     int marked[10] = {0};
struct card c1,c2;
struct tablecard tb;
c1.tail = c1.head = 1;
c2.head = c2.tail = 1;

for(int i = 0;i < 6;i++){
  //6代表一开始每个人手上六张牌
  cin>>c1.num[c1.tail];
  c1.tail++;
}
for(int i = 0;i < 6;i++){
  //6代表一开始每个人手上六张牌
  cin>>c2.num[c2.tail];
  c2.tail++;
}
for(int i = 0;i < 10; i++)
marked[i] = 0;
tb.top = 0;
int t;
while(c1.head < c1.tail && c2.head < c2.tail)
{
 
t = c1.num[c1.head];


c1.head++;
if(marked[t]) 
{
 
  c1.num[c1.tail] = t;
   c1.tail++;
  while(tb.data[tb.top] != t)
  {
    c1.num[c1.tail++] = tb.data[tb.top];
    marked[tb.data[tb.top]] = 0;//!!!!注意，要记得取消标记
    tb.top--;
  }
}
else {
  
  marked[t]  = 1;
tb.top++;
tb.data[tb.top] = t;
}



t = c2.num[c2.head];


c2.head++;
if(marked[t]) 
{

  c2.num[c2.tail] = t;
    c2.tail++;
  while(tb.data[tb.top] != t)
  {

    c2.num[c2.tail++] = tb.data[tb.top];
    marked[tb.data[tb.top]] = 0;//!!!!注意，要记得取消标记
    tb.top--;
  }
}
else {
  marked[t]  = 1;
tb.top++;
tb.data[tb.top] = t;
}

}
if(c1.head != c1.tail)
{cout<<"小明！";
for(int i = c1.head;i!=c1.tail; i++)
cout<<c1.num[i];
}
if(c2.head != c2.tail)
{
  cout<<"小王！";
  for(int i = c2.head;i!=c2.tail; i++)
cout<<c1.num[i];
}
}
 

```

## 快速排序：

```java
  public static void sort(Comparable[]a)
	    {
	    	sort(a,0,a.length-1);
	    }
	    public static void sort(Comparable[]a,int lo,int hi)
	    {
	    	if(lo >= hi) return;
	    	int j = partion(a,lo,hi);
	    	sort(a,lo,j-1);//左半部分排序
	    	sort(a,j+1,hi);//右半部分排序
	    }
	    
	    //快速排序的切分
	   public static int partion(Comparable[]a,int lo,int hi)
	   {
		   Comparable v = a[lo];
		   int i = lo,j = hi+1;
		   //数组切分为a[lo,...j-1] a[j] a[j+1,...hi]
		   while(true) {
	
		   while(less(a[++i],v)) if(i == hi) break;
		   while(less(v,a[--j] )) if(j == lo) break;
		   if(i>=j) break;
		   exch(a,i,j);
		   }
		   exch(a,lo,j);//将v=a[j]放在正确的位置
		   return j;//a[lo...j-1]<= a[j]<=[aj+1,...hoi]实现
		   //调试了一下将i换成j结果也是一样的
	   }

	    
```

先用partion方法将a[j]放在一个合适的位置，然后递归调用将其他位置的元素排序，一般是先随意取a[lo]作为切分元素，然后从数组左端向右端直到找到一个大于等于它的元素，再从右端开始向左扫描直到找到一个小于等于它的元素

当两指针相遇时，只需要将切分元素a[lo]和左子数组最右侧元素a[j]交换然后返回j

测试条件j==lo是冗余的，因为切分元素就是a[lo],它不可能比自己小。

归并排序和希尔排序一般比快速排序慢。

方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。

![094811yilrz1tkzkvlrriz.png](http://s9.51cto.com/wyfs02/M00/1A/00/wKioL1MUSNWg3HhPAAAfgmnJY0E832.jpg-wh_651x-s_2122757912.jpg)

 

首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。）。哨兵j一步一步地向左挪动（即j--），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。

![095430axy0qkhxxkktkktk.png](http://s3.51cto.com/wyfs02/M00/1A/00/wKioL1MUSNbjWRw9AAAfljx73DY807.jpg)

![095437kdandfxhbtokk2qh.png](http://s9.51cto.com/wyfs02/M00/19/FF/wKiom1MUSP7gBX4VAAAaPLt4QB0783.jpg)

现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：

6  1  2  5 9 3  4  7 10  8

![095448k1kevwlz41373e7k.png](http://s7.51cto.com/wyfs02/M00/19/FF/wKiom1MUSQCzWy0UAAAe9Ihqgcs108.jpg)

![095458ejza15wscjv7iw5c.png](http://s7.51cto.com/wyfs02/M01/19/FF/wKiom1MUSQOCyGOFAAAbW4sRFRs031.jpg)

到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：

6  1  2 5  4 3  9 7 10  8

第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：

3 1 2  5  4  6 9 7  10  8

![095506uz7e1uuukcblhkxv.png](http://s2.51cto.com/wyfs02/M01/19/FF/wKiom1MUSQWiPameAAAawpa4u98529.jpg)

![095514cag5fumuqqg5jnsw.png](http://s3.51cto.com/wyfs02/M02/19/FF/wKiom1MUSQizZS4AAAAg4BoYKU8539.jpg)

![095530e0jf6p0y6aaaw2ir.png](http://s3.51cto.com/wyfs02/M00/19/FF/wKiom1MUSQqSkSkpAAAchtx6GUg755.jpg)

到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。

### 三分切向的快速排序(算法 P201)

```java
public static void sort(Comparable[]a,int lo,int hi)
	    {

			   if(hi<=lo) return;
			   Comparable v = a[lo];
			   int i = lo +1,lt = lo,gt = hi;
			   while(i <= gt)
			   {
				   int cmp = a[i].compareTo(v);
				   if(cmp < 0) exch(a,lt++,i++);
				   else if(cmp > 0) exch(a,i,gt--);
				   else i++;
			   }
			   sort(a,lo,lt-1);
			   sort(a,gt+1,hi);
	    }
```

![image-20201216152111279](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20201216152111279.png)



## 模仿二分查找设计一个三分查找

```java
int Search(T a[],int low,int high,T X){
    if(low > high)
return -1;
    else if(low == high) {
        if(a[low] == x) return low;
        else
            return -1;
    }
    if(high -low<2){
        if(x==a[low]) return low;
        else if(x == a[low+1]) return low+1;
        else return -1;
    }
    int length = (high - low+1)/3;//每个子序列的长度
    int mid1 = low+length;
    int mid2 = high -length;
    if(x == a[mid1]) return mid1;
    else if(x < a[mid1])
        return Search(a,low,mid-1,x);
    else if(x == a[mid2]) return mid2;
else if(x < a[mid2]) return Search(a,mid1+1,mid2-1,x);
    else return Search(a,mid2+1,high,x);
}
```

## 堆排序

```java
//构建大根堆：将array看成完全二叉树的顺序存储结构
 2     private int[] buildMaxHeap(int[] array){
 3         //从最后一个节点array.length-1的父节点（array.length-1-1）/2开始，直到根节点0，反复调整堆
 4         for(int i=(array.length-2)/2;i>=0;i--){ 
 5             adjustDownToUp(array, i,array.length);
 6         }
 7         return array;
 8     }
 9     
10     //将元素array[k]自下往上逐步调整树形结构
11     private void adjustDownToUp(int[] array,int k,int length){
12         int temp = array[k];   
13         for(int i=2*k+1; i<length-1; i=2*i+1){    //i为初始化为节点k的左孩子，沿节点较大的子节点向下调整
14             if(i<length && array[i]<array[i+1]){  //取节点较大的子节点的下标
15                 i++;   //如果节点的右孩子>左孩子，则取右孩子节点的下标
16             }
17             if(temp>=array[i]){  //根节点 >=左右子女中关键字较大者，调整结束
18                 break;
19             }else{   //根节点 <左右子女中关键字较大者
20                 array[k] = array[i];  //将左右子结点中较大值array[i]调整到双亲节点上
21                 k = i; //【关键】修改k值，以便继续向下调整
22             }
23         }
24         array[k] = temp;  //被调整的结点的值放人最终位置
25     }    
 1     //堆排序
 2     public int[] heapSort(int[] array){
 3         array = buildMaxHeap(array); //初始建堆，array[0]为第一趟值最大的元素
 4         for(int i=array.length-1;i>1;i--){  
 5             int temp = array[0];  //将堆顶元素和堆低元素交换，即得到当前最大元素正确的排序位置
 6             array[0] = array[i];
 7             array[i] = temp;
 8             adjustDownToUp(array, 0,i);  //整理，将剩余的元素整理成堆
 9         }
10         return array;
11     }
```

## [969. 煎饼排序](https://leetcode.cn/problems/pancake-sorting/)

难度中等286

给你一个整数数组 `arr` ，请使用 **煎饼翻转** 完成对数组的排序。

一次煎饼翻转的执行过程如下：

- 选择一个整数 `k` ，`1 <= k <= arr.length`
- 反转子数组 `arr[0...k-1]`（**下标从 0 开始**）

例如，`arr = [3,2,1,4]` ，选择 `k = 3` 进行一次煎饼翻转，反转子数组 `[3,2,1]` ，得到 `arr = [**1**,**2**,**3**,4]` 。

以数组形式返回能使 `arr` 有序的煎饼翻转操作所对应的 `k` 值序列。任何将数组排序且翻转次数在 `10 * arr.length` 范围内的有效答案都将被判断为正确。

 

**示例 1：**

```
输入：[3,2,4,1]
输出：[4,2,4,3]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 arr = [3, 2, 4, 1]
第一次翻转后（k = 4）：arr = [1, 4, 2, 3]
第二次翻转后（k = 2）：arr = [4, 1, 2, 3]
第三次翻转后（k = 4）：arr = [3, 2, 1, 4]
第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。 
```

-----------------------------

![image-20230120201808171](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230120201808171.png)

思路：煎饼排序每摊一次，就会有一个数被排好序。比较容易想到的策略是使得这个数要么是在第一个元素，要么是在本次被摊的最后一个元素。如果选择第一个元素被排好序，那么在下次摊的时候会被翻转翻掉，因此想到选择本次被摊的最后一个元素，将其移到数组最后。所以策略就是每次都找到最大的那个元素，然后放到最后一个位置即可

```java
 public List<Integer> pancakeSort(int[] arr) {
  List<Integer> ret = new ArrayList<Integer>();
        for (int n = arr.length; n > 1; n--) {
            int index = 0;
            for (int i = 1; i < n; i++) {
                if (arr[i] >= arr[index]) {
                    index = i;
                }
            }
            if (index == n - 1) {
                continue;
            }
            reverse(arr, index);
            reverse(arr, n - 1);
            ret.add(index + 1);
            ret.add(n);
        }
        return ret;
    }

    public void reverse(int[] arr, int end) {
        for (int i = 0, j = end; i < j; i++, j--) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
```



# 原地哈希

## [41. 缺失的第一个正数]

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。


示例 1：

输入：nums = [1,2,0]
输出：3
示例 2：

输入：nums = [3,4,-1,1]
输出：2

----

![image-20220208122115128](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220208122115128.png)



首先想到的是利用哈希表来存储数组中的元素，然后从`1`开始遍历整数，不在哈希表中的第一个数字便是我们的解。我们知道了要从 `1` 开始遍历，那遍历到什么值为止呢？
 设数组的长度为 `n`，如果数组中的元素正好为 `[1, …, n]` ，则缺失的元素为 `n+1`；如果数组中有非 `[1, …, n]` 的数字呢？则它们占用的位置就是 `[1, …, n]` 中缺失的那些数字的位置。所以我们要找的数字一定是在 `[1, …, n+1]` 之间。所以我们需要遍历的最大值为 `n+1`。
 题目要求使用常数级别的额外空间，而我们使用哈希表来存储数字，空间复杂度为 `O(n)`，不满足要求。基于此，我们尝试将原数组改造成哈希表(需要修改原数组，所以题目不能要求说不能修改原数组)，这样不使用额外的空间。

我们对数组进行遍历，对于遍历到的值 `num`，如果它的值在 `[1, n]` 之间，那么就将数组中索引为 `num-1` 的数字打上标记，在遍历结束后，如果所有位置都被打上了标记，则答案为 `n+1`，否则为最小的没有打上标记的位置加 `1`。
 由于我们只在意 `[1, n]` 中的数字，所以可以将其他数字做统一修改，比如改为 `n+1`，这样数组中的数字都为正整数，也方便了我们使用数组中的元素作为索引来用。

![image-20230117193058540](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230117193058540.png)

```java
  public int firstMissingPositive(int[] nums) {
int len=nums.length;
for(int i=0;i<len;i++)
{if(nums[i]<=0) nums[i]=len+1;

}
for(int i=0;i<len;i++)
{
    int number=Math.abs(nums[i]);
    if(number<=len)nums[number-1] =-Math.abs(nums[number - 1]);//如果2出现了，修改nums[1] 如果1出现了 修改nums[0] 最大未出现的正数也只有n+1
}
for(int i=0;i<len;i++)
{
    if(nums[i]>0) return i+1;
}

return len+1;
    }
```

方法2：置换 将1放在0位置，2放在1位置

![image-20230220000745076](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230220000745076.png)

```java
public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; ++i) {
            //目的是把nums[i]放在nums[nums[i]-1]的位置 
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }


```



## 第k个缺失的正数

给出一个有序数组 `A`，数组中的每个数字都是 **独一无二的**，找出从数组最左边开始的第 `K` 个缺失数字。

**示例 1：**

```text
输入：A = [4,7,9,10], K = 1
输出：5
解释：
第一个缺失数字为 5 。
```

**示例 2：**

```text
输入：A = [4,7,9,10], K = 3
输出：8
解释： 
缺失数字有 [5,6,8,...]，因此第三个缺失数字为 8 。
```

**示例 3：**

```text
输入：A = [1,2,4], K = 3
输出：6
解释：
缺失数字有 [3,5,6,7,...]，因此第三个缺失数字为 6 。
```

**提示：**

1. `1 <= A.length <= 50000`
2. `1 <= A[i] <= 1e7`
3. `1 <= K <= 1e8`

---------------

方法：二分查找

### 

看到有序数组，查找某个数字，一定想到二分查找的方法，然后再细致思考具体的实施方式。

我们要找到缺失的第k个数字，**数组中的最小值minn = nums[0]，从minn开始递增，不存在的第K个数即为答案。**

直接递增查找的方法时间复杂度较高，我们需要使用二分查找的方法优化。left=0，right=len(nums)-1。

我们的目的**是找到第K个缺失数字往前递减，遇到的前面的第一个存在于nums数组中的数字的下标x，得到这个下标之后，我们的答案就可以轻松得出，即minn+x+k。即minn为最小值，x为答案之前存在于nums数组中的个数（不算minn），只要在minn上增加（x+k）,即排除了递增到答案的过程中，存在于数组中的x个元素，再加k即为答案。**

那么找到这个x的过程如下：

```python
while left < right:
            mid = left + (right-left+1)//2
            # 当mid时，数组中算nums[mid]一共有mid+1个值，
            # 那么此时nums[mid]的最小值为minn+mid(即每个值递增1)
            # 那么缺少的第k个数字即为minn+mid+k
            # 如果此时nums[mid] >= minn+mid+k，
            # 第K个缺失数字之前的nums中的那个值肯定在0-mid之间
            # 反之，在mid-right之间
            if nums[mid]>= minn+k+mid:
                right = mid-1
            else:
                left = mid
```

**最后找到的left，即为x，返回minn+left+k即为答案**

代码：

```python
    def missingElement(self, nums: List[int], k: int) -> int:
        # minn为最小值
        minn = nums[0]
        # 左右指针
        left = 0
        right = len(nums) - 1
        # 开始二分，找到第K个缺失数字之前的nums中的那个值的下标
        # 即比如示例2，找到7对应的位置，下标1
        while left < right:
            mid = left + (right-left+1)//2
            # 当mid时，数组中算nums[mid]一共有mid+1个值，
            # 那么此时nums[mid]的最小值为minn+mid(即每个值递增1)
            # 那么缺少的第k个数字即为minn+mid+k
            # 如果此时nums[mid] >= minn+mid+k，
            # 第K个缺失数字之前的nums中的那个值肯定在0-mid之间
            # 反之，在mid-right之间
            if nums[mid]>= minn+k+mid:
                right = mid-1
            else:
                left = mid
        #找到left之后，答案为minn + left + k，minn为最小值，left为存在于数组中的值
        #k为未存在数组中的值
        return minn + left + k
```





## [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)

#### 

难度简单269

不使用任何内建的哈希表库设计一个哈希映射（HashMap）。

实现 `MyHashMap` 类：

- `MyHashMap()` 用空映射初始化对象
- `void put(int key, int value)` 向 HashMap 插入一个键值对 `(key, value)` 。如果 `key` 已经存在于映射中，则更新其对应的值 `value` 。
- `int get(int key)` 返回特定的 `key` 所映射的 `value` ；如果映射中不包含 `key` 的映射，返回 `-1` 。
- `void remove(key)` 如果映射中存在 `key` 的映射，则移除 `key` 和它所对应的 `value` 。



---

注意：

关键是要注意需要要哈希算法、数组、且模拟java的哈希表设计，每一个数组的元素是一个链表，这样发生哈希冲突的时候往链表末尾放，取元素的时候先计算哈希值，再在数组的这个位置上获得链表，往链表上放

```java
class MyHashMap {
    class Node{
    int key;
    int value;
    Node()
    {

    }
    Node(int key)
    {
        this.key=key;
    }
    Node(int key,int value)
    {
        this.key=key;
        this.value=value;
    }

        public int getKey() {
            return key;
        }

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            this.value = value;
        }


    }
      private static final int BASE = 769;//用于取模
    LinkedList[]data;//数组中的每一个元素都是链表
//List<Node>mylist;
    public MyHashMap() {
        data = new LinkedList[BASE];
for(int i=0;i<BASE;i++)
data[i]=new LinkedList<Node>();
    }
    
    public void put(int key, int value) {
        int hashkey=hash(key);
Iterator<Node>iter=data[hashkey].iterator();
    while(iter.hasNext())
    {
        Node node=iter.next();
        if(node.getKey()==key)
        {
            node.setValue(value);
            return;
        }
    }
    data[hashkey].offerLast(new Node(key,value));
    return;
    }
    
    public int get(int key) {
    int hashkey=hash(key);
Iterator<Node>iter=data[hashkey].iterator();
    while(iter.hasNext())
    {
        Node node=iter.next();
        if(node.getKey()==key)
        {            
            return node.value;
        }
    }
    return -1;
    }    
    public void remove(int key) {
   int hashkey=hash(key);
Iterator<Node>iter=data[hashkey].iterator();
    while(iter.hasNext())
    {
        Node node=iter.next();
        if(node.getKey()==key)
        {
            
           data[hashkey].remove(node);
           return;
        }
    }
    }
       private static int hash(int key) {
        return key % BASE;
    }
}
```

## [1497. 检查数组对是否可以被 k 整除](https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/)

难度中等74

给你一个整数数组 `arr` 和一个整数 `k` ，其中数组长度是偶数，值为 `n` 。

现在需要把数组恰好分成 `n / 2` 对，以使每对数字的和都能够被 `k` 整除。

如果存在这样的分法，请返回 *True* ；否则，返回 *False* 。

 

**示例 1：**

```
输入：arr = [1,2,3,4,5,10,6,7,8,9], k = 5
输出：true
解释：划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。
```

------------------

![image-20230114224951360](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230114224951360.png)

```java
  public boolean canArrange(int[] arr, int k) {
int[]map=new int[k];
for(int i=0;i<arr.length;i++)
//注意这里对负数的处理，(arr[i]%k+k)%k是一种对称的关系，不能用math.abs去算
map[((arr[i]%k+k)%k)]++;
for(int i=1;i<map.length;i++){
    if(map[i]!=map[k-i]) return false;
}
return map[0]%2==0;
    }
```



# 字典树问题

## [211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

难度中等479

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 `WordDictionary` ：

- `WordDictionary()` 初始化词典对象
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true` ；否则，返回 `false` 。`word` 中可能包含一些 `'.'` ，每个 `.` 都可以表示任何一个字母。

这里的匹配是指两个字符串相等

输入：
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
输出：
[null,null,null,null,false,true,true,true]



--------------------

```java
class WordDictionary {


  private Trie root;

    public WordDictionary() {
        root = new Trie();
    }
        
    public void addWord(String word) {
root.insert(word);
    }
    
    public boolean search(String word) {
       return dfs(word,0,root);
    }
    public boolean dfs(String word,int begin,Trie root){
        if(begin==word.length())
         return root.isEnd();
         char ch=word.charAt(begin);
         //如果当前字符是字母，则判断当前字符对应的子结点是否存在，如果子结点存在则移动到子结点，继续搜索下一个字符，如果子结点不存在则说明单词不存在，返回false；

//如果当前字符是点号，由于点号可以表示任何字母，因此需要对当前结点的所有非空子结点继续搜索下一个字符。
        //重复上述步骤，直到返回 \text{false}false 或搜索完给定单词的最后一个字符。

//如果搜索完给定的单词的最后一个字符，则当搜索到的最后一个结点的 isEnd 为 true 时，给定的单词存在。
//特别地，当搜索到点号时，只要存在一个非空子结点可以搜索到给定的单词，即返回true。

         if(ch!='.'){
             if(root.getChildren()[ch-'a']==null) return false;
             root=root.getChildren()[ch-'a'];
             if(dfs(word,begin+1,root)) return true;
         }
         else{
             for(int i = 0;i<26;i++){
                   Trie child = root.getChildren()[i];
               if(child!=null&&dfs(word,begin+1,child)){
                   return true;
               }
             }
         }
           return false;
    }
}
class Trie {
    private Trie[] children;
    private boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    public void insert(String word) {
        Trie node=this;
        for (int i = 0; i < word.length(); i++) {
            char ch=word.charAt(i);
            int index=ch-'a';
            if(node.children[index]==null){
                node.children[index]=new Trie();

            }
            node=node.children[index];
        }
        node.isEnd=true;
    }
    public Trie[] getChildren() {
        return children;
    }

    public boolean isEnd() {
        return isEnd;
    }

   

}
```



## [剑指 Offer II 064. 神奇的字典](https://leetcode.cn/problems/US1pGT/)

难度中等38

设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 **互不相同** 。 如果给出一个单词，请判定能否只将这个单词中**一个**字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。

实现 `MagicDictionary` 类：

- `MagicDictionary()` 初始化对象
- `void buildDict(String[] dictionary)` 使用字符串数组 `dictionary` 设定该数据结构，`dictionary` 中的字符串互不相同
- `bool search(String searchWord)` 给定一个字符串 `searchWord` ，判定能否只将字符串中 **一个** 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例：**

```
输入
inputs = ["MagicDictionary", "buildDict", "search", "search", "search", "search"]
inputs = [[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]
输出
[null, null, false, true, false, false]
```



----

如果用遍历法效率很低，这里用字典树优化

```java
class MagicDictionary {
 Node trie;
    /** Initialize your data structure here. */
    public MagicDictionary() {
trie=new Node();
    }
    
    public void buildDict(String[] dictionary) {
  for (String word : dictionary) {
            Node cur = trie;
          cur.insert(word);
        }
    }
    
    public boolean search(String searchWord) {
        return dfs(searchWord,trie,0,false);

}
      public boolean dfs(String searchWord,Node trie,int begin,boolean isChange)
    {
if(begin==searchWord.length()) return isChange&&trie.isLast;
int index=searchWord.charAt(begin)-'a';
if(trie.child[index]!=null)
{
       if(dfs(searchWord,trie.child[index],begin+1,isChange))
    return true;
    //注意，这里不能加     else return false; 否则会出错，因为不一定这条路不符合，不代表其他的路径也不符合，比如说字典中有一个字符串abced和aoooo，现在有字符串abooo是不符合abced的，如果匹配了ab往下发现就不符合了，如果这时候就返回false的话就是错的

     if(isChange) return false;
     else{
      for(int j=0;j<26;j++)
    {
        if(j!=index&&trie.child[j]!=null&&dfs(searchWord,trie.child[j],begin+1,true))
        {
return true;
        }
    
     }
}


return false;
    }
    
 
    
    class Node{
        Node[]child;
        boolean isLast;
        public Node()
        {
            child=new Node[26];
            isLast=false;
        }
        public void insert(String word)
        {
            Node node=this;
            for(int i=0;i<word.length();i++)
            {
                char ch=word.charAt(i);
                if(node.child[ch-'a']==null)
                {
                    node.child[ch-'a']=new Node();
                }
                node=node.child[ch-'a'];
            }
            node.isLast=true;
        }
    }
}

```



## [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

难度中等1385

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

-----

```java
class Trie {
Trie[]children;
boolean isEnd;
    public Trie() {
children=new Trie[26];
isEnd=false;
    }
    
    public void insert(String word) {
Trie node=this;
for(int i = 0;i<word.length();i++){
    char ch=word.charAt(i);
    if(node.children[ch-'a']==null){
        node.children[ch-'a']=new Trie();
     
    }
       node=node.children[ch-'a'];
}
node.isEnd=true;
    }
    
    public boolean search(String word) {
Trie node=searchPrefix(word);
return node!=null&&node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
Trie node=searchPrefix(prefix);
return node!=null;
    }

     private Trie searchPrefix(String prefix) {
        Trie node = this;
        for (int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }
        return node;
    }

}
```

## [剑指 Offer II 063. 替换单词](https://leetcode.cn/problems/UhWRSj/)

难度中等33

在英语中，有一个叫做 `词根(root)` 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 `继承词(successor)`。例如，词根`an`，跟随着单词 `other`(其他)，可以形成新的单词 `another`(另一个)。

现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有`继承词`用`词根`替换掉。如果`继承词`有许多可以形成它的`词根`，则用最短的词根替换它。

需要输出替换之后的句子。

 

**示例 1：**

```
输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
输出："the cat was rat by the bat"
```

-------

这是有关前缀的问题，故应考虑用前缀树的方法，先按照dictionary建立一棵前缀树，然后遍历句子，如果找到了一个前缀且它是走到了结尾，那么就进行替换，且因为先遍历到的是更短的，所以一定会用最短的词根

```java
 public String replaceWords(List<String> dictionary, String sentence) {
 Trie trie=new Trie();
 for(String dic:dictionary)
 {
     Trie t=trie;
     t.insert(dic);
 }
  String[] words = sentence.split(" ");
        for (int i = 0; i < words.length; i++) {
            words[i] = trie.findRoot(words[i], trie);
        }
return String.join(" ",words);
    }
  
}
  class Trie{
        Trie[]children;
        boolean isEnd;
        public Trie()
        {
            children=new Trie[26];
            isEnd=false;
        }
        public void insert(String word)
        {
Trie node=this;
for(int i=0;i<word.length();i++)
{
    int index=word.charAt(i)-'a';
    if(node.children[index]==null)
    node.children[index]=new Trie();
    node=node.children[index];
}
node.isEnd=true;
        }
        public String findRoot(String word,Trie trie)
        {
            Trie node=trie;
            for(int i=0;i<word.length();i++)
            {
                int index=word.charAt(i)-'a';
                if(node.children[index]==null) return word;
                if(node.children[index].isEnd==true) return word.substring(0,i+1);
                node=node.children[index];
            }
            return word;
        }
    }
```

## [剑指 Offer II 066. 单词之和](https://leetcode.cn/problems/z1R5dt/)

难度中等27

实现一个 `MapSum` 类，支持两个方法，`insert` 和 `sum`：

- `MapSum()` 初始化 `MapSum` 对象
- `void insert(String key, int val)` 插入 `key-val` 键值对，字符串表示键 `key` ，整数表示值 `val` 。如果键 `key` 已经存在，那么原来的键值对将被替代成新的键值对。
- `int sum(string prefix)` 返回所有以该前缀 `prefix` 开头的键 `key` 的值的总和。

 

**示例：**

```
输入：
inputs = ["MapSum", "insert", "sum", "insert", "sum"]
inputs = [[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
输出：
[null, null, 3, null, 5]

解释：
MapSum mapSum = new MapSum();
mapSum.insert("apple", 3);  
mapSum.sum("ap");           // return 3 (apple = 3)
mapSum.insert("app", 2);    
mapSum.sum("ap");           // return 5 (apple + app = 3 + 2 = 5)
```

------

对于字典树中的每一个前缀都要加上对应的值,这里不再需要判断是否是结尾

```java
class MapSum {
class Trie{
    Trie[]children=new Trie[26];
    int val;
}
Trie trie;
Map<String,Integer>map=new HashMap<>();
    /** Initialize your data structure here. */
    public MapSum() {
trie=new Trie();
    }
    
    public void insert(String key, int val) {
int diff=val-map.getOrDefault(key,0);
map.put(key,val);
Trie node=trie;
for(int i =0;i<key.length();i++)
{
int index=key.charAt(i)-'a';
if(node.children[index]==null)
node.children[index]=new Trie();
//要先移动到子节点然后再加上val
node=node.children[index];
node.val+=diff;
}
    }
    
    public int sum(String prefix) {
        Trie node=trie;
        for(int i =0;i<prefix.length();i++)
{
    int index=prefix.charAt(i)-'a';
    if(node.children[index]==null) return 0;
    node=node.children[index];
}
return node.val;
    }
}

```

insert就类似下面这种思想：每个前缀和对应的值都进行存储

   public void insert(String key, int val) {
        int delta = val - map.getOrDefault(key, 0);
        map.put(key, val);
        for (int i = 1; i <= key.length(); ++i) {
            String currprefix = key.substring(0, i);
            prefixmap.put(currprefix, prefixmap.getOrDefault(currprefix, 0) + delta);
        }
    }

## [剑指 Offer II 065. 最短的单词编码](https://leetcode.cn/problems/iSwD2y/)

难度中等35

单词数组 `words` 的 **有效编码** 由任意助记字符串 `s` 和下标数组 `indices` 组成，且满足：

- `words.length == indices.length`
- 助记字符串 `s` 以 `'#'` 字符结尾
- 对于每个下标 `indices[i]` ，`s` 的一个从 `indices[i]` 开始、到下一个 `'#'` 字符结束（但不包括 `'#'`）的 **子字符串** 恰好与 `words[i]` 相等

给定一个单词数组 `words` ，返回成功对 `words` 进行编码的最小助记字符串 `s` 的长度 。

 

**示例 1：**

```
输入：words = ["time", "me", "bell"]
输出：10
解释：一组有效编码为 s = "time#bell#" 和 indices = [0, 2, 5] 。
words[0] = "time" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[1] = "me" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[2] = "bell" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
```

```java
   public int minimumLengthEncoding(String[] words) {
        TrieNode trie = new TrieNode();
        Map<TrieNode, Integer> nodes = new HashMap<TrieNode, Integer>();

        for (int i = 0; i < words.length; ++i) {
            String word = words[i];
            TrieNode cur = trie;
            //注意这里j是从最后一个往前遍历的
            for (int j = word.length() - 1; j >= 0; --j) {
                cur = cur.get(word.charAt(j));
            }
            nodes.put(cur, i);
        }

        int ans = 0;
        for (TrieNode node: nodes.keySet()) {
            if (node.count == 0) {
                ans += words[nodes.get(node)].length() + 1;
            }
        }
        return ans;

    }
}

class TrieNode {
    TrieNode[] children;
    int count;

    TrieNode() {
        children = new TrieNode[26];
        count = 0;
    }

    public TrieNode get(char c) {
        if (children[c - 'a'] == null) {
            children[c - 'a'] = new TrieNode();
            count++;
        }
        return children[c - 'a'];
    }


```

也可以用这种思路：我们发现，如果 t 是 s 的后缀，那么反转之后 t’ 就是 s’ 的前缀。在反转+排序之后，s’ 一定紧跟在 t’ 的后面！

这样，我们就可以检查排序后的每一个单词，如果当前单词是下一个单词的前缀，则将单词丢弃。这样我们就可以写出完成的题解代码了：

```java
public int minimumLengthEncoding(String[] words) {
    int N = words.length;
    // 反转每个单词
    String[] reversed_words = new String[N];
    for (int i = 0; i < N; i++) {
        String word = words[i];
        String rword = new StringBuilder(word).reverse().toString();
        reversed_words[i] = rword;
    }
    // 字典序排序    
    Arrays.sort(reversed_words);

    int res = 0;
    for (int i = 0; i < N; i++) {
        if (i+1 < N && reversed_words[i+1].startsWith(reversed_words[i])) {
            // 当前单词是下一个单词的前缀，丢弃
        } else {
            res += reversed_words[i].length() + 1; // 单词加上一个 '#' 的长度
        }
    }
    return res;
}


```



# 贪心算法

## 硬币问题

：有1元、5元、10元、50元、100元、500元的硬币各c1 c5 c10 c50 c100枚。现 在要用这些硬币来支付A元，最少需要多少枚硬币？假定本题至少存在一种支付方案

思路：尽量使用面额较大的硬币

```cpp
const int v[6]={1,5,10,50,100,500};//硬币面值
int A;
int c[6];//数量
void solve()
{
int ans = 0;
int t;
for(int i = 5;i >= 0;i--)
{
t = min(A/v[i],c[i]);
A -= t*v[i];
ans +=t;
}
}
```

## 区间调度问题

有"项工作，每项工作分别在s’时间开始，在t1时间结束。对于每项工作，你都可以选择参 与与否。如果选择了参与，那么自始至终都必须全程参与。此外，参与工作的时间段不能重 叠（即使是开始的瞬间和结束的瞬间的重叠也是不允许的）。你的目标是参与尽可能多的工作，那么最多能参与多少项工作呢？
输入
n = 5, s = {1, 2, 4, 6, 8}, t = {3, 5, 7, 9, 10}

输出	
3 （选取工作1、3,5）
这个问题也可以通过贪心算法来求解，但不像前面的硬币问题那么简单。我们可以设计出各种各 样的贪心算法，例如下面的算法就是其中最容易想到的一种。
(1)在可选的工作（也就是和目前已选的工作都不重叠的工作）中，每次都选取开始时间最早的 工作。
（2）	在可选的工作中，每次都选取用时最短的工作。
(3)	在可选的工作中，每次都选取与最少可选工作有重叠的工作。
算法一是正确的，而其余两种都可以找到对应的反例。或者说，在有些情况下，它们所选取的工 作并非最优。
该算法有一些不能正确处理的情况，例如对于下面的情况，该算法就无法得到正确的结果。


```cpp
const int MAX_N = 100000;
//输入
int N, S[MAX_N], T[MAX_N];
//用于对工作排序的pair数组
pair<int, int> itv[MAX_N];
void solve() {
//对pair进行的是字典序比较
//为了让结束时间早的工作排在前面，把T存入first,把S存入second
for(int i = 0;i < N;i++)
{
itv[i].first = T[i];itv[i].second=S[i];

}
sort(itv,itv+N);
int ans = 0;t = 0;//t是最后所选工作的结束时间
for(int i = 0;i<N;i++)
{
if(t<itv[i].second){ans++;
t = itv[i].first;}
}
}
```



## 最小字典序

字典序最小问题 Best Cow Line (POJ 3617)
给定长度为N的字符串S,要构造一个长度为N的字符串T。起初，r是一个空串，随后反 复进行下列任意操作。
.从S的头部删除一个字符，加到T的尾部
.从s的尾部删除一个字符，加到r的尾部 目标是要构造字典序尽可能小的字符串T
①字典序是指从前到后比较两个字符串大小的方法。首先比较第1个字符，如果不同则第1个字符较小的字符串更小，如 果相同则继续比较第2个字符……如此继续，来比较整个字符串的大小。 
输入
N = 6
S = "ACDBCB"
输出
ABCBCD 

从字典序的性质上看，无论T的末尾有多大，只要前面部分的较小就可以。所以我们可以试一下 如下贪心算法：
»不断取S的开头和末尾中较小的一个字符放到7的末尾。
这个算法已经接近正确了，只是针对S的开头和末尾字符相同的情形还没有定义。在这种情形下, 因为我们希望能够尽早使用更小的字符，所以就要比较下一个字符的大小。下一个字符也有可能 相同，因此就有如下算法：
■按照字典序比较S和将S反转后的字符串S'。
■如果S，就从S的开头取出一个文字，追加到T末尾。
■如果S'较小，就从S的末尾取出一个文字，追加到T末尾。
(如果相同则取哪个都可以)

```cpp
int N;
const int maxn = 100000;
char s[maxn];

void solve(){
int a = 0,b = N-1;
while(a <= b)
{
bool left = false;
for(int i = 0;i + a <=b;i++)
{if(s[a+i] < s[b-i]
{
left = true;
break;
}
else if(s[a+i] > s[b-i])
{
left = false;
break;
}}
if(left)putchar(a++);
else putchar(b--);
}
}
```


## 最少标记点
![image-20210104191106715](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210104191106715.png)

直线上有N个点。从这N个点中选择若干个，给它们加上标记。对每一个 点，其距离为R以内的区域里必须有带有标记的点(自己本身带有标记的点，可以认为与其 距离为0的地方有一个带有标记的点)。在满足这个条件的情况下，希望能为尽可能少的点 添加标记。请问至少要有多少点被加上标记？

输入
N = 6
R = 10
X = (1, 7, 15, 20, 30, 50)
输出
3

```cpp
int N, R;
int X[MAX_N];
void solve() {
sort(X, X + N);
int i = 0,ans = 0;
while(i < N)
{// s是没有被覆盖的最左的点的位置
int s = X[i++];// 一直向右前进直到距S的距离大于R的点
while(i < N && (s+R)>=X[i])i++;
int p = X[i-1];//p是新加上标记的点的位置
// 一直向右前进直到距p的距离大于R的点
while(i < N &&(p+R)>=X[i])i++;ans++;
}
cout<<ans;
}

```

## 跳跃游戏

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

----



![image-20220207211842059](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220207211842059.png)

```java
    public boolean canJump(int[] nums) {
        int index=0,right=0;

                for(int i=0;i<nums.length;i++)
                {
                    if(i<=right){
right=Math.max(nums[i]+i,right);
if(right>=nums.length-1) return true;
                }
                }
                return false;

    }
```

## [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

难度中等589

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 

这个题有一个关键，就是可以删除元素，因此不能用常规的方法

-----

```java
 public int wiggleMaxLength(int[] nums) {
if(nums.length==1) return 1;
if(nums.length==2 && nums[0] != nums[1]) return 2;
int prediff=0;//上一个差值
int curdiff = 0;//当前差值
int count = 1;
for(int i = 0;i < nums.length-1;i++)
{
    int cur = nums[i] - nums[i+1];
    if((prediff<=0&&cur>0)||(prediff>=0&&cur<0))
   { count++;
    prediff=cur;
   }
}
return count;
    }
```

也可以用动态规划解：

假设 up[i] 表示 nums[0:i] 中最后两个数字递增的最长摆动序列长度，down[i] 表示 nums[0:i] 中最后两个数字递减的最长摆动序列长度，只有一个数字时默认为 1。

接下来我们进行分类讨论：

nums[i+1] > nums[i]
假设 down[i] 表示的最长摆动序列的最远末尾元素下标正好为 i，遇到新的上升元素后，up[i+1] = down[i] + 1 ，这是因为 up 一定从 down 中产生（初始除外），并且 down[i] 此时最大。
假设 down[i] 表示的最长摆动序列的最远末尾元素下标小于 i，设为 j，那么 nums[j:i] 一定是递增的，因为若完全递减，最远元素下标等于 i，若波动，那么 down[i] > down[j]。由于 nums[j:i] 递增，down[j:i] 一直等于 down[j] ，依然满足 up[i+1] = down[i] + 1 。
nums[i+1] < nums[i]，类似第一种情况
nums[i+1] == nums[i]，新的元素不能用于任何序列，保持不变



```java
public int wiggleMaxLength(int[] nums) {
    int down = 1, up = 1;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1])
            up = down + 1;
        else if (nums[i] < nums[i - 1])
            down = up + 1;
    }
    return nums.length == 0 ? 0 : Math.max(down, up);
}

。
```

## [1247. 交换字符使得字符串相同](https://leetcode-cn.com/problems/minimum-swaps-to-make-strings-equal/)

难度中等53

有两个长度相同的字符串 `s1` 和 `s2`，且它们其中 **只含有** 字符 `"x"` 和 `"y"`，你需要通过「交换字符」的方式使这两个字符串相同。

每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。

交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 `s1[i]` 和 `s2[j]`，但不能交换 `s1[i]` 和 `s1[j]`。

最后，请你返回使 `s1` 和 `s2` 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 `-1` 。

 

**示例 1：**

```
输入：s1 = "xx", s2 = "yy"
输出：1
解释：
交换 s1[0] 和 s2[1]，得到 s1 = "yx"，s2 = "yx"。
```

**示例 2：**

```
输入：s1 = "xy", s2 = "yx"
输出：2
解释：
交换 s1[0] 和 s2[0]，得到 s1 = "yy"，s2 = "xx" 。
交换 s1[0] 和 s2[1]，得到 s1 = "xy"，s2 = "xy" 。
注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 "yx"，因为我们只能交换属于两个不同字符串的字符。
```

-----

由于要求交换次数尽量少，故：
本来相同位置就有相同的字符，不需要交换。
本来相同位置字符不同，需要交换。交换为两组字符交换，本质上只有两种情形：

(a) 2组相同(2组xy或2组yx，等价于示例1)：
此时，s1[0]与s2[1]交换即可，需要进行1次交换
(b) 2组不同(1组xy，1组yx，等价于示例2)：
此时，将s1[0]与s2[0]交换后与a相同，需要进行2次交换

综上所述，我们可以得出如下结论：
xy与yx的组数之和必须为偶数，否则返回-1(两两交换)
优先进行(a)类交换，剩余的进行(b)类交换(贪心算法)

![image-20220223191047746](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220223191047746.png)

```java
  public int minimumSwap(String s1, String s2) {

 int xy =0,yx = 0;
 for(int i = 0 ;i < s1.length();i++)
 {
     if(s1.charAt(i) == s2.charAt(i))
     continue;
     if(s1.charAt(i) == 'x')//s1[i] = x s2[i] = y
xy++;
else yx++;
 }
 if(((xy+yx) &1 )== 1) return -1;//注意这种判断是否是奇数的方法,比用%运算快一倍
 return xy/2+yx/2+yx%2*2;
    }
```

## [763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

难度中等675

字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

 

**示例：**

```
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
```

----

![image-20220307003918795](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220307003918795.png)

```java
public List<Integer> partitionLabels(String s) {
int[]arr = new int[26];//26个字母
for(int i = 0;i < s.length();i++)
{
    arr[s.charAt(i) - 'a'] = i;
}
int start = 0,end = 0;
List<Integer>mylist = new ArrayList<>();
for(int i = 0;i < s.length();i++)
{
    end = Math.max(end,arr[s.charAt(i)-'a']);
    if(end ==i)
    {
mylist.add(end-start+1);
start = end+1;
    }
}
return mylist;
    }
```



## [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

【这种区间问题首先想到对区间进行排序，需要判断是以左端点进行排序还是右端点进行排序，此题变换思维，移除区间可以转变为留下最多不重叠的区间即可，这样才能解出题目，所以可以同等变换为：不重叠的区间最多的个数。】

难度中等

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

 

**示例 1:**

```
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

------

![image-20220810224900433](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220810224900433.png)

此题用动态规划会超时，需要采用贪心法

![image-20220810225117218](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220810225117218.png)

![image-20230221195830697](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230221195830697.png)

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) {
            return 0;
        }
        
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] interval1, int[] interval2) {
                return interval1[1] - interval2[1];
            }
        });

        int n = intervals.length;
        int right = intervals[0][1];
        int ans = 1;
        for (int i = 1; i < n; ++i) {
            if (intervals[i][0] >= right) {
                ++ans;
                right = intervals[i][1];
            }
        }
        return n - ans;
    }
}


```

## [1353. 最多可以参加的会议数目](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/)

难度中等221

给你一个数组 `events`，其中 `events[i] = [startDayi, endDayi]` ，表示会议 `i` 开始于 `startDayi` ，结束于 `endDayi` 。

你可以在满足 `startDayi <= d <= endDayi` 中的任意一天 `d` 参加会议 `i` 。注意，一天只能参加一个会议。

请你返回你可以参加的 **最大** 会议数目。

```
输入：events= [[1,2],[2,3],[3,4],[1,2]]
输出：4
```

注意：只要d小于等于endday即可，比如第一天第一个会议 第二天第四个会议 第三天第三个会议 第四天第四个会议

------------------------

```java
public int maxEvents(int[][] events) {
  Arrays.sort(events, new Comparator<int[]>() {
         @Override
         public int compare(int[] o1, int[] o2) {
             return o1[0]-o2[0];
         }
     });
     PriorityQueue<Integer>queue =new PriorityQueue<>();
     int curIndex = 0;
     int ans = 0;
        int curDay = events[0][0];
        //curIndex是遍历数组中的元素，此时数组是按开始时间从小到大排序的
        while(curIndex < events.length || !queue.isEmpty()){
            //这里必须有curindex++的while循环，因为可能有两个一样的beginDay 比如两个[1,2]
            while(curIndex< events.length &&events[curIndex][0]==curDay){
                //注意这里是以结束时间为准，因为能否开一个会议应该是以结束时间为标准的，即便开始时间很早，但是结束时间很晚的话，也是可以开这个会议的
                queue.offer(events[curIndex][1]);
                curIndex++;

            }
            //要对队列中的元素进行判断，因为刚刚curday加了一
            while(!queue.isEmpty() && queue.peek() < curDay)
                queue.poll();
            
            if(!queue.isEmpty()){
                //因为一天只能一个会议，用if 如果此时队列非空，这些元素是结束时间大于等于当前时间的，弹出结束时间最小即最早的会议
                queue.poll();
                ans ++;
            }
            curDay++;
        }
        return ans;
    }
```

## [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

难度中等298

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

 

**示例 1:**

```
输入: n = 10
输出: 9
```

**示例 2:**

```
输入: n = 1234
输出: 1234
```

**示例 3:**

```
输入: n = 332
输出: 299
```

--------------------



```java
 public int monotoneIncreasingDigits(int n) {
        char[]chaArray = Integer.toString(n).toCharArray();
        int i = 1;
        for (i = 1; i < chaArray.length; i++) {
            if(chaArray[i]<chaArray[i-1]) break;
        }
        if(i != chaArray.length){
            //如果前一个数字大于后一个数字，前一个数字减一，注意这样减了以后的数字一定比原先的数字小，比如855，第一个数字减一变成755，这里75一定是比855小的，然后再找最大的数即799，就在下一个操作中为后面位数的数字都赋9
            while(i>0&&chaArray[i-1]>chaArray[i]){
                chaArray[i-1]-=1;
                i--;
            }
            for(int j = i+1;j<chaArray.length;j++)
                chaArray[j] = '9';
        }
        return Integer.parseInt(new String(chaArray));
    }
```

## [881. 救生艇](https://leetcode.cn/problems/boats-to-save-people/)

难度中等260

给定数组 `people` 。`people[i]`表示第 `i` 个人的体重 ，**船的数量不限**，每艘船可以承载的最大重量为 `limit`。

每艘船最多可同时载两人，但条件是这些人的重量之和最多为 `limit`。

返回 *承载所有人所需的最小船数* 。

 

**示例 1：**

```
输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)
```

------------------

方法：贪心
要使需要的船数尽可能地少，应当使载两人的船尽可能地多。

设 people 的长度为 n。考虑体重最轻的人：

若他不能与体重最重的人同乘一艘船，那么体重最重的人无法与任何人同乘一艘船，此时应单独分配一艘船给体重最重的人。从 people 中去掉体重最重的人后，我们缩小了问题的规模，变成求解剩余 n−1 个人所需的最小船数，将其加一即为原问题的答案。
若他能与体重最重的人同乘一艘船，那么他能与其余任何人同乘一艘船，为了尽可能地利用船的承载重量，选择与体重最重的人同乘一艘船是最优的。从 people 中去掉体重最轻和体重最重的人后，我们缩小了问题的规模，变成求解剩余 n−2 个人所需的最小船数，将其加一即为原问题的答案。在代码实现时，我们可以先对 people 排序，然后用两个指针分别指向体重最轻和体重最重的人，按照上述规则来移动指针，并统计答案。

```java
 public int numRescueBoats(int[] people, int limit) {
int ans = 0,min = 0,max = people.length-1;
Arrays.sort(people);
while(min<=max){
if(people[min]+people[max]<=limit){
    //如果最小的和最大的重量可以载，那么就作为一艘船，min索引加一
    min++;
    
}
//如果min+max>limit,说明这个最重的只能单独坐一个船，船数量加一，min不改变，这里不管是否能载，船数量都要加一，但是含义不一样，能载的情况下船载了两个人，不能载两个人的情况下船只载了一个人
max--;
ans++;
}
return ans;
    }
```

## 逆向思维 坏的了计数器

在显示着数字 startValue 的坏计算器上，我们可以执行以下两种操作：

双倍（Double）：将显示屏上的数字乘 2；
递减（Decrement）：将显示屏上的数字减 1 。
给定两个整数 startValue 和 target 。返回显示数字 target 所需的最小操作数。

 

示例 1：

输入：startValue = 2, target = 3
输出：2
解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.

------------------------





![image-20230118173445921](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230118173445921.png)



```java
public int brokenCalc(int X, int Y) {
        int ans = 0;
        while (Y > X) {
            ans++;
            if (Y % 2 == 1)
                Y++;
            else
                Y /= 2;
        }

        return ans + X - Y;
    }


```

## [870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)

难度中等359

给定两个大小相等的数组 `nums1` 和 `nums2`，`nums1` 相对于 `nums2` 的*优势*可以用满足 `nums1[i] > nums2[i]` 的索引 `i` 的数目来描述。

返回 nums1 的**任意**排列，使其相对于 `nums2` 的优势最大化。

 

**示例 1：**

```
输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]
输出：[2,11,7,15]
```

**示例 2：**

```
输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]
输出：[24,32,8,12]
```

-----

![image-20230204172946036](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230204172946036.png)

代码实现时，由于 nums 2不能排序，我们可以创建一个下标数组 
ids，对ids 排序，即 ids[0] 对应 nums 2中最小值的下标，


```java
public int[] advantageCount(int[] nums1, int[] nums2) {
    //这样设计就是为了可以知道nums2的原始索引是哪一个
Integer[]index1=new Integer[nums1.length];
Integer[]index2=new Integer[nums2.length];
for(int i=0;i<nums2.length;i++)
{
    index1[i]=i;
    index2[i]=i;
}
int left=0,right=nums2.length-1;
int[]ans=new int[nums1.length];
Arrays.sort(index1,(o1,o2)->nums1[o1]-nums1[o2]);
Arrays.sort(index2,(o1,o2)->nums2[o1]-nums2[o2]);
for(int i = 0;i<nums1.length;i++){
if(nums1[index1[i]]>nums2[index2[left]])
{
   
    ans[index2[left]]=nums1[index1[i]];
     left++;
}
else{
    //反正nums1中这个最小的元素比nums2中任何一个元素都小，干脆配对一个nums2中最大的元素，这样ums1中剩下的元素有最大的可能比nums2中的元素大
    ans[index2[right]]=nums1[index1[i]];
    right--;
}
}
return ans;
    }
```





## 754 到目标值的最小移动次数

在一根无限长的数轴上，你站在0的位置。终点在target的位置。

你可以做一些数量的移动 numMoves :

每次你可以选择向左或向右移动。
第 i 次移动（从  i == 1 开始，到 i == numMoves ），在选择的方向上走 i 步。
给定整数 target ，返回 到达目标所需的 最小 移动次数(即最小 numMoves ) 。

 

示例 1:

输入: target = 2
输出: 3
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 -1 。
第三次移动，从 -1 到 2 。

------------------

![image-20230114130319473](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230114130319473.png)

![image-20230114130334826](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230114130334826.png)

由于相距 d=s-target<s，根据结论，在 d 为偶数时，一定可以选择某些步，满足这些步长的和为 d/2，将这些步反向，就能恰好到达终点。

代码实现时，我们可以不断循环，累加当前步长 n，当到达（越过）终点且相距偶数时停止。最后一步的步长即为答案。

![image-20230114141136476](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230114141136476.png)

注意为什么是delta/2:因为负数和正数相差了两倍，比如说-1和1相差1的二倍，-2和2相差2的二倍

```java
 public int reachNumber(int target) {
int cur=0,n=0;
target=Math.abs(target);
     //如果当前还没到达targe或者已经走过了targe但是与targe距离为奇数，就继续向前走
while(cur<target||(cur-target)%2==1)
{
 cur+=++n;
}
return n;

    }
```

## 300.最长递增子序列





![image-20230224014835940](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230224014835940.png)

![image-20230224021246298](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230224021246298.png)  

![image-20230224014853559](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230224014853559.png) 

```java
public int lengthOfLIS(int[] nums) {
        int len = 1, n = nums.length;
        if (n == 0) {
            return 0;
        }
        int[] d = new int[n + 1];
        d[len] = nums[0];
        for (int i = 1; i < n; ++i) {
            if (nums[i] > d[len]) {
                d[++len] = nums[i];
            } else {
                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (d[mid] < nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return len;
    }
```



# 子集生成算法

1.增量构造法

第一种思路是一次选出一个元素放到集合中，程序如下：

```java
void print_subset(int n, int* A, int cur) {
for(int i = 0; i < cur; i++) printf("%d ", A[i]); //打印当前集合
printf("\n");
int s = cur ? A[cur-1]+1 : 0; //确定当前元素的最小可能值
for(int i = s; i < n; i++) {
A[cur] = i;
print_subset(n, A, cur+1); //递归构造子集
}
}
```

和前面不同，由于A中的元素个数不确定，每次递归调用都要输出当前集合。另外，递归边界也不需要显式确定——如果无法继续添加元素，自然就不会再递归了。
上面的代码用到了定序的技巧：规定集合A中所有元素的编号从小到大排列，就不会把集合{1, 2}按照{1, 2}和{2, 1}输出两次了。

2.位向量法
第二种思路是构造一个位向量B[i]，而不是直接构造子集A本身，其中B[i]=1，当且仅当i在子集A中。递归实现如下：

```c++
void print_subset(int n,int *b,int cur)
{
    if(cur == n)
    {
        for(int i = 0;i < cur;i++)
        {
            if(b[i]) cout<<i;
            
        }
        cout<<"\n";
        return;
    }
    b[i] = 1;
    print_subset(n,b,cur);//选第cur个元素
    b[i] = 0;
    print_subset(n,b,cur);//不选第cur个元素
    
}
```

必须当“所有元素是否选择”全部确定完毕后才是一个完整的子集，因此仍然像以前那样当if(cur == n)成立时才输出。现在的解答树上有2047个结点，比刚才的方法略多。这个也不难理解：所有部分解（不完整的解）也对应着解答树上的结点。（？什么意思）

提示7-5：在枚举子集的位向量法中，解答树的结点数略多，但在多数情况下仍然够快。
这是一棵n+1层的二叉树（cur的范围从0～n），第0层有1个结点，第1层有2个结点，第2层有4个结点，第3层有8个结点，……，第i层有2i个结点，总数为1+2+4+8+…+2n=2n+1-1，和实验结果一致。

如图7-2所示为这棵解答树

![image-20210730124111310](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210730124111310.png)

另外，还可以用二进制来表示{0, 1, 2,…,n-1}的子集S：从右往左第i位（各位从0开始编号）表示元素i是否在集合S中。图7-3展示了二进制0100011000110111是如何表示集合{0, 1,2, 4, 5, 9, 10, 14}的。

![image-20210730124340583](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210730124340583.png)

注意：为了处理方便，最右边的位总是对应元素0，而不是元素1。

此时仅表示出集合是不够的，还需要对集合进行操作。幸运的是，常见的集合运算都可以用位运算符简单实现。最常见的二元位运算是与（&）、或（|）、非（!），它们和对应的逻辑运算非常相似

![image-20210730133721425](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210730133721425.png)

不难看出，A&B、A|B和A^B分别对应集合的交、并和对称差。另外，空集为0，全集{0,1, 2,…, n-1}的二进制为n个1，即十进制的2n-1。为了方便，往往在程序中把全集定义为ALL_BITS= (1<<n)-1，则A的补集就是ALL_BITS^A。当然，直接用整数减法ALL_BITS -A也
可以，但速度比位运算“^”慢



下面的程序输出子集S对应的各个元素：

```c++
void print_subset(int n, int s) { //打印{0, 1, 2,..., n-1}的子集S
for(int i = 0; i < n; i++)
if(s&(1<<i)) printf("%d ", i); //这里利用了C语言"非0值都为真"的规定
printf("\n");
}
int main()
{
	int nn = 4;
for(int i = 0;i < (1 << nn);i++)
print_subset(nn,i);
}

```

![image-20210730144126383](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210730144126383.png)









# hash编码

使用哈希（hash）技术。简单地说，就是要把结点“变成”整数，但不必是一一对应。换句话说，只需要设计一个所谓的哈希函数h(x)，然后将任意结点x映射到某个给定范围[ 0 , M-1]的整数即可，其中M是程序员根据可用内存大小自选的。在理想情况下，只需开一个大小为M的数组就能完成判重，但此时往往会有不同结点的哈希值相同，因此需要把哈希值相同的状态组织成链表，细节参见下面的代码：

```c
const int hashsize = 1000003;
int head[hashsize],next[maxstate];
void init_lookup_table(){
    memset(head,0,sizof(head));
}
int hash(State& s)
{
    int v = 0;
    for(int i = 0;i < 9;i++)
        v= v*10+s[i];//把9个数字组合成9位数
    return v%hashsize;//确保hash函数值是不超过hash表的大小的非负整数
}
int try_to_insert(int s)
{
    int h = hash(st[s]);
    int u = head[h];
    while(u)
    {
        if(memcmp(st[u],st[s],sizeof(s)) == 0)//找到了一样的，插入失败
            u = next[u];
    }
    next[s] = head[h];
    head[h] = s;//插入操作
    ret
}
```



# 高效求素数个数

```java
int countPrimes(int n) {
boolean[] isPrim = new boolean[n];
    Arrays.fill(isPrime,true);
    for(int i = 2;i * i < n;i++)
        if(isPrim[i])
        {
            for(int j = i*i;j < n;j += i)
                isPrime[j] = false;//i的倍数一定不是
        }
    int count = 0;
    for(int i = 2;i < n;i++)
        if(isPrim[i]) count++;
    return count;//n以内的素数个数
}
```

未优化时：

for (int i = 2; i < n; i++)
if (isPrim[i])
// i 的倍数不可能是素数了
for (int j = 2 * i; j < n; j += i)
isPrim[j] = false;

i 不需要遍历到 n ，⽽只需要到 sqrt(n) 即可。为什么呢，
我们举个例⼦，假设 n = 12 。
12 = 2 × 6
12 = 3 × 4
12 = sqrt(12) × sqrt(12)
12 = 4 × 3
12 = 6 × 2，换句话说，如果在 [2,sqrt(n)] 这个区间之内没有发现可整除因⼦，就可以直接断定 n 是素数了，因为在区间 [sqrt(n),n] 也⼀定不会发现可整
除因⼦。

首先优化i*i<n,其次 ⽐如 n = 25 ， i = 4 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 i = 2 和 i = 3 的 2 × 4 和 3 × 4 标记了。因此j从i的平方开始

# 阿拉伯数字转中文

比如19 变成十九 1001变成一千零一

```java
public static String num2cn (int n) {
    // write code here
    boolean negative = false;
    if(n==0){
        return "零";
    }
    //变负为正
    if(n<0){
        n=Math.abs(n);
        negative=true;
    }
    StringBuilder stringBuilder = new StringBuilder();
    //整数转字符串
    String res = String.valueOf(n);
    String[] splits = res.split("");
    int length = splits.length;
    //构建单位集合，注意重量级的单位要倒过来写
    HashMap<Integer,String> unitMap = new HashMap<>();
    //因为后面会将字符串翻转，所以这里的是反的，比如百万这里是万百
    unitMap.put(1,"十");
    unitMap.put(2,"百");
    unitMap.put(3,"千");
    unitMap.put(4,"万");
    unitMap.put(5,"万十");
    unitMap.put(6,"万百");
    unitMap.put(7,"万千");
    unitMap.put(8,"亿");
    unitMap.put(9,"亿十");
    //构建数字集合
    HashMap<String,String> numberMap = new HashMap<>();
    numberMap.put("0","零");
    numberMap.put("1","一");
    numberMap.put("2","二");
    numberMap.put("3","三");
    numberMap.put("4","四");
    numberMap.put("5","五");
    numberMap.put("6","六");
    numberMap.put("7","七");
    numberMap.put("8","八");
    numberMap.put("9","九");
    //将阿拉伯数字转为中文
    for (int i = length - 1; i >= 0; i--) {
        String temp = splits[i];
        if(!temp.equals("0")){
            stringBuilder.append(unitMap.getOrDefault(length-i-1,""));

            stringBuilder.append(numberMap.get(temp));
        } else {
            stringBuilder.append("零");
        }
    }
    //去除最左边连续的零
    while (stringBuilder.charAt(0)=='零'){
        stringBuilder.deleteCharAt(0);
    }
    //去除中间部分连续的零，只保留一个零
    for (int i = stringBuilder.length()-1; i >=0; i--) {
        //比如100002
        if(stringBuilder.charAt(i)=='零'&&stringBuilder.charAt(i+1)=='零'){
            stringBuilder.deleteCharAt(i);
        }
    }
    //去掉最前面的一十中的一
    if(stringBuilder.charAt(stringBuilder.length()-1)=='一'&&
            stringBuilder.charAt(stringBuilder.length()-2)=='十'){
        //如果不进行这个处理，19会变成一十九，多了一个一
        stringBuilder.deleteCharAt(stringBuilder.length()-1);
    }
    //如果是负数还要添加负字
    if(negative){
        stringBuilder.append("负");
    }
    StringBuilder reverseStringBuilder = stringBuilder.reverse();
    //因为亿字有重复，所以要去掉多余的亿，只留一个亿字
    int index = 0;
    for (int i = 0; i < reverseStringBuilder.length(); i++) {
        if(reverseStringBuilder.charAt(i)=='亿'){
            index++;
        }
    }
    while (index>1){
        for (int i = 0; i < reverseStringBuilder.length(); i++) {
            if(reverseStringBuilder.charAt(i)=='亿'){
                reverseStringBuilder.deleteCharAt(i);
                break;
            }
        }
        index--;
    }
    //因为万字有多余，所以要去掉多余的万字，只留一个万字
    index = 0;
    for (int i = 0; i < reverseStringBuilder.length(); i++) {
        if(reverseStringBuilder.charAt(i)=='万'){
            index++;
        }
    }
    while (index>1){
        for (int i = 0; i < reverseStringBuilder.length(); i++) {
            if(reverseStringBuilder.charAt(i)=='万'){
                reverseStringBuilder.deleteCharAt(i);
                break;
            }
        }
        index--;
    }
    return reverseStringBuilder.toString();
}
```

# 阿拉伯数字转英文

![image-20230315235043464](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230315235043464.png) 

------

这里先判断一些可以直接表示的数字，对于其他的数字，进行递归判断，且英语中有百、千、百万、亿

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
            static String[]ones=new String[]{"zero","one","two","three","four","five","six","seven","eight","nine"};
          static  String[] tens = new String[]{"ten","eleven","twelve","thirteen","forteen","fifteen","sixteen","seventeen","eighteen","nineteen"};
     static String[] twieties = new String[]{" "," ","twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety"};
 static int[] range = new int[]{(int)1e2, (int)1e3, (int)1e6, (int)1e9, (int)1e12};
 static String[] ranges = new String[]{"hundred", "thousand", "million", "billion"};
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        int num = sc.nextInt();
            // 转换
            System.out.println(transfer(num));
    }
      public static String transfer(int num){
     if(num <= 9) return ones[num];
        if(num <= 19) return tens[num % 10];
        if(num <= 99) return twieties[num / 10] + (num % 10 == 0 ? "" : " " + ones[num % 10]);
for(int i=0;i<4;i++)
{
    //注意这里是num<range[i+1]的时候才进入判断，也就是最开始是最大的数字判断的，也就是从亿到百万到千
    if(num < range[i+1]){
        //num%range[i]=0表示是100或1000或者1000000等的整数，如果是百分位为0，那么不加and ，千分位等为0 需要加and
        return transfer(num/range[i])+" "+ranges[i]+(num%range[i]==0?" ":(i!=0?" ":" and ")+transfer(num%range[i]));
    }
}
return "";
      }
}
```



# 前缀和+哈希表

当循环到 i 时，往往需要前 i-1项 的和来处理。
多数结合hashmap ，不要重复就hashset。
hashmap.getOrDefault(key,0);
hashmap中有对应key值返回对应value ，否则返回0，0可以随便改，类型符合就ok

## [面试题 17.05.  字母与数字](https://leetcode.cn/problems/find-longest-subarray-lcci/)

难度中等157

给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。

返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。

**示例 1:**

```
输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]

输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]
```

------

```java
    public String[] findLongestSubarray(String[] array) {
    Map<Integer, Integer>index=new HashMap<Integer, Integer>();
        int sum=0;
        int len=0;
        int left=0,right=0;
        index.put(0,-1);//注意这里先要放入0，-1键值对
        for (int i = 0; i < array.length; i++) {
             sum+= Character.isDigit(array[i].charAt(0))?1:-1;
            if(index.size()==0||!index.containsKey(sum))
                index.put(sum,i);
            else if(index.containsKey(sum))
            {
                if(i-index.get(sum)>len){
                    left=index.get(sum)+1;//要加一
                    right=i;
                    len=Math.max(len,i-index.get(sum));
                }
               
            }
        }
        //左闭右开区间 
        return Arrays.copyOfRange(array,left,left+len);
    }
```







## [525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/)

难度中等516

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1:**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组
```

----

![image-20220206163143493](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220206163143493.png)



标prevIndex+1 到下标 i的子数组中有相同数量的 0 和 1，该子数组的长度为 i−prevIndex，使用该子数组的长度更新最长连续子数组的长度；

如果counter 的值在哈希表中不存在，则将当前余数和当前下标 i 的键值对存入哈希表中。

由于哈希表存储的是 counter 的每个取值第一次出现的下标，因此当遇到重复的前缀和时，根据当前下标和哈希表中存储的下标计算得到的子数组长度是以当前下标结尾的子数组中满足有相同数量的 0 和 1 的最长子数组的长度。遍历结束时，即可得到 nums 中的有相同数量的 0 和 1 的最长子数组的长度。

这道题最关键的就是在遍历到当前1的数量时候，如何知道从哪个索引开始到当前位置出现了同样数量的0，需要进行转化

```java
   class Solution {
    public int findMaxLength(int[] nums) {

for(int i=0;i<nums.length;i++)
if(nums[i]==0) nums[i]=-1;
int pre=0;
Map<Integer,Integer>map=new HashMap<>();
int len=0;
map.put(0,-1);
for(int i=0;i<nums.length;i++)
{
    pre+=nums[i];
    if(map.containsKey(pre))
len=Math.max(len,i-map.get(pre));
else
map.put(pre,i);
}
return len;
    }
```



## [560. 和为 K 的子数组个数](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

难度中等1306

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回该数组中和为 `k` 的连续子数组的个数。

 

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

---

![image-20220213213932827](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220213213932827.png)

```java
 int tot = 0;
    public int subarraySum(int[] nums, int k) {
        int index,sum;
        HashMap<Integer,Integer>map = new HashMap<>();
        int pre=0,count=0;
         map.put(0, 1);//   可以认为前缀和为 0，个数为 1 个
        for(int i = 0;i < nums.length;i++)
        {
          pre +=nums[i];
          if(map.get(pre-k) != null)
          {
count+=map.get(pre-k);
          }
          map.put(pre,map.getOrDefault(pre,0)+1);
        }
//dfs(nums,i,0,k);

return count;
    }
```

## 209.和大于k的最短子数组

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0



这个题可以采用前缀和，也可以用二分查找：

```java
  public int minSubArrayLen(int s, int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int ans = Integer.MAX_VALUE;
        int[] sums = new int[n + 1]; 
        // 为了方便计算，令 size = n + 1 
        // sums[0] = 0 意味着前 0 个元素的前缀和为 0
        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]
        // 以此类推
        for (int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
        for (int i = 1; i <= n; i++) {
            int target = s + sums[i - 1];
            int bound = Arrays.binarySearch(sums, target);
            if (bound < 0) {
                bound = -bound - 1;
            }
            if (bound <= n) {
                ans = Math.min(ans, bound - (i - 1));
            }
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }


```



## [523. 和为k的n次方的子数组](https://leetcode-cn.com/problems/continuous-subarray-sum/)

难度中等

给你一个整数数组 `nums` 和一个整数 `k` ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

- 子数组大小 **至少为 2** ，且
- 子数组元素总和为 `k` 的倍数。

如果存在，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `n` ，令整数 `x` 符合 `x = n * k` ，则称 `x` 是 `k` 的一个倍数。`0` 始终视为 `k` 的一个倍数。

---------

```java
    public boolean checkSubarraySum(int[] nums, int k) {
           if(nums.length<2) return false;
      HashMap<Integer,Integer>map = new HashMap<>();
        int pre=0,count=0;
        //pre[i] - pre[j-1] = k*n pre[i] pre[j-1]除以k的余数相同 这道题中哈希表中值存放的是下标，上一道题是个数
         map.put(0, -1);//  尤其注意这道题中这个点很容易被忽略，初始要放入（0，-1）键值对,否则得不到正确结果
        for(int i = 0;i < nums.length;i++)
        {
pre =(pre+ nums[i])%k;
if(map.get(pre)!= null)//如果这个数已经存在
{
    int number = map.get(pre);
    if(i- number>=2) return true;
 //哈希表中的值是下标
}
else
map.put(pre,i);
        }
        return false;
    }
```



![image-20220213214723885](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220213214723885.png)

## [和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

难度中等374

给定一个整数数组 `nums` 和一个整数 `k` ，返回其中元素之和可被 `k` 整除的（连续、非空） **子数组** 的数目。

**子数组** 是数组的 **连续** 部分。

 

**示例 1：**

```
输入：nums = [4,5,0,-2,-3,1], k = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 k = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```



-----

![image-20220803213506677](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220803213506677.png)

```java
   public int subarraysDivByK(int[] nums, int k) {
        //因此我们可以考虑对数组进行遍历，在遍历同时统计答案。当我们遍历到第 i 个元素时，我们统计以 i 结尾的符合条件的子数组个数。我们可以维护一个以前缀和模 k 的值为键，出现次数为值的哈希表 record，在遍历的同时进行更新。这样在计算以 ii 结尾的符合条件的子数组个数时，根据上面的分析，答案即为 [0..i-1]中前缀和模 k 也为 P[i] mod k 的位置个数，即record[P[i]modk]。

int ans = 0,left=0,right=0,total = 0;
Map<Integer,Integer>map = new HashMap<>();
map.put(0,1);
for(int i = 0;i<nums.length;i++){
    total+=nums[i];
// 注意 Java 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正,这里试了一下，如果total都是正数，则用total%k也可以得出正确结果，否则要用下面的写法
  int modans = (total %k+k)%k;
  int same = map.getOrDefault(modans,0);
  ans +=same;
  map.put(modans,same+1);
  }
 
return ans;
}
```

## [1031. 两个非重叠子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/)

难度中等140

给出非负整数数组 `A` ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 `L` 和 `M`。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。）

从形式上看，返回最大的 `V`，而 `V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1])` 并满足下列条件之一：

 

- `0 <= i < i + L - 1 < j < j + M - 1 < A.length`, **或**
- `0 <= j < j + M - 1 < i < i + L - 1 < A.length`.

 

**示例 1：**

```
输入：A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
输出：20
解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。
```

**示例 2：**

输入：A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2
输出：29
解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。

-------

考虑题意: 必然存在一条分界线把 A 拆分成两半，存在两大类情况：
长度为 L 的连续子数组在左边, 长度为 M 的连续子数组在右边
或者反过来长度为 M 的连续子数组在左边, 长度为 L 的连续子数组在右边
引入

```
dp[i][0]: 从 A[0]到A[i] 连续 L 长度子数组最大的元素和
dp[i][1]: 从 A[0]到A[i] 连续 M 长度子数组最大的元素和
dp[i][2]: 从 A[i]到A[A.size()-1] 连续 L 长度子数组最大的元素和
dp[i][3]: 从 A[i]到A[A.size()-1] 连续 M 长度子数组最大的元素和
```

```java
 public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {
int[][]dp = new int[nums.length][4];
int prenum = 0;
for(int i = 0;i < firstLen;i++){
    prenum+=nums[i];
        }
int maxnum = prenum;
dp[firstLen-1][0]=maxnum;
for(int i = firstLen;i < nums.length;i++){
    prenum -=nums[i-firstLen];
    prenum+=nums[i];
    maxnum = Math.max(maxnum,prenum);
    dp[i][0] = maxnum;
}
prenum = 0;
for(int i = 0;i < secondLen;i++){
    prenum+=nums[i];
}
maxnum = prenum;
dp[secondLen-1][1] = maxnum;
for(int i = secondLen;i<nums.length;i++){
    prenum -=nums[i-secondLen];
    prenum+=nums[i];
    dp[i][1] = Math.max(prenum,maxnum);
}
        prenum = 0;
        for (int i =nums.length - 1; i >= nums.length -firstLen; --i)
        {
            prenum += nums[i];
        }

        dp[nums.length - firstLen][2] = prenum;
        maxnum = prenum;
        for (int i =nums.length - firstLen- 1; i >= 0; --i)
        {
            prenum -= nums[i + firstLen];
            prenum += nums[i];
            maxnum = Math.max(maxnum, prenum);
            dp[i][2] = maxnum;
        }
        prenum = 0;
        for(int i = nums.length -1;i>=nums.length-secondLen;i--){
            prenum+=nums[i];
        }
        dp[nums.length-secondLen][3]=prenum;
maxnum = prenum;
        for(int i = nums.length-secondLen-1;i>=0;i--)
        {
            prenum-=nums[i+secondLen];
            prenum+=nums[i];
            maxnum =  Math.max(maxnum,prenum);
            dp[i][3] = maxnum;
        }
        //计算答案
        int res = 0;
        //L在M左边
        for (int i =firstLen; i <= nums.length - secondLen; ++i)
            res = Math.max(res, dp[i - 1][0] + dp[i][3]);
        //M在L左边
        for (int i = secondLen; i <= nums.length - firstLen; ++i)
            res = Math.max(res, dp[i - 1][1] + dp[i][2]);

        return res;
    }
```

## [848. 字母移位](https://leetcode.cn/problems/shifting-letters/)

难度中等65

有一个由小写字母组成的字符串 `s`，和一个长度相同的整数数组 `shifts`。

我们将字母表中的下一个字母称为原字母的 *移位* `shift()` （由于字母表是环绕的， `'z'` 将会变成 `'a'`）。

- 例如，`shift('a') = 'b', ``shift('t') = 'u'`, 以及 `shift('z') = 'a'`。

对于每个 `shifts[i] = x` ， 我们会将 `s` 中的前 `i + 1` 个字母移位 `x` 次。

返回 *将所有这些移位都应用到 `s` 后最终得到的字符串* 。

 

**示例 1：**

```
输入：s = "abc", shifts = [3,5,9]
输出："rpl"
解释： 
我们以 "abc" 开始。
将 S 中的第 1 个字母移位 3 次后，我们得到 "dbc"。
再将 S 中的前 2 个字母移位 5 次后，我们得到 "igc"。
最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 "rpl"。
```

----------------------



```java
 public String shiftingLetters(String s, int[] shifts) {
char[]arr = s.toCharArray();
//这里必须用long,不然会溢出导致结果错误
long[]tot = new long[shifts.length];
tot[shifts.length-1]=shifts[shifts.length-1];
for(int i = shifts.length-2;i>=0;i--){
    //倒序前缀和
    tot[i]=tot[i+1]+shifts[i];
}
for(int i = 0;i < tot.length;i++){
     int temp=arr[i]-'a';
     //这里记得要模26，因为z加一变成a
            int c=(int) ((tot[i]+temp)%26);
            arr[i]=(char)('a'+c);

}
return new String(arr);
    }
```

## [1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

难度中等433

这里有 `n` 个航班，它们分别从 `1` 到 `n` 进行编号。

有一份航班预订表 `bookings` ，表中第 `i` 条预订记录 `bookings[i] = [firsti, lasti, seatsi]` 意味着在从 `firsti` 到 `lasti` （**包含** `firsti` 和 `lasti` ）的 **每个航班** 上预订了 `seatsi` 个座位。

请你返回一个长度为 `n` 的数组 `answer`，里面的元素是每个航班预定的座位总数。

 

**示例 1：**

```
输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]
```



---------------------



注意到一个预订记录实际上代表了一个区间的增量。我们的任务是将这些增量叠加得到答案。因此，我们可以使用差分解决本题。

![image-20230117114506955](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230117114506955.png)



在本题中，我们可以遍历给定的预定记录数组，每次 O(1) 地完成对差分数组的修改即可。当我们完成了差分数组的修改，只需要最后求出差分数组的前缀和即可得到目标数组。

注意本题中日期从 1 开始，因此我们需要相应的调整数组下标对应关系，对于预定记录 
booking=[l,r,inc]，我们需要让 d[l−1] 增加 inc
d[r] 减少 inc,特别地，当 r 为 n 时，我们无需修改 d[r]，因为这个位置溢出了下标范围。如果求前缀和时考虑该位置，那么该位置对应的前缀和值必定为 0读者们可以自行思考原因，以加深对差分数组的理解

## 二维拆分：子矩阵元素加一

给你一个正整数 n ，表示最初有一个 n x n 、下标从 0 开始的整数矩阵 mat ，矩阵中填满了 0 。

另给你一个二维整数数组 query 。针对每个查询 query[i] = [row1i, col1i, row2i, col2i] ，请你执行下述操作：

找出 左上角 为 (row1i, col1i) 且 右下角 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1 。也就是给所有满足 row1i <= x <= row2i 和 col1i <= y <= col2i 的 mat\[x][y] 加 1 。
返回执行完所有操作后得到的矩阵 mat 。

 

示例 1：

![image-20230119161517402](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230119161517402.png)

输入：n = 3, queries = [[1,1,2,2],[0,0,1,1]]
输出：[[1,1,0],[1,2,1],[0,1,1]]
解释：上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵、执行完第二个操作后的矩阵。
- 第一个操作：将左上角为 (1, 1) 且右下角为 (2, 2) 的子矩阵中的每个元素加 1 。 
- 第二个操作：将左上角为 (0, 0) 且右下角为 (1, 1) 的子矩阵中的每个元素加 1 。 

------------------------------



按照这种来求前缀和即可：

![image-20230119161612354](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230119161612354.png)

遍历的时候要加上前面的行得到结果，再加上前面的列得到结果

```java
 public int[][] rangeAddQueries(int n, int[][] queries) {
int[][]ans=new int[n][n];
int[][]operate=new int[n+1][n+1];
for(int[]query:queries){
    operate[query[0]][query[1]]++;
    operate[query[2]+1][query[3]+1]++;
    operate[query[2]+1][query[1]]--;
    operate[query[0]][query[3]+1]--;
}
for(int i = 1;i<n;i++)
for(int j=0;j<n;j++)//固定列
operate[i][j]+=operate[i-1][j];
for(int i = 0;i<n;i++)
for(int j=1;j<n;j++)//
operate[i][j]+=operate[i][j-1];
for(int i = 0;i<n;i++)
for(int j=0;j<n;j++)
ans[i][j]=operate[i][j];
return ans;
    }
```

## 二维前缀和：二维子矩阵的和

给定一个二维矩阵 matrix，以下类型的多个请求：

计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。
实现 NumMatrix 类：

NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化
int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。

-------



![image-20230212232040466](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230212232040466.png)

![image-20230212233005958](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230212233005958.png) 

```java

int[][]presum;
    public NumMatrix(int[][] matrix) {

presum=new int[matrix.length+1][matrix[0].length+1];
 for(int j=0;j<matrix[0].length;j++)
for(int i=0;i<matrix.length;i++)
{
   
    presum[i+1][j+1]=presum[i][j+1]+matrix[i][j]+presum[i+1][j]-presum[i][j];
}
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        int sum=presum[row2+1][col2+1]+presum[row1][col1]-presum[row1][col2+1]-presum[row2+1][col1];
return sum;
    }
```





## [1124. 表现良好的最长时间段](https://leetcode.cn/problems/longest-well-performing-interval/)

难度中等247

给你一份工作时间表 `hours`，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于 `8` 小时的时候，那么这一天就是「**劳累的一天**」。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 **大于**「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

 

**示例 1：**

```
输入：hours = [9,9,6,0,6,6,9]
输出：3
解释：最长的表现良好时间段是 [9,9,6]。
```

**示例 2：**

```
输入：hours = [6,6,6]
输出：0
```





-------

,遍历 stk = [0 ,5, 6], 拿到一个i, 再从右向左遍历prefixSum = [0, 1, 2, 1, 0, -1, -2, -1] ,拿到一个j, 检查每一对(i, j)

```java
    public int longestWPI(int[] hours) {
int tired=0,relax=0;
int left=0,right=0;
int maxDay=0;
//我们的目标：找到一个最大的(i,j)使得prefixSum[j] - prefixSum[i] > 0.
 int len = hours.length;
        int[] hours2 = new int[len];
        for (int i = 0; i < len; i++) {
            if (hours[i] > 8) {
                hours2[i] = 1;
            } else {
                hours2[i] = -1;
            }
        }
        int[] presum = new int[len + 1];
        for (int i = 1; i < len + 1; i++) {
            presum[i] = presum[i - 1] + hours2[i - 1]; 
        }
Deque<Integer>deque=new LinkedList<>();
for(int i=0;i<presum.length;i++)
{
    //presum的第一个元素是0
    if(deque.isEmpty()) deque.push(i);
    //找到一个单调递减的子序列 deque里面存的都是元素一定小于0的索引
if(!deque.isEmpty()&&presum[i]<presum[deque.peek()]) deque.push(i);
}
//注意这里终止条件i>=maxday，因为如果i=maxday,最大的结果也是maxday,这样终止条件可以提高效率
    for(int i=presum.length-1;i>=maxDay;i--)
{
    //从后往前遍历，因为如果pre[3]-pre[0]>0 [0,3]是一定符合的，但是不确定[0,4]是否符合，而如果[0,4]符合条件，则[0,3]一定不符合，因为题目要求最长的
    //对于每一个deque.peek()来说，最大的i就是最好的结果了，所以i从大到小遍历
  while(!deque.isEmpty()&&presum[i]>presum[deque.peek()]){
      //对于一个全部都大于8的原数组，则从最大一个开始，减去deque中的元素0，就是结果了
        maxDay=Math.max(maxDay,i-deque.peek());
        deque.pop();
    }
}
return maxDay;
    }
```

## [862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)

难度困难641

给你一个整数数组 `nums` 和一个整数 `k` ，找出 `nums` 中和至少为 `k` 的 **最短非空子数组** ，并返回该子数组的长度。如果不存在这样的 **子数组** ，返回 `-1` 。

**子数组** 是数组中 **连续** 的一部分。

 



**示例 1：**

```
输入：nums = [1], k = 1
输出：1
```

**示例 2：**

```
输入：nums = [1,2], k = 4
输出：-1
```



-------------------

首先因为数组中出现了正负数，用滑动窗口不行，这里先考虑前缀和，两个前缀和之差>=k时，就已经找到了一个子数组

然后考虑用一个队列存放下标

![image-20230204154750283](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230204154750283.png)

```java
 public int shortestSubarray(int[] nums, int k) {
        //用long数组，防止溢出
long[]presum=new long[nums.length+1];
for(int i=0;i<nums.length;i++)
presum[i+1]=presum[i]+nums[i];
Deque<Integer>queue=new LinkedList<>();
int ans=Integer.MAX_VALUE;
for(int i = 0;i<=nums.length;i++){
    //sum是当前的前缀和
    long sum=presum[i];
    while(!queue.isEmpty()&&sum-presum[queue.peekFirst()]>=k)
{
    ans=Math.min(ans,i-queue.pollFirst());
    if(ans==1) return 1;
}
//当一个前缀和 preSumArr[j] 试减完 q 中的元素时，需要将它也放入 q 中。将它放入 q 前， q 中可能存在比 preSumArr[j] 大的元素，而这些元素和preSumArr[j] 一样，只能作为再后续访问到的某个前缀和preSumArr[h] 的减数。而作为减数时，更大的值只会让不等式 preSumArr[h]−preSumArr[i]≥k 更难满足。即使都满足，后访问到的值也可以带来更短的长度。 因此，在把 preSumArr[j] 放入q 时，需要将 q 中大于等于 preSumArr[j] 的值也都移除。
while(!queue.isEmpty()&&presum[queue.peekLast()]>=sum)
queue.pollLast();
queue.offerLast(i);
}
return ans==Integer.MAX_VALUE?-1:ans;
    }
```

## 和为k的所有子数组

给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。

 

示例 1：

输入:nums = [1,1,1], k = 2
输出: 2
解释: 此题 [1,1] 与 [1,1] 为两种不同的情况

------------------------------



![image-20230212183859271](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230212183859271.png)


的下标范围是 0≤j≤i 。同时，由于pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1] 的答案即可。

```java
 public int subarraySum(int[] nums, int k) {
int left=0,right=0,sum=0;
int ans=0;
int pre=0;
Map<Integer,Integer>map=new HashMap<>();
map.put(0,1);
//当前的元素加起来的和为pre,之前的某个元素前缀和为number,如果pre-number为k,那么此时找到了一个子数组，所以只需要找到目前有多少个前缀和为number的，就是有多少个子数组，也就是以j为末尾的，查找j之前的i,从i到j和为k,一共有多少个这样的i
for(int i=0;i<nums.length;i++)
{
pre+=nums[i];
if(map.containsKey(pre-k))
ans+=map.get(pre-k);
map.put(pre,map.getOrDefault(pre,0)+1);
}
return ans;
    }
```

## [剑指 Offer II 050. 路径和为给定值的数目](https://leetcode.cn/problems/6eUYwP/)

难度中等73

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 ![image-20230218222938611](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230218222938611.png) 

--------

最直观的：遍历每一个节点作为父节点，向下寻找是否有一条路径和为给定值

这样会有很多重复遍历，所以用前缀和的方法进行优化

```java
 Map<Long,Integer>map=new HashMap<>();
    public int pathSum(TreeNode root, int targetSum) {
        map.put(0L,1);
return dfs(root,targetSum,0);
    }
    public int dfs(TreeNode root,int targetSum,long cur)
    {
        int ret=0;
if(root==null) return 0;
cur+=root.val;
//当前的所有路径之和加起来减去之前的某个前缀和=target的话，那么就存在一条路径
ret=map.getOrDefault(cur-targetSum,0);
//前缀和数量加一，代表存在和为cur的一条路径
map.put(cur,map.getOrDefault(cur,0)+1);
ret+=dfs(root.left,targetSum,cur);
ret+=dfs(root.right,targetSum,cur);
//尤其注意这里dfs完了以后要再回溯，数量要减一
map.put(cur,map.getOrDefault(cur,0)-1);
return ret;
    }
```

用普通方法写法如下：

```java
    int targetSum;
     public int pathSum(TreeNode root, int targetSum) {
         this.targetSum=targetSum;
        if (root == null) {
            return 0;
        }

        int ret = rootSum(root, 0);
        ret += pathSum(root.left, targetSum);
        ret += pathSum(root.right, targetSum);
        return ret;
    }
//用long防止移除，因为涉及到所有值的和，可能会溢出
    public int rootSum(TreeNode root, long cur) {
        int ret = 0;

        if (root == null) {
            return 0;
        }
        int val = root.val;
        if (val+cur == targetSum) {
            ret++;
        } 

        ret += rootSum(root.left, val+cur);
        ret += rootSum(root.right, val+cur);
        return ret;
    }

```

## 1590.使数组减去最小子数组后能被p整除

给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。

请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。

子数组 定义为原数组中连续的一组元素。

 

示例 1：

输入：nums = [3,1,4,2], p = 6
输出：1
解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。
示例 2：

--------



![image-20230311005246063](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230311005246063.png)

```java
    public int minSubarray(int[] nums, int p) {
  int n = nums.length, ans = n;
        var s = new int[n + 1];
        for (int i = 0; i < n; ++i)
            s[i + 1] = (s[i] + nums[i]) % p;
        int x = s[n];
        if (x == 0) return 0; // 移除空子数组（这行可以不要）

        var last = new HashMap<Integer, Integer>();
        for (int i = 0; i <= n; ++i) {
            last.put(s[i], i);
            // 如果不存在，-n 可以保证 i-j >= n
            int j = last.getOrDefault((s[i]-x+p) % p, -n);
            ans = Math.min(ans, i - j);
        }
        return ans < n ? ans : -1;


    
    }
```





# 二叉树

## 非递归前序遍历

思路：

用栈，第一次弹出时就打印，有右子树再push右子树，有左子树再push左子树（push的顺序头右左）

非递归后序遍历刚好反过来，push的顺序是头左右，但是这里不要将弹出的节点打印。而是放到另一个新栈中

```java
public static void preorder(TreeNode root)
{
    if(root != null)
    {
        Stact<TreeNode>stack = new Stack<>();
        stack.add(root);
        while(root.left != null)//要找到最左边的结点，注意循环条件
        {
            root = stack.pop();
            
            if(root!=null){
                System.out.println(root.val);
            if(root.right!=null)
                stack.add(root.right);
            if(root.left != null)
                stack.add(root.left);//由于是栈。注意先进右树后进左子树，这样才能先出左子树
          }
        }
        
        
        
        
    }
}
```

前序另一个版本：

```java
public static void post(Node node)
{
    
        if(node != null)
        {
            Stack<Node>s1 = new Stack<>();
         
            s1.push(node);
            while(!s1.isEmpty())
            {
node = s1.pop();
              System.out.println(node.val+" ");//弹出立马打印
                     if(node.right != null)
                    s1.push(node.right);
                if(node.left != null)
                    s1.push(node.left);//这里是s1
                
            }
        }
                while(!s2.isEmpty())
                {
                    System.out.println(s2.pop().val+" ");
                }
                     
}
```



后序：(跟上面的非常相似，只是多了一辅助栈和顺序不一样)

```java
public static void post(Node node)
{
    
        if(node != null)
        {
            Stack<Node>s1 = new Stack<>();
              Stack<Node>s2 = new Stack<>();
            s1.push(node);
            while(!s1.isEmpty())
            {
node = s1.pop();
                s2.push(node);//注意这里是s2
                if(node.left != null)
                    s1.push(node.left);//这里是s1
                     if(node.right != null)
                    s1.push(node.right);
            }
        }
                while(!s2.isEmpty())
                {
                    System.out.println(s2.pop()+" ");
                }
                     
}
```



## 非递归中序遍历

非递归的思路如下：
1. 定义一个栈
2. 将树的左节点依次入栈
3. 左节点为空时，弹出栈顶元素并处理
4. 重复 2-3 的操作

```java
if(root != null)
{
         Stact<TreeNode>stack = new Stack<>();
   
    while(root!=null || !stack.isEmpty()){
       
        
       if(root != null)
       {
            stack.push(root);
           root = root.left;
       }
        else
        {
            root = stack.pop();
            System.out.println(root.val);
            root = root.right;
        }
    }
}
```

📣注意：将中序遍历的输出部分改为判断就可以改成判断是否是二叉搜索树：

```java
if(root != null)
{
    int res = Integer.MIN_VALUE;
    Stack<Node>stack = new Stack<>();
    while(root != null || !stack.isEmpty())
    {
        if(root != null)
        {
            stack.push(root);
            root = root.left;
        }
        else
        {
            root = stack.pop();
            if(res > root.data) return false;
            else
            {
                res = root.data;
                root = root.right;
            }
        }
    }
    return true;
}
```



## 非递归的后序遍历

```java
public static void postorder(TreeNode root){
    if(root != null){
        TreeNode prev = null;
          Stack<Node>stack = new Stack<>();
        while(root !=null || !stack.isEmpty())
        {
            while(root != null)
            {
                stack.push(root);
            root = root.left;
            }
            root = stack.pop();
           if(root.right== null|| prev == root.right )
            {
               sout(root.val);
                prev = root;
               root = null;
            }
            else
            {
                stack.push(root);
                root = root.right;
            }
        }
        
    }
    
}
```

## [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

难度中等664

给你二叉搜索树的根节点 `root` ，该树中的 **恰好** 两个节点的值被错误地交换。*请在不改变其结构的情况下，恢复这棵树* 。

 进阶：用空间复杂度o(1)完成

![image-20220307162305735](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220307162305735.png)

---

```java
  public void recoverTree(TreeNode root) {
      
    Deque<TreeNode>queue = new ArrayDeque<>();
    TreeNode x = null,y = null,prev = null;
    while(!queue.isEmpty() || root!=null)
    {
       
      while(root!=null)
        {
         
            queue.push(root);
            root = root.left;

        }
          root = queue.pop();
           if(prev!=null && prev.val > root.val)
        {
            y = root;//注意在这里y会被赋值两次，而x只会赋值一次
            if(x == null)
            x  = prev;
            else break;
        }
               prev = root;
            root = root.right;
      
    }
    int val = y.val;
    y.val = x.val;
    x.val = val;

    }
```





## 中序遍历的后继节点

题目一，普通二叉树寻找后继节点：

![图片](https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVG0bAiaNM3XZ6c4zary9YZlPaiaVX224Cx9Gx17vB8fYCWc1qiaNNfsUSVj1uu0SWP1lRXic55SEOictGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

分情况：

节点(设为x)中序遍历的下一个节点有以下可能：

1. 若x有右子树。则x的下一个节点为x右子树最左侧节点。如，2的下一个节点为8。
2. 若x没有右子树，又分为2种情况。

- 若x是父节点的左孩子。则x的父节点就是x的下一个节点。如，7的下一个节点是4。
- 若x是父节点的右孩子。则沿着父节点向上，直到找到一个节点的父节点的左孩子是该节点，则该节点的父节点就是x的下一个节点。如，9的下一个节点是1。

```java
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
if(root == null||p==null) return null;
boolean flag = false;
Stack<TreeNode> stack = new Stack<>();
TreeNode temp = root;
while (temp!= null || !stack.isEmpty())
{
    
    if(temp!=null)
    {
        stack.push(temp);
        temp = temp.left;
    }
    else {
      
        temp = stack.pop();
          if(flag) return temp;
        if(temp == p)
        {
           flag = true;
        }
          //  if(temp==p && stack.isEmpty()) return null;
      temp = temp.right;
    }
}
return null;
    }
```







题目二：一个特殊的二叉树寻找后继节点

在二叉树中找到一个节点的后继节点  【题目】 现在有一种新的二叉树节点类型如下：     

```java
            public class Node {
              public int value;
              public Node left;
              public Node right;
              public Node parent;
         public Node(int data) {
                 this.value = data;
          }
   }
```
 该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null。只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中，node的下一个节点叫作node的后继节点。 

最优解法不必遍历所有的节点，如果node节点和node后继节点之间的实际距离为L，最优解法只用走过L个节点，时间复杂度为O（L），额外空间复杂度为O（1）。接下来详细说明最优解法是如何找到node的后继节点的。 

情况1：如果node有右子树，那么后继节点就是右子树上最左边的节点。 

情况2：如果node没有右子树，那么先看node是不是node父节点的左孩子，如果是左孩子，那么此时node的父节点就是node的后继节点；如果是右孩子，就向上寻找node的后继节点，假设向上移动到的节点记为s，s的父节点记为p，如果发现s是p的左孩子，那么节点p就是node节点的后继节点，否则就一直向上移动。 

情况3：如果在情况2中一直向上寻找，都移动到空节点时还是没有发现node的后继节点，说明node根本不存在后继节点。

```java
public Node getNext(Node root) {
    if (root == null) return root;
    if (root.right != null) {
        return getMostLeft(root.right);
    } else {
        Node parent = root.parent;
        while (parent!=null && parent.left != root) {
            root = parent;
            parent = root.parent;
        }
        return parent;
    }
}

    private Node getMostLeft(Node right) {
        if(right==null) return right;
        while (right.left!=null)
        {
            right = right.left;
        }
        return right;
    }
```



## 由后序和中序遍历建立二叉树

```java
  public TreeNode buildTree(int[] inorder, int[] postorder) {
Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i],i);
                }
return buildInPost(inorder,0,inorder.length-1,postorder,0,inorder.length-1,map);
    }
    private TreeNode buildInPost(int[] inorder, int inbegin, int inend, int[]postorder,int postbegin, int postend, Map<Integer, Integer> map) {
      if(postbegin > postend) return null;
      TreeNode head = new TreeNode(postorder[postend]);
      int headIndex = map.get(postorder[postend]);//树根在中序遍历中的位置
      head.left = buildInPost(inorder,inbegin,headIndex-1,postorder,postbegin,postbegin+headIndex-inbegin-1,map);
      head.right = buildInPost(inorder,headIndex+1,inend,postorder,postbegin+headIndex-inbegin,postend-1,map);//headIndex-inbegin实际上是左边子树的长度
      return head;
    }
```



## 中序和前序重建二叉树

```java
   private Map<Integer, Integer> indexMap;

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return null;
        }

        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);
        
        // 先把根节点建立出来
        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        // 构造哈希映射，帮助我们快速定位根节点
        indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## [1382. 将二叉搜索树变平衡](https://leetcode.cn/problems/balance-a-binary-search-tree/)

难度中等163

给你一棵二叉搜索树，请你返回一棵 **平衡后** 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。

如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 `1` ，我们就称这棵二叉搜索树是 **平衡的** 。

![image-20230326134202475](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230326134202475.png) 

-----

![image-20230326134314447](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230326134314447.png) 

总的来说，先中序遍历得到一个序列，然后递归地建树

```java
   List<Integer> inorder = new ArrayList<Integer>();

    public TreeNode balanceBST(TreeNode root) {
        getInorder(root);
        return build(0, inorder.size() - 1);
    }

    public void getInorder(TreeNode o) {
        if (o.left != null) {
            getInorder(o.left);
        }
        inorder.add(o.val);
        if (o.right != null) {
            getInorder(o.right);
        }
    }

    public TreeNode build(int l, int r) {
 if(l>r) return null;
 int mid=(l+r)/2;
 TreeNode root=new TreeNode(inorder.get(mid));
 root.left=build(l,mid-1);
 root.right=build(mid+1,r);
 return root;
    }
```



## [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

难度中等182

给定一个二叉搜索树 `root` (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。

提醒一下， *二叉搜索树* 满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

 

![image-20220920215710477](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220920215710477.png)

----------------------



```java
int allnode = 0;
    public TreeNode bstToGst(TreeNode root) {
if(root != null){
    //这里用反序的方法，要先遍历最右边的树，然后再到左边的树，所以递归的时候要先root.right
    bstToGst(root.right);
    allnode+=root.val;
    root.val = allnode;
    bstToGst(root.left);
}
return root;
    }
```





## [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

难度中等268

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 **任何** 一个。

----------------------

前序遍历为：

(根结点) (前序遍历左分支) (前序遍历右分支)
而后序遍历为：

(后序遍历左分支) (后序遍历右分支) (根结点)
例如，如果最终的二叉树可以被序列化的表述为 [1, 2, 3, 4, 5, 6, 7]，那么其前序遍历为 [1] + [2, 4, 5] + [3, 6, 7]，而后序遍历为 [4, 5, 2] + [6, 7, 3] + [1].

如果我们知道左分支有多少个结点，我们就可以对这些数组进行分组，并用递归生成树的每个分支。

我们令左分支有 LL 个节点。我们知道左分支的头节点为 pre[1]，但它也出现在左分支的后序表示的最后。所以 pre[1] = post[L-1]（因为结点的值具有唯一性），因此 L = post.indexOf(pre[1]) + 1。

现在在我们的递归步骤中，左分支由 pre[1 : L+1] 和 post[0 : L] 重新分支，而右分支将由 pre[L+1 : N] 和 post[L : N-1] 重新分支。

```java
public TreeNode constructFromPrePost(int[] preorder, int[] postorder) 
{
        if(preorder.length==0) return null;
TreeNode root =new  TreeNode(preorder[0]);
if(preorder.length==1) return root;
int leftest=0;
for(int i = 0;i < preorder.length;i++){
    if(postorder[i]==preorder[1]){
        leftest = i+1;//左边的根节点
    }
}
//注意这里的copyOfRange方法，是左闭右开，不会取右边的
root.left =  constructFromPrePost(Arrays.copyOfRange(preorder,1,leftest+1),
Arrays.copyOfRange(postorder,0,leftest));
root.right = constructFromPrePost(Arrays.copyOfRange(preorder,leftest+1,preorder.length),Arrays.copyOfRange(postorder,leftest,postorder.length-1));
return root;

    }
```





## （❓未理解）给定一个整数N，请返回可能的二叉树结构有多少

如果N<1，代表空树结构，否则代表中序遍历的结果为{1，2，3，…，N}。请返回可能的二叉树结构有多少。 例如，N=-1时，代表空树结构，返回1；N=2时，满足中序遍历为{1，2}的二叉树结构只有如图3-49所示的两种，所以返回结果为2。

![image-20210924103612131](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210924103612131.png)



【难度】 尉　★★☆☆ 

【解答】 如果中序遍历有序且无重复值，则二叉树必为搜索二叉树。假设num（a）代表a个节点的搜索二叉树有多少种可能，再假设序列为{1，…，i，…，N}，如果以1作为头节点，1不可能有左子树，故以1作为头节点有多少种可能的结构，完全取决于1的右子树有多少种可能结构，1的右子树有N-1个节点，所以有num（N-1）种可能。 如果以i作为头节点，i的左子树有i-1个节点，所以可能的结构有num（i-1）种，右子树有N-i个节点，所以有num（N-i）种可能。故以i为头节点的可能结构有num（i-1）×num（N-i）种。 如果以N作为头节点，N不可能有右子树，故以N作为头节点有多少种可能，完全取决于N的左子树有多少种可能，N的左子树有N-1个节点，所以有num（N-1）种。 把从1到N分别作为头节点时，所有可能的结构加起来就是答案，可以利用动态规划来加速计算的过程，从而做到O（N²）的时间复杂度。 

动态规划：

给定一个有序序列 1 ⋯n，为了构建出一棵二叉搜索树，我们可以遍历每个数字 i，将该数字作为树根，将 1 ⋯(i−1) 序列作为左子树，将 (i+1)⋯n 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树

给定序列 1⋯n，我们选择数字 i作为根，则根为 i 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，

![image-20220221132616122](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220221132616122.png)

![image-20210924122311570](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210924122311570.png)

当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，即：

*G*(0)=1,*G*(1)=1

```java
public int numTrees(int n)
{
    if(n < 2) return 1;
}
int[]nums = new int[n+1];
nums[0] =1;
for(int i = 1;i < n+1;i++)//对于给定序列1~n
    for(int j  = 1;j < i+1;j++)//取1~n的每一个结点都作为根节点，所有的结点作为根节点时的二叉搜索树数量总和即1~i这个序列的二叉搜索树数量
    {
        nums[i] += nums[j-1]*nums[i-j];
    }
return nums[n];
}
```

![image-20210924122400541](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210924122400541.png)



## 递归法判断二叉搜索树的最小节点差值

```java
 int pre;
    int ans;
    public int minDiffInBST(TreeNode root) {
pre = -1;
ans = Integer.MAX_VALUE;
dfs(root);
        return ans;
    }

    private void dfs(TreeNode root) {
        if(root == null) return;

            dfs(root.left);
        if(pre == -1)
            pre = root.val;
        else
        {
            ans = Math.min(ans,Math.abs(pre -root.val));
            pre = root.val;
        }
        dfs(root.right);
    }
```







## 递归的形式判断是否是二叉搜索树

```java
isValidBST(TreeNode root) {
    return isValidBST(root,null,null) ;
}
isValidBST(TreeNode root,TreeNode min,TreeNode max) {
   if(root == null )return true;//注意这个root为空时返回true
    if((min != null &&root.data =< min.data )|| (max!=null && root.data >= max.data)) return false;
    return isValidBST(root.left,min,root)&& isValidBST(root.right,root,max);
   //if(min != null) 
}

```



在 BST 中查找⼀个数是否存在
根据我们的指导思想，可以这样写代码：

```java
boolean isInBST(TreeNode root, int target) {
if (root == null) return false;
if (root.val == target) return true;
return isInBST(root.left, target)
|| isInBST(root.right, target);
}
```

对数据结构的操作⽆⾮遍历 + 访问，遍历就是“找”，访问就是“改”。具体到
这个问题，插⼊⼀个数，就是先找到插⼊位置，然后进⾏插⼊操作。
上⼀个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框
架，加上“改”的操作即可。⼀旦涉及“改”，函数就要返回 TreeNode 类型，
并且对递归调⽤的返回值进⾏接收。

```java
TreeNode insertIntoBST(TreeNode root, int val) {
 if(root == null) return new TreeNode(val) ;//找到了空的位置
    if(root.val < val)
        root.right = insertIntoBST(root.right,val);
    if(root.val > val)//BST 中⼀般不会插⼊已存在元素
        root.left = insertIntoBST(root.left,val);
    return root;
        
}
```



## 前中后序遍历图片

![image-20220126011639618](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220126011639618.png)

## 二叉搜索树的中序后继

给定根节点和一个节点p,求p的中序后继

因为这里用到了二叉搜索树所以可以利用二叉搜索树的特性

二叉搜索树的一个性质是中序遍历序列单调递增，因此二叉搜索树中的节点 p 的中序后继满足以下条件：

中序后继的节点值大于 p 的节点值；

中序后继是节点值大于 p 的节点值的所有节点中节点值最小的一个节点。

![image-20230219122058738](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230219122058738.png) 

```java
 public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
       TreeNode successor=null;
       if(p.right!=null)
       {
           successor=p.right;
           while(successor.left!=null)
           successor=successor.left;
           return successor;
       }
       TreeNode cur=root;
       while(cur!=null)
       {
           if(cur.val>p.val)
           {
               successor=cur;
               cur=cur.left;
           }
           else cur=cur.right;
       }
        return successor;
    }
 
```



## Morris遍历

**：和二叉树的遍历有关的最优解都是 Morris 遍历。**

是使用线索二叉树进行中序遍历的一种实现，其可以在O(n)的时间，O(1)的空间完成遍历， 对其稍加修改可以推广到先序、后序遍历，其遍历过程包含三个部分：

创建指向中序后驱结点的线索；
遍历输出结点；
删除线索，恢复树的结构；
\2. Morris 中序遍历
Morris 中序遍历过程如下：

当前结点的左孩子是否为空，若是则输出当前结点，更当前结点为当前结点的右孩子；否则进入2；

在当前结点的左子树中寻找中序遍历下的前驱结点（左子树中最右结点）

a. 若前驱结点的右孩子为空，则将前驱结点的右孩子指向当前结点，当前结点更新为当前结点的左孩子；进入3；

b. 若前驱结点的右孩子为当前结点（不为空），将前驱结点的右孩子置NULL，输出当前结点，当前结点更新为当前结点的右孩子，进入3；

若当前结点不为空，进入1；否则程序结束； 

中序：

```java
  public static class Node{
        private Node left;
        private Node right;
        private int value;
 
        public Node(int value){
            this.value = value;
        
        }
public void morris1(TreeNode t1)
{
    TreeNode cur = t1;
    if(t1 == null) return;
     TreeNode mostright= null;
    while(cur != null){
        mostright = cur.left;
        if(mostright != null)//如果cur.left不为空
        {
        while(mostright.right != null &&mostright.right != cur
                    // 找到左子树的最右子节点mostRight
        {
            mostright = mostright.right;
            
        }
            if(mostright.right == null)
            {mostright.right = cur;//建立线索
             cur = cur.left;
            continue;}
                                  // 第一次来到current
                    // 遍历完左子树，通过mostRight.right就可以返回到current了

            else
            {
                mostright.right = null;//删除线索
            }
            
        }
       
         //如果cur.left为空
               System.out.println(cur.val);
         cur = cur.right;//进入下一轮while循环
    }
}
```



Morris 的前序遍历：不管有无左子树，都是第一次遍历到一个节点时就打印。



```java
public class Morris {
// Morris先序遍历：有无左子树都是第一次遍历到current时就打印
public static void morrisPre(Node root){
    if(root == null){
        return;
    }
    Node current = root;
    Node mostRight = null;
    while(current != null){
        mostRight = current.left;
        // current 有左子树时，就要进行Morris遍历
        if(mostRight != null){
            while(mostRight.right != null && mostRight.right != current){
                // 找到左子树的最右子节点mostRight
                mostRight = mostRight.right;
            }
            // mosrRight找到了,说明是第一次来到cur
            if(mostRight.right == null){
                System.out.print(current.value + " ");
                mostRight.right = current;
                current = current.left;
                continue;//continue保证了不会走到下面的current=current.right;
            }else{
                mostRight.right = null;
            }
        }else{
            // 无左子树，第一次来到current
            System.out.print(current.value + " ");
        }
        // 无左子树 或者左子树已经遍历完了就遍历右子树
        current = current.right;
    }
}
```
}

中序遍历：



```java
// Morris中序遍历：没有左子树的节点直接打印，有左子树的节点，第二次遍历到打印
public static void morrisIn(Node root){
    if(root == null){
        return;
    }
    Node current = root;
    Node mostRight = null;
    while(current != null){
        mostRight = current.left;
        // current 有左子树时，就要进行Morris遍历
        if(mostRight != null){
            while(mostRight.right != null && mostRight.right != current){
                // 找到左子树的最右子节点mostRight
                mostRight = mostRight.right;
            }
            // mosrRight找到了,说明是第一次来到cur
            if(mostRight.right == null){
                mostRight.right = current;
                current = current.left;
                continue;
            }else{
                System.out.print(current.value + " ");
                mostRight.right = null;
            }
        }else{
            // 无左子树，第一次来到current
            System.out.print(current.value + " ");
        }
        // 无左子树 或者左子树已经遍历完了就遍历右子树
        current = current.right;
    }
}
```


## 节点间的最大距离。 

从二叉树的节点A出发，可以向上或者向下走，但沿途的节点只能经过一次，当到达节点B时，路径上的节点数叫作A到B的距离。 比如，图3-48所示的二叉树，节点4和节点2的距离为2，节点5和节点6的距离为5。给定一棵二叉树的头节点head，求整棵树上节点间的最大距离。 

难度】 尉　★★☆☆ 

【解答】 一个以h为头的树上，最大距离只可能来自以下三种情况： 

h的左子树上的最大距离。 

h的右子树上的最大距离。 

h左子树上离h.left最远的距离+1（h）+h右子树上离h.right最远的距离。 三个值中最大的那个就是整棵h树中最远的距离。 根据如上分析，设计解法的过程如下： 1.整个过程为后序遍历，在二叉树的每棵子树上执行步骤2。 2.假设子树头为h，处理h左子树，得到两个信息，左子树上的最大距离记为lMax，左子树上距离h左孩子的最远距离记为maxfromLeft。同理，处理h右子树得到右子树上的最大距离记为rMax和距离h右孩子的最远距离记为maxFromRight。那么maxfromLeft+1+maxFromRight就是跨h节点情况下的最大距离，再与lMax和rMax比较，把三者中的最值作为h树上的最大距离返回，maxfromLeft+1就是h左子树上离h最远的点到h的距离，maxFromRight+1就是h右子树上离h最远的点到h的距离，选两者中最大的一个作为h树上距离h最远的距离返回。如何返回两个值？一个正常返回，另一个用全局变量表示。 

![image-20210923000909108](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210923000909108.png)

```java
public int maxDistance(TreeNode head)
{
    int[] record = new int[1];
    return posOrder(head,record);
}

private int posOrder(TreeNode head, int[] record) {
    if(head == null)
    {
        record[0] = 0;
        return 0;
    }
    int lmax = posOrder(head.left,record);
    int maxfromleft = record[0];
    int rmax = posOrder(head.right,record);
    int maxfromright = record[0];
    //这是经过头节点的路径
    int coreMax = maxfromright + maxfromleft +1;
    record[0] = Math.max(lmax,rmax) +1;
    return Math.max(coreMax,Math.max(lmax,rmax));
}
```



## 节点最大路径和

![image-20220125174847606](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220125174847606.png)

![image-20220125174908181](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220125174908181.png)

```java
class Solution {
    int total = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {

findmax(root); 
//rmax = Math.max(rmax,lmax);
return total;
    }
    public int findmax(TreeNode root)
    {
        if(root == null) return 0;
       int leftmax = Math.max(findmax(root.left),0);
       int rightmax= Math.max(findmax(root.right),0);

int pricepath = root.val+leftmax+rightmax;
total =Math.max(total,pricepath);//total是最大的值
return root.val+Math.max(leftmax,rightmax);//结点的最大贡献度

    }
}
```





## 多叉树遍历

基于二叉树的框架遍历多叉树（层序遍历）

```java
void levelTraverse(TreeNode root){
    if(root == null) return 0;
    Queue<TreeNode>q = new Linkedlist<>();
    q.offer(root);
    int depth = 1;
    while(!q.isEmpty())
    {
        int sz = q.size();
        for(int i = 0;i < sz;i++)
        {
            TreeNode r = q.poll();
            System.out.println("节点%s在第%s层",r,depth);
            for(TreeNode child:r.children)
                q.offer(child);//把每一层的所有结点放入队列
        }
        depth++;//注意depth++的位置
    }
}
```



## **[节点与其祖先之间的最大差值](https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/)**

![image-20210923174134531](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210923174134531.png)

```java
 int res = 0;
    public int maxAncestorDiff(TreeNode root) {
recurse(root);
return res;
    }
     private int[] recurse(TreeNode root) {
        if(root ==null)return null;
        if(root.left==null&&root.right==null)
        {
            res = Math.max(res,0);
            //int数组存储从根节点到叶节点的路径上的最大值和最小值，递归地更新，先找到左子树上到叶节点的最大值和最小值，再往上回溯
            return new int[]{root.val,root.val};
        }
        int low = Integer.MAX_VALUE;
        int high = Integer.MIN_VALUE;
        int left[] = recurse(root.left);
        if(left!=null)
        {
            low = Math.min(low,left[0]);
            high = Math.max(high,left[1]);
        }
        int right[] = recurse(root.right);
        if(right!=null)
        {
            low = Math.min(low,right[0]);
            high = Math.max(high,right[1]);
        }//比较，是这个路径上的最大值减去root的值大还是最小值减去root的值大
        res= Math.max(res,Math.max(Math.abs(root.val - low),Math.abs(root.val-high)));
        return new int[]{Math.min(root.val,low),Math.max(root.val,high)};

    }
```





## 最近公共祖先

方法一：

后序遍历二叉树，假设遍历到的当前节点为cur。因为是后序遍历，所以先处理cur的两棵子树。假设处理cur左子树时返回节点为left，处理右子树时返回right。

1.如果发现cur等于null，或者o1、o2，则返回cur。 

2.如果left和right都为空，说明cur整棵子树上没有发现过o1或o2，返回null。 

3.如果left和right都不为空，说明左子树上发现过o1或o2，右子树上也发现过o2或o1，说明o1向上与o2向上的过程中，首次在cur相遇，返回cur。 

4.如果left和right有一个为空，另一个不为空，假设不为空的那个记为node，此时node到底是什么？有两种可能，要么node是o1或o2中的一个，要么node已经是o1和o2的最近公共祖先。不管是哪种情况，直接返回node即可。 

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
         if (root == null) return null;
         TreeNode left=lowestCommonAncestor(root.left,p,q);
         TreeNode right=lowestCommonAncestor(root.right,p,q);
         if(left!=null&&right!=null) return root;
         if(root==p||root==q) return root;
         if(left==null) return right;
         if(right==null) return left;
        return null;
    }

    }
```

方法二：

```java
         private HashMap<TreeNode, TreeNode> map;

            public void Record1(TreeNode head) {

map = new HashMap<>();
if(head != null) map.put(head,null);
setMap(head);


            }

    private void setMap(TreeNode head) {
                if(head == null) return;
                if(head.left!= null)
                    map.put(head.left,head);
                if(head.right!=null)
                    map.put(head.right,head);
                setMap(head.left);
                setMap(head.right);
    }
public TreeNode query(TreeNode p,TreeNode q)
{
    Set<TreeNode> path = new HashSet<>();
    while (map.containsKey(p))
    {
        path.add(p);
        p = map.get(p);
    }
    while (!path.contains(q))
    {
        q = map.get(q);
    }
    return q;
}
```







如果是二叉搜索树的最近公共祖先，由于二叉搜索树每个结点值不一样，可以采用两个数组存储中序遍历到结点的路径，返回最先分叉的点：



```java
     
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
List<TreeNode> path1 = new ArrayList<>();
List<TreeNode> path2 = new ArrayList<>();
path1 = findNode(root,p);
path2 = findNode(root,q);
TreeNode tar = null;
        for (int i = 0; i < path1.size() && i < path2.size(); i++) {
            if(path1.get(i).val == path2.get(i).val)
                tar = path1.get(i);
                else
                break;
        }
        return tar;
    }

        public List<TreeNode> findNode(TreeNode root, TreeNode q)
    {
        List<TreeNode>path = new ArrayList<>();
        TreeNode treeNode = root;
        while (treeNode!= q)
        {
            path.add(treeNode);
            if(treeNode.val > q.val) {
                treeNode = treeNode.left;    
            }
            else if(treeNode.val < q.val) {
                treeNode = treeNode.right;
            }
        }
        path.add(q);
        return path;
    }

```





## 判断一颗树是否是二叉排序树

对给定的树中序遍历，如果始终能保证前一个结点的关键字比后一个结点的关键字小，则说明该二叉树是一棵排序树,为了比较前一个结点与后一个结点，需要设一个结点保存之前遍历的结点

```java
T pre= MIN;//用于保存当前结点中序前驱的结点值,注意必须要是全局变量才可以
bool judgeBST(BSTNode *b){
    //判断二叉树B是否为BST
    bool flag1,flag2;
    if(b == null) return true;
    else
    {
        flag1 = judgeBST(b->lchild);//判断左子树
        if(!flag1 || pre >= b.val) return false;
        pre = b->val;
        
        flag2 = judgeBST(b->rchild);
        return flag2;
}
}

```

## 寻找距离f值距离最近且大于等于f的节点

其中f=(min+max)/2;

```java
BSTNode* getNode(BSTNode*bt){
    BSTNode*p = bt,*q = bt,*result;
    while(p->lchild != null)
    {
        p = p->lchild;
    }
    while(q->rchild != null)
    {
        q = q.rchild;
    }
    int f = (p.val + q.val)/2;
    while(bt != null)
    {
        if(bt.val < f)
        {
            bt = bt.rchild;
        }
        else
        {
result = bt;//在左子树中寻找最近的结点
            bt = bt.lchild;//result才是最后一个大于等于bt结点的结点
        }
        return result;
    }
}
```



## 二叉树序列化

先序序列化的方式：

```java
 // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "#!";
        String res = root.val + "!";
        res+=serialize(root.left);
        res+=serialize(root.right);
        return res;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[]values = data.split("!");
         Queue<String>queue = new LinkedList<>();
         for(int i = 0;i < values.length;i++)
         queue.offer(values[i]);
return rebuild(queue);

    }
    public TreeNode rebuild(Queue<String>qu)
    {
        String val = qu.poll();
        if(val.equals("#"))
        return null;
        TreeNode head = new TreeNode(Integer.valueOf(val));
        head.left = rebuild(qu);
        head.right = rebuild(qu);
        return head;
    }
```

## 搜索二叉树序列化

这里利用搜索二叉树的性质，用后序遍历的方式

```java
   public StringBuilder postorder(TreeNode root, StringBuilder sb) {
        if (root == null)
          {
 return sb.append("#!");
          } 
        postorder(root.left, sb);//后序遍历 左子树-右子树-根节点
        postorder(root.right, sb);
        sb.append(root.val);
        sb.append('!');
        return sb;
    }

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = postorder(root, new StringBuilder());
   
        return sb.toString();
    }

    public TreeNode helper(Integer lower, Integer upper, ArrayDeque<String> nums) {
        while(!nums.isEmpty()&& nums.getLast().equals("#")) //先移除掉为null的元素
    nums.removeLast();
        if (nums.isEmpty())//如果只剩一个#，这时候nums为空，直接返回
            return null;
   
 
      String val = nums.getLast();//否则进行后序遍历，先取出根节点 即队列的最后一个元素
       if (Integer.valueOf( val )< lower || Integer.valueOf(val) > upper)//这个条件判断不能少，否则结果不正确
          return null;

        nums.removeLast();//在这里要把刚刚遍历到的最后一个元素移除
        int number = Integer.valueOf( val );
        TreeNode root = new TreeNode(Integer.valueOf( val ));
        root.right = helper(number, upper, nums);
        root.left = helper(lower, number, nums);//在这里注意，根节点的左边小于根节点，根节点的右边大于根节点
        return root;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data.isEmpty())
            return null;
        ArrayDeque<String> nums = new ArrayDeque<String>();
        for (String s : data.split("!"))
            nums.add(s);
        return helper(Integer.MIN_VALUE, Integer.MAX_VALUE, nums);//尤其注意这里的最大和最小值是什么
    }
```

## [652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)

难度中等464

给定一棵二叉树 `root`，返回所有**重复的子树**。

对于同一类的重复子树，你只需要返回其中任意**一棵**的根结点即可。

如果两棵树具有**相同的结构**和**相同的结点值**，则它们是**重复**的。

 ![image-20220903165017781](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220903165017781.png)

--------------------

使用深度优先搜索，其中递归函数返回当前子树的序列化结果。把每个节点开始的子树序列化结果保存在 map 中，然后判断是否存在重复的子树。每棵不同子树的序列化结果都是唯一的。

```java
   Map<String, Integer> count;
    Set<TreeNode>ans = new HashSet<>();
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
           count = new HashMap();
inOrder(root);
return new ArrayList<>(ans);
    }
    public String inOrder(TreeNode root){
        if(root==null)
 return "#";
 String serial = root.val+","+inOrder(root.left)+","+inOrder(root.right);
 count.put(serial,count.getOrDefault(serial,0)+1);
 if(count.get(serial)==2)
 ans.add(root);       
 return serial;
    }
```



## 🔷🔷（未思考清楚）二叉树的最大搜索二叉子树

一个普通二叉树，给定头节点，每个节点值不一样，返回含有节点数最多的搜索二叉子树并返回它的头节点

以节点node为头的树中，最大的搜索二叉子树只可能来自以下两种情况。 第一种：如果来自node左子树上的最大搜索二叉子树是以node.left为头的；来自node右子树上的最大搜索二叉子树是以node.right为头的；node左子树上的最大搜索二叉子树的最大值小于node.value；node右子树上的最大搜索二叉子树的最小值大于node.value，那么以节点node为头的整棵树都是搜索二叉树。 第二种：如果不满足第一种情况，说明以节点node为头的树整体不能连成搜索二叉树。这种情况下，以node为头的树上的最大搜索二叉子树是来自node的左子树上的最大搜索二叉子树和来自node的右子树上的最大搜索二叉子树之间，节点数较多的那个。 通过以上分析，求解的具体过程如下：

 1.整体过程是二叉树的后序遍历。 

2.遍历到当前节点记为cur时，先遍历cur的左子树收集4个信息，分别是左子树上最大搜索二叉子树的头节点（lBST）、节点数（lSize）、最小值（lMin）和最大值（lMax）。再遍历cur的右子树收集4个信息，分别是右子树上最大搜索二叉子树的头节点（rBST）、节点数（rSize）、最小值（rMin）和最大值（rMax）。  

3.根据步骤2所收集的信息，判断是否满足第一种情况，如果满足第一种情况，就返回cur节点，如果满足第二种情况，就返回lBST和rBST中较大的一个。 

4.可以使用全局变量的方式实现步骤2中收集节点数、最小值和最大值的问题。

```java
  public Node biggestSubBST(Node head) {
        int[] record = new int[3];
        return posOrder(head, record);
    }

    private Node posOrder(Node head, int[] record) {
if(head == null)
{
    record[0] = 0;
    record[1] = Integer.MAX_VALUE;
    record[2] = Integer.MIN_VALUE;
    return null;
}
int val = head.value;
    Node left = head.left;
    Node right = head.right;
    Node lBST = posOrder(left,record);
    int lsize = record[0];
    int lmin = record[1];
    int lmax = record[2];
    Node rBST = posOrder(right,record);
    int rsize = record[0];
    int rmin = record[1];
    int rmax = record[2];
    record[1] = Math.min(lmin,val);
    record[2] = Math.max(rmax,val);
    if(left == lBST && right == rBST && lmax < val && rmin > val)
    {
        record[0] = lsize + rsize+1;
        return head;
    }
    record[0] = Math.max(lsize,rsize);
    return lsize>rsize?lBST:rBST;
    }
```





## 判断B是不是A的子结构



给定彼此独立的两棵树头节点分别为t1和t2，判断t1树是否包含t2树全部的拓扑结构。
如果t1中某棵子树头节点的值与t2头节点的值一样，则从这两个头节点开始匹配，匹配的每一步都让t1上的节点跟着t2的先序遍历移动，每移动一步，都检查t1的当前节点是否与t2当前节点的值一样。比如，题目中的例子，t1中的节点2与t2中的节点2匹配，然后t1跟着t2向左，发现t1中的节点4与t2中的节点4匹配，t1跟着t2继续向左，发现t1中的节点8与t2中的节点8匹配，此时t2回到t2中的节点2，t1也回到t1中的节点2，然后t1跟着t2向右，发现t1中的节点5与t2中的节点5匹配。t2匹配完毕，结果返回true。如果匹配的过程中发现有不匹配的情况，直接返回false，说明t1的当前子树从头节点开始，无法与t2匹配，那么再去寻找t1的下一棵子树。t1的每棵子树上都有可能匹配出t2，所以都要检查一遍。

(约定空树不是任意一个树的子结构)

```java
 public boolean isSubStructure(TreeNode A, TreeNode B) {
    if(B == null ||A == null) return false;
return contain(A,B)|| isSubStructure(A.left,B) || isSubStructure(A.right,B);
    }

        public boolean contain(TreeNode a, TreeNode b) {
        if(b == null) return true;
        if(a == null || a.val != b.val) return false;
        return  contain(a.left,b.left) && contain(a.right,b.right);
    }
```

力扣：[572. 另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。

二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。



```java
 public boolean isSubtree(TreeNode root, TreeNode subRoot) {
return dfs(root,subRoot);
    }
   boolean dfs(TreeNode o, TreeNode t) {
        if (o==null) {
            return false;
        }
        return judgeequal(o, t) || dfs(o.left, t) || dfs(o.right, t);
    }


    public boolean judgeequal(TreeNode root,TreeNode subRoot)
    {
        if(subRoot==null && root==null) return true;
if(subRoot==null) return false;
if(root==null) return false;
        if(root.val!=subRoot.val) return false;
        
        return judgeequal(root.left,subRoot.left)&&judgeequal(root.right,subRoot.right);
    }
```








## 判断t1树中是否有与t2树拓扑结构完全相同的子树 
给定彼此独立的两棵树头节点分别为t1和t2，判断t1中是否有与t2树拓扑结构完全相同的子树。

![image-20210921210857787](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210921210857787.png)

如果t1的节点数为N，t2的节点数为M，本题最优解是时间复杂度为O（N+M）的方法。先简单介绍一个时间复杂度为O（N×M）的方法，对于t1的每棵子树，都去判断是否与t2树的拓扑结构完全一样，这个过程的复杂度为O（M），t1的子树一共有N棵，所以时间复杂度为O（N×M），这种方法本书不再详述。 下面重点介绍一下时间复杂度为O（N+M）的方法，首先是把t1树和t2树按照先序遍历的方式序列化，例如t1树序列化后的结果为“1！2！4！#！8！#！#！5！9！#！#！#！3！6！#！#！7！#！#！”，记为t1Str。t2树序列化后的结果为“2！4！#！8！#！#！5！9！#！#！#！”，记为t2Str。接下来只要验证t2Str是否是t1Str的子串即可，这个用KMP算法可以在线性时间内解决。所以t1序列化的过程为O（N），t2序列化的过程为O（M），KMP解决t1Str和t2Str的匹配问题O（M+N），所以时间复杂度为O（M+N）。 

```java
       public boolean isSubtree(Node t1, Node t2) {
              String t1Str = serialByPre(t1);
              String t2Str = serialByPre(t2);
              return getIndexOf(t1Str, t2Str) != -1;
       }

       public String serialByPre(Node head) {
              if (head == null) {
                     return "#!";
              }
              String res = head.value + "!";
              res += serialByPre(head.left);
              res += serialByPre(head.right);
              return res;
       }

       // KMP
       public int getIndexOf(String s, String m) {
              if (s == null || m == null || m.length() < 1 || s.length() < m.length())               {
                     return -1;
              }
              char[] ss = s.toCharArray();
              char[] ms = m.toCharArray();
              int si = 0;
              int mi = 0;
              int[] next = getNextArray(ms);
              while (si < ss.length && mi < ms.length) {
                     if (ss[si] == ms[mi]) {
                            si++;
                            mi++;
                     } else if (next[mi] == -1) {
                            si++;
                     } else {
                            mi = next[mi];
                     }
              }
              return mi == ms.length ? si - mi : -1;
       }
 

       public int[] getNextArray(char[] ms) {
              if (ms.length == 1) {
                     return new int[] { -1 };
              }
              int[] next = new int[ms.length];
              next[0] = -1;
              next[1] = 0;
              int pos = 2;
              int cn = 0;
              while (pos < next.length) {
                     if (ms[pos - 1] == ms[cn]) {
                            next[pos++] = ++cn;
                     } else if (cn > 0) {
                            cn = next[cn];
                     } else {
                            next[pos++] = 0;
                     }
              }
              return next;
       }
 

```





## 判断是否是平衡二叉树

自己的代码：

```java
   public boolean isBalanced(TreeNode root) {
if(root == null || (root.left == null && root.right == null)) return true;
int lh = getHeight(root.left);
int rh = getHeight(root.right);
if(Math.abs(lh - rh) >1) return false;
return isBalanced(root.left) && isBalanced(root.right);
    }
      public int getHeight(TreeNode root)
    {
        if(root == null) return 0;
        int lh = getHeight(root.left) +1;
        int rh = getHeight(root.right) +1;
        return Math.max(lh,rh);
    }
```





## 判断数组是不是某二叉搜索树的后序遍历结果

给定一个整型数组arr，已知其中没有重复值，判断arr是否可能是节点值类型为整型的搜索二叉树后序遍历的结果。 

```java
 public boolean verifyPostorder(int[] postorder) {
if(postorder == null || postorder.length == 0) return true;
return post(postorder,0,postorder.length-1);
    }
     private boolean post(int[] postorder, int begin, int end) {
        if(begin == end) return true;
        int more = end,less = -1;
        for (int i = begin; i < end; i++) {
            if(postorder[end] > postorder[i])
                less = i;
            else more = more == end?i:more;
        }
        if(more == end || less==-1) return post(postorder,begin,end-1);//有可能只有左子树或者只有右子树
        if(more - less != 1) return false;//不满足条件
        return post(postorder,begin,less) && post(postorder,more,end-1);
    }
```

进阶：通过一个数组重建搜索二叉树，已知数组是搜索二叉树的后序遍历(剑指offer 07)

```java
 public boolean verifyPostorder(int[] postorder) {
if(postorder == null || postorder.length == 0) return true;
return postToBST(postorder,0,postorder.length-1);
    }
 public Node postToBST(int[]arr,int begin,int end)
 {
     if(begin > end) return null;
     TreeNode node = new  TreeNode(arr[end]);
 int more = end,less = -1;
        for (int i = begin; i < end; i++) {
            if(postorder[end] > postorder[i])
                less = i;
            else more = more == end?i:more;
        }
      node.left = postToBST(arr,begin,less);
     node.right = postToBST(arr,more,end-1);
     return head;
 }

```



## 判断是否是一个有效的二叉搜索树。

只需要改写二叉树的中序遍历，在遍历过程中查看节点值是否都是递增的即可。

下面以mirros遍历进行判断：

```java
if(root == null) return true;
TreeNode cur2;
boolean res = true;
TreeNode cur = root,pre = null;
while (cur != null)
{
    cur2 = cur.left;//当cur2为null,说明左子树已经遍历完，开始判断pre与cur的值大小
    if(cur2!= null) {
        while (cur2.right != null && cur2.right != cur) {
            cur2 = cur2.right;
        }
        if (cur2.right == null) {
            cur2.right = cur;
            cur = cur.left;
            continue;
        } else cur2.right = null;
    }
pre=cur;
cur = cur.right;
if(pre.val > cur.val) res = false;


}
return res;
```



## 验证是否是完全二叉树

完全二叉树：除了最后一层，每一层节点数均达到最大值，在最后一层上只缺少右边的若干节点

思路：1.按层序遍历二叉树

2.如果当前节点有右孩子无左孩子返回false

3.如果只有左孩子没有右孩子，那之后的结点必须都为叶节点

```java

  public boolean isValidCST(TreeNode root) {
if(root == null) return true;
TreeNode cur2;
boolean res = false;
TreeNode left = root,right = null;
Queue<TreeNode> queue = new LinkedList<>();
queue.offer(root);
while (!queue.isEmpty())
{
    root = queue.poll();
    left = root.left;
    right = root.right;
    if((res && (left != null || right != null)) ||(left == null && right!= null)) return false;
    if(left!=null)
        queue.offer(left);
    if(right!=null)
        queue.offer(right);//(res && (left != null || right != null))表示当前结点只有左节点没有右节点且后面的结点不是叶子节点
    else res = true;
                
        
}
return true;
}
```



## 通过有序数组生成平衡搜索二叉树

给定一个有序数组sortArr，已知其中没有重复值，用这个有序数组生成一棵平衡搜索二叉树，并且该搜索二叉树中序遍历的结果与sortArr一致。 

【难度】 士　★☆☆☆ 

【解答】 本题的递归过程比较简单，用有序数组中最中间的数生成搜索二叉树的头节点，然后用这个数左边的数生成左子树，用右边的数生成右子树即可。 

```java
 public TreeNode generateNode(int[]sortarr)
  {
      if(sortarr == null) return null;
     return generate(sortarr,0,sortarr.length-1);
  }

    private TreeNode generate(int[] sortarr, int low, int high) {
        int mid = low + (high-low)>>1;
        TreeNode head = new TreeNode(sortarr[mid]);
        head.left = generate(sortarr,low,mid-1);
        head.right = generate(sortarr,mid+1,high);
        return head;
    }
```

## 删除二叉搜索树中的结点

这里有三种可能的情况：

- 要删除的节点为叶子节点，可以直接删除
- 要删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点
- 要删除的节点不是叶子节点，且没有右节点但是有左节点。这意味着它的后继节点在它的上面，但是我们并不想返回。我们可以使用它的前驱节点进行替代，然后再递归的向下删除前驱节点。

![image-20220216215216185](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220216215216185.png)

![image-20220216215417890](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220216215417890.png)



```java
    public int sussessor(TreeNode root,int key)//非叶结点的后继
    {
        root = root.right;
        while(root.left != null)
        {
            root = root.left;
        }
        return root.val;
    }
    public int prenode(TreeNode root,int key)//非叶结点的前驱
    {
        root = root.left;
        
        while(root.right!=null)
        {
            root = root.right;
        }
     return root.val;
    }

    public TreeNode deleteNode(TreeNode root, int key) {
if(root == null) return root;

if(root.val >key)
root.left = deleteNode(root.left,key);
else if(root.val < key)
root.right = deleteNode(root.right,key);
else
{//找到了要删除的结点
    if(root.left==null&&root.right==null)
    {
        root  =null;
    }
    else if(root.right != null)//如果存在右子树说明存在后继
    {
        root.val = sussessor(root,key);
        root.right = deleteNode(root.right,root.val);

    }
    else//如果存在左节点则存在前驱，则将要删除的结点值改为前驱结点的值然后删除前驱结点
    {
        root.val = prenode(root,key);
        root.left = deleteNode(root.left,root.val);
    }
}
 
 return root;
    }
```



## [863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)

给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。

返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。

 若将 target 当作树的根结点，我们就能从target 出发，使用深度优先搜索去寻找与 target 距离为 k 的所有结点，即深度为 k的所有结点。

由于输入的二叉树没有记录父结点，为此，我们从根结点root 出发，使用深度优先搜索遍历整棵树，同时用一个哈希表记录每个结点的父结点。

然后从target 出发，使用深度优先搜索遍历整棵树，除了搜索左右儿子外，还可以顺着父结点向上搜索。

代码实现时，由于每个结点值都是唯一的，哈希表的键可以用结点值代替。此外，为避免在深度优先搜索时重复访问结点，递归时额外传入来源结点from，在递归前比较目标结点是否与来源结点相同，不同的情况下才进行递归。

```java
 Map<Integer, TreeNode> parents = new HashMap<Integer, TreeNode>();
    List<Integer> ans = new ArrayList<Integer>();

    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        // 从 root 出发 DFS，记录每个结点的父结点
        findParents(root);

        // 从 target 出发 DFS，寻找所有深度为 k 的结点
        findAns(target, null, 0, k);

        return ans;
    }

    public void findParents(TreeNode node) {
        if (node.left != null) {
            parents.put(node.left.val, node);
            findParents(node.left);
        }
        if (node.right != null) {
            parents.put(node.right.val, node);
            findParents(node.right);
        }
    }

    public void findAns(TreeNode node, TreeNode from, int depth, int k) {
        if (node == null) {
            return;
        }
        if (depth == k) {
            ans.add(node.val);
            return;
        }
        if (node.left != from) {
            findAns(node.left, node, depth + 1, k);
        }
        if (node.right != from) {
            findAns(node.right, node, depth + 1, k);
        }
        if (parents.get(node.val) != from) {
            findAns(parents.get(node.val), node, depth + 1, k);
        }
    }


```

## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

难度中等1226

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

-----

```java

    public int pathSum(TreeNode root, int targetSum) {
int tot = 0;//dfs(p,val) 表示以节点 p为起点向下且满足路径总和为 valval 的路径数目。我们对二叉树上每个节点 p 求出 dfs(p,targetSum)，然后对这些路径数目求和即为返回结果。

if(root==null) return 0;
tot=dfs(root,targetSum);
tot+=pathSum(root.left,targetSum);//其实相当于对每个结点都调用了dfs方法
tot+=pathSum(root.right,targetSum);//注意这个递归函数是哪个递归函数
return tot;
    }
    public int dfs(TreeNode root,int targetSum)
    {
        int tot = 0;//在这里Tot是局部变量
        if(root == null)
        return 0;
     
        if(targetSum == root.val)
        {
            tot++;
        }
      
          tot+=  dfs(root.left,targetSum-root.val);
         tot+=   dfs(root.right,targetSum-root.val);
       //     sum -=root.val;
 return tot;
    }
}
```

也可以用前缀和的方法来解：

这道题用到了一个概念，叫前缀和。就是到达当前元素的路径上，之前所有元素的和。

前缀和怎么应用呢？

在同一个路径之下（可以理解成二叉树从root节点出发，到叶子节点的某一条路径），如果两个数的前缀总和是相同的，那么这些节点之间的元素总和为零。进一步扩展相同的想法，如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target。

因为本题中的路径是一棵树，从根往任一节点的路径上(不走回头路)，有且仅有一条路径，因为不存在环。(如果存在环，前缀和就不能用了，需要改造算法)

抵达当前节点(即B节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和currSum-target的节点(即A节点)，存在即表示从A到B有一条路径之和满足条件的情况。结果加上满足前缀和currSum-target的节点的数量。然后递归进入左右子树。

左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。

核心代码

// 当前路径上的和
currSum += node.val;
// currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target
res += prefixSumCount.getOrDefault(currSum - target, 0);
// 更新路径上当前节点前缀和的个数
prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, 0) + 1);
代码

```java
   public int pathSum(TreeNode root, int targetSum) {
int tot = 0;
  // key是前缀和, value是大小为key的前缀和出现的次数
  Map<Integer,Integer>mymap = new HashMap<Integer,Integer>();
  mymap.put(0,1);//前缀和为0时次数为1
  return prefixsum(root,targetSum,mymap,0);

    }
    public int prefixsum(TreeNode root,int targetSum,Map<Integer,Integer>mymap,int cursum)
    {
        if(root == null) return 0;
        cursum+=root.val;
    int ret = mymap.getOrDefault(cursum - targetSum,0);
    mymap.put(cursum,mymap.getOrDefault(cursum,0)+1);
    ret+= prefixsum(root.left,targetSum,mymap,cursum);
    ret+=prefixsum(root.right,targetSum,mymap,cursum);
    mymap.put(cursum,mymap.getOrDefault(cursum,0)-1) ; 
    return ret;
    }
```



## [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

难度困难744

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

这里，我们选择先序遍历的编码方式，我们可以通过这样一个例子简单理解

--------

![image-20220130153605738](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220130153605738.png)

code

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        //序列化''
        return serialize(root,"");
    }
public String serialize(TreeNode root,String str)
{
    if(root == null) str+="None,";
    else
    {
        str+=str.valueOf(root.val)+",";
        str=serialize(root.left,str);
        str=serialize(root.right,str);
    }
    return str;
} 
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //反序列化
    String[] strs = data.split(",");
    List<String>ans = new LinkedList<>(Arrays.asList(strs));
    return deserialize(ans);
    }
public TreeNode deserialize(List<String>data)
{
if(data.get(0).equals("None"))
{
    data.remove(0);
    return null;
}
int val = Integer.parseInt(data.get(0));
data.remove(0);
TreeNode root = new TreeNode(val);
root.left = deserialize(data);
root.right = deserialize(data);
return root;
} 
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
```





## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

难度中等506

给定一个二叉树

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。



---

思路：不用队列额外空间，直接利用next指针，可以得到一条队列，再用两个额外结点分别表示下一次开始的结点和上一个遍历到的结点

```java
  Node last,nextStart;
    public Node connect(Node root) {
        if(root == null) return null;
        Node start = root;
while(start!= null)
{
    last=null;nextStart=null;
    for(Node p = start;p!=null;p=p.next)
    {
if(p.left!=null)
handle(p.left);
if(p.right!=null)
handle(p.right);
start = nextStart;
    }
}
return root;
    }
    public void handle(Node p)
    {
        if(last!=null)
        last.next = p;
        if(nextStart==null)
        nextStart = p;
        last = p;
    }
```

## [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

难度中等260

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

----

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root == null) return new TreeNode(val);
        TreeNode temp = root;
        while(temp !=null)
        {
            if(val > temp.val)
            {
                if(temp.right==null)
                {
                    temp.right = new TreeNode(val);
                break;
                }
                temp = temp.right;
            }else
            {
                if(temp.left==null)
                {
                    temp.left = new TreeNode(val);
                    break;
                }
                temp = temp.left;
            }
        }
        return root;
    }
```





## 约瑟夫环

```java
 public int lastRemaining(int n, int m) {

   // if(n == 1) return 0;

List<Integer>mylist = new ArrayList<>();

for(int i = 0;i <n;i++)
{
mylist.add(i);
}
int idx = 0;
while(n>1)
{
  idx = (idx + m-1)%n;
  mylist.remove(idx);
  n--;
}
return mylist.get(0);
  }


```



## [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

难度中等829

在一条环路上有 *N* 个加油站，其中第 *i* 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 *i* 个加油站开往第 *i+1* 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

**说明:** 

- 如果题目有解，该答案即为唯一答案。
- 输入数组均为非空数组，且长度相同。
- 输入数组中的元素均为非负数。

**示例 1:**

```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3
```

---

推论：从 x,y 之间的任何一个加油站出发，都无法到达加油站 y 的下一个加油站。

在发现了这一个性质后，算法就很清楚了：我们首先检查第 0 个加油站，并试图判断能否环绕一周；如果不能，就从第一个无法到达的加油站开始继续检查。



```java
  public int canCompleteCircuit(int[] gas, int[] cost) {
int sum=0;
int index=0;
while(index<gas.length)
{
int cnt=0;
int sumgat=0,sumcost=0;
while(cnt<gas.length)
{
    int j=(cnt+index)%gas.length;
sumgat+=gas[j];
sumcost+=cost[j];
if(sumgat<sumcost) break;
cnt++;
}
 if(cnt==gas.length) return index;
else
index=index+cnt+1;//如果没有这一步直接index+1会超时
}
return -1;
    }
```

## [1339. 分裂二叉树的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/)

难度中等69

给你一棵二叉树，它的根为 `root` 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。

由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_1_1699.png)**

```
输入：root = [1,2,3,4,5,6]
输出：110
解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）
```

------

```java
  long totalsum = 0,best = 0;
    public int maxProduct(TreeNode root) {
     int MOD = (int)1e9 + 7;//这里要加(int)否则会报错
totalsum=dfs(root);
 dfs2(root);
return (int)(best %MOD);//注意这里第二个括号不能少，否则结果不正确
    }
    public long dfs(TreeNode root)
    {
        if (root == null) return 0;
       return dfs(root.left)+dfs(root.right)+root.val;//这里是获得二叉树结点总和
        
       
    }
    public long dfs2(TreeNode root)
    {
           if (root == null) return 0;
long cur = dfs2(root.left) + dfs2(root.right)+root.val;//这里其实就是获得以每个结点作为分割，其下的结点值总和，因为分裂二叉树就是分成一个是根节点为根，一个以其他结点为根的子树

best =Math.max(best,cur*(totalsum-cur));
return cur;
    }
```

## [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

难度中等564

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 *`nums` 构建的* ***最大二叉树\*** 。

![image-20220914193806166](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220914193806166.png)

---------------------



```java
 public TreeNode constructMaximumBinaryTree(int[] nums) {

TreeNode root = dfs(nums,0,nums.length-1);

return root;
    }
    public TreeNode dfs(int[]nums,int left,int right){
        if(left>right)return null;
int max = 0,index = 0;
        int best = left;
        for (int i = left + 1; i <= right; ++i) {
            if (nums[i] > nums[best]) {
                best = i;
            }
        }
        TreeNode root = new TreeNode(nums[best]);

    root.left = dfs(nums,left,best-1);
    root.right = dfs(nums,best+1,right);
    return root;
    }
```

## [1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)

难度中等126

给定二叉树的根节点 `root`，找出存在于 **不同** 节点 `A` 和 `B` 之间的最大值 `V`，其中 `V = |A.val - B.val|`，且 `A` 是 `B` 的祖先。

（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那

么我们认为 A 是 B 的祖先）

------------------

关键：其实就是祖先结点中的最大值或者最小值与当前结点的差值

```java
int maxdiff = 0;
    public int maxAncestorDiff(TreeNode root) {
        dfs(root,root.val,root.val);
        return maxdiff;
    }
    public void dfs(TreeNode root, int min, int max){
        if(root==null) return ;
        maxdiff = Math.max(maxdiff,Math.max(Math.abs(min-root.val),Math.abs(max-root.val)));
        min = Math.min(min,root.val);
        max = Math.max(max,root.val);
        //这里先左子树还是先右子树不影响
        dfs(root.right,min,max);
        dfs(root.left,min,max);
    }
```

## 图：1361.验证二叉树

二叉树上有 n 个节点，按从 0 到 n - 1 编号，其中节点 i 的两个子节点分别是 leftChild[i] 和 rightChild[i]。

只有 所有 节点能够形成且 只 形成 一颗 有效的二叉树时，返回 true；否则返回 false。

如果节点 i 没有左子节点，那么 leftChild[i] 就等于 -1。右子节点也符合该规则。

注意：节点没有值，本问题中仅仅使用节点编号。

示例 1：



输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
输出：true
示例 2：

![image-20230116195034524](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230116195034524.png)

输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
输出：false





------

在第二步中，我们从根节点开始进行深度优先搜索或广度优先搜索，判定这 n 个节点的连通性，这是因为当这个 n 个节点是一颗有效的二叉树时，所有的节点会恰好被遍历一次。如果某一个节点被遍历了超过一次（有不止一个父节点）或零次（不连通），那么这 n 个节点都不是一颗有效的二叉树。我们可以使用哈希集合（HashSet）seen 来存放所有被遍历过的节点，如果在搜索时遍历到了 seen 中出现的节点，那么说明该节点被遍历了超过一次。如果在搜索完成后，seen 中的节点个数少于 n，那么说明有些节点没有被遍历过。

回到第一步中遗留的那个问题，如果有多个满足 index[root] == 0 的节点 r1, r2, ...，那么我们可以任意选择一个节点，例如 r1，作为根节点。在搜索时，由于节点 r2, ... 的入度为 0，因此不可能被遍历到。这样在搜索结束后，seen 中的节点个数一定少于 n。



```java
   //只有满足：图中没有环、图都是连通的才可以
    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
int []indeg=new int[n];
for(int i=0;i<n;i++)
{
    if(leftChild[i]!=-1)
   {
        indeg[leftChild[i]]++;
          if(indeg[leftChild[i]]>1) return false;
   }
    if(rightChild[i]!=-1)
   { indeg[rightChild[i]]++;
  if(indeg[rightChild[i]]>1)return false;
}
}
int root=-1;
//如果有多个满足 indeg[root] == 0 的节点呢？在这种情况下，这 n 个节点一定不是一颗有效的二叉树。我们把这个问题放在第二步来考虑，而在第一步中，我们先不处理这个问题。


for(int i =0;i<n;i++){
    if(indeg[i]==0) {
        root=i;
        }
}
if(root==-1) return false;
Set<Integer>vis = new HashSet<>();
Queue<Integer>queue=new LinkedList<>();
vis.add(root);
queue.offer(root);
while(!queue.isEmpty()){
    int q=queue.poll();
    int left=leftChild[q];
    if(left!=-1) {
           if(vis.contains(left))return false;
        queue.offer(left);
 
    vis.add(left);
    }
    int right=rightChild[q];
    if(right!=-1) {
            if(vis.contains(right)) return false;
        queue.offer(right);

    vis.add(right);
    }
}
//最后必须所有结点都访问了，因此vis的元素数量应该为n时才正确
return vis.size()==n;
    }
```

## [1110. 删点成林](https://leetcode.cn/problems/delete-nodes-and-return-forest/)

难度中等199

给出二叉树的根节点 `root`，树上每个节点都有一个不同的值。

如果节点值在 `to_delete` 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。

返回森林中的每棵树。你可以按任意顺序组织答案。

 

**示例 1：**

![image-20230205201236372](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230205201236372.png)

```
输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]
输出：[[1,2,null,4],[6],[7]]
```

------------------

递归法：root.left=dfs root.right=dfs这种模板

```java
 List<TreeNode>ans=new ArrayList<>();
     Set<Integer>set=new HashSet<>();
    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
       if(root==null) return ans;
        for(int i:to_delete)
        set.add(i);
        dfs(root,null);
return ans;
    }
    public TreeNode dfs(TreeNode root,TreeNode parent){
        if(root==null) return null;
       TreeNode left=root.left;
       TreeNode right=root.right;
       if(set.contains(root.val)) root=null;
       else{
           //只有parent为nul时才需要加入，否则就算重复加入了
           if(parent==null) ans.add(root);
          
       }
        TreeNode newleft=dfs(left,root);
           TreeNode newright=dfs(right,root);
           //如果Root不为null,把左右两边连接起来 ，如果root为null,因为前面一步中判断了是否parent为null 此时left和Right也已经加进去了
           if(root!=null) root.left=newleft;
           if(root!=null) root.right=newright;
       return root;
        
    }
```

## [1080. 根到叶路径上的不足节点](https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/)

难度中等75

给定一棵二叉树的根 `root`，请你考虑它所有 **从根到叶的路径**：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）

假如通过节点 `node` 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 `limit`，则该节点被称之为「不足节点」，需要被删除。

请你删除所有不足节点，并返回生成的二叉树的根。

 ![image-20230205210204362](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230205210204362.png)

注意题目意思：是删了叶节点以后剩下的结点不会成为叶节点，而是判断这个结点左边和右边是否有一条路径和>=limit(即，如果一个结点左右两个结点都删了，那么这个结点也是不成立的，当一个结点不是叶子结点的时候，它是否被删除，也要看它的孩子结点，只要孩子结点有一个被保留，父亲结点就不能被删，换句话说，父亲结点被删除当且仅当它的两个孩子结点均被删除；



```java
int lim;
    public TreeNode sufficientSubset(TreeNode root, int limit) {
lim=limit;
if(root==null) return null;
boolean issave= dfs(root,0);
return issave?root:null;
    }
    public boolean dfs(TreeNode root,int sum)
    {
        if(root==null) return false;
        if(root.left==null&&root.right==null)
        {
            return root.val+sum>=lim;
        }
      boolean left=false,right=false;
        if(root.left!=null)
        left=dfs(root.left,sum+root.val);
        if(root.right!=null)
        {
            right=dfs(root.right,sum+root.val);
        }

if(!left)
root.left=null;
if(!right)
root.right=null;
if(!left&&!right){
root=null;
return false;
}

  return left||right;
    }
```



## treeset一些api：[729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/)

#### 

难度中等247

实现一个 `MyCalendar` 类来存放你的日程安排。如果要添加的日程安排不会造成 **重复预订** ，则可以存储这个新的日程安排。

当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 **重复预订** 。

日程可以用一对整数 `start` 和 `end` 表示，这里的时间是半开区间，即 `[start, end)`, 实数 `x` 的范围为，  `start <= x < end` 。

实现 `MyCalendar` 类：

- `MyCalendar()` 初始化日历对象。
- `boolean book(int start, int end)` 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 `true` 。否则，返回 `false` 并且不要将该日程安排添加到日历中。

 ["MyCalendar", "book", "book", "book"]
[[], [10, 20], [15, 25], [20, 30]]
输出：
[null, true, false, true]

-----

最简单的方法是把int[]放在list中，然后每来一个 都去遍历，如果可以，则加入进去

优化：用treeset 按照第一个元素进行排序

d对于新的一个数组，用一个{end,0}来进行判断，看有没有比它大的，如果第一个比它大的就是第一个元素，那么说明第一个元素的start大于end 它一点可以放进去，否则比较第一个比它小的元素 

```java
TreeSet<int[]> booked;

    public MyCalendar() {
        booked = new TreeSet<int[]>((a, b) -> a[0] - b[0]);
    }


    public boolean book(int start, int end) {
          if(booked.isEmpty()){
            booked.add(new int[]{start,end});
            return true;
        }
               int[] tmp = {end, 0};
        int[] arr = booked.ceiling(tmp);
        // /ceiling ()方法用于返回大于或等于给定元素的该集合中的最小元素；如果没有此类元素，则返回null。
//如果booked中的第一个元素==arr,说明booked中最小的数组的第一个元素是end,那么可以放进去，如果比{end,0}小的第一个数组的第二个元素<=start,说明{start,end}可以放在这个数组后面 如果存在end作为第一个元素的数组，则这个数组的第二个元素一定大于end 又因为当前{start,end}最大的就是end,也就是一切比tmp大的数组的start一定大于End 
//lower(E ele)方法用于返回此集合中最大的元素，该元素严格小于给定的元素。
        if(arr==booked.first()||booked.lower(tmp)[1]<=start){
            booked.add(new int[]{start,end});
            return true;
        }
        return false;
  
    }
```

## [ 所有大于等于节点的值之和](https://leetcode.cn/problems/w6cpku/)

难度中等51

给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。

 

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。



二叉搜索树是一棵空树，或者是具有下列性质的二叉树：

若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；

若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；

它的左、右子树也分别为二叉搜索树。

由这样的性质我们可以发现，二叉搜索树的中序遍历是一个单调递增的有序序列。如果我们反序地中序遍历该二叉搜索树，即可得到一个单调递减的有序序列。

方法一：反序中序遍历
思路及算法

本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。

```java
 int sum=0;
    public TreeNode convertBST(TreeNode root) {
if(root==null) return root;

convertBST(root.right);
sum+=root.val;
root.val=sum;
convertBST(root.left);
return root;
    }
```

## [面试题 04.12. 求和路径](https://leetcode.cn/problems/paths-with-sum-lcci/)

难度中等132

给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。

**示例:**
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

返回:

```
3
解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]
```

-----

![image-20230409215541957](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230409215541957.png)

是否要双重递归(即调用根节点的dfs函数后，继续调用根左右节点的pathsum函数)：看题目要不要求从根节点开始的，还是从任意节点开始,因为这道题是可以从任意结点开始，所以需要 

```java
 public int pathSum(TreeNode root, int sum) {
  if (root == null) {
            return 0;
        }

        int ans = getSum(root, sum);
        ans += pathSum(root.left, sum);
        ans += pathSum(root.right, sum);
        return ans;

    }
     public int getSum(TreeNode root, int sum) {
        int ret = 0;

        if (root == null) {
            return 0;
        }
        int val = root.val;
        if (val == sum) {
            ret++;
        } 

        ret += getSum(root.left, sum - val);
        ret += getSum(root.right, sum - val);
        return ret;
    }
```





# 稀疏数组与二维数组的转化

![image-20210909094926646](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210909094926646.png)

```java
public static void main(String[] args) {
// 创建一个原始的二维数组11 * 11
// 0: 表示没有棋子， 1 表示黑子2 表蓝子
int chessArr1[][] = new int[11][11];
chessArr1[1][2] = 1;
chessArr1[2][3] = 2;
chessArr1[4][5] = 2;
    // 将二维数组转稀疏数组的思
// 1. 先遍历二维数组得到非0 数据的个数
int sum = 0;
for (int i = 0; i < 11; i++) {
for (int j = 0; j < 11; j++) {
if (chessArr1[i][j] != 0) {
sum++;
}
}
}
// 2. 创建对应的稀疏数组
int sparseArr[][] = new int[sum + 1][3];
// 给稀疏数组赋值
sparseArr[0][0] = 11;
sparseArr[0][1] = 11;
sparseArr[0][2] = sum;
    // 遍历二维数组，将非0 的值存放到sparseArr 中
int count = 0; //count 用于记录是第几个非0 数据
for (int i = 0; i < 11; i++) {
for (int j = 0; j < 11; j++) {
if (chessArr1[i][j] != 0) {
count++;
sparseArr[count][0] = i;
sparseArr[count][1] = j;
sparseArr[count][2] = chessArr1[i][j];
}
}
}
```

![image-20210909121311502](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210909121311502.png)

# 队列

## 2.通过队列改变一个栈的排列顺序

```++
//通过一个队列把一个栈st 从栈顶到栈底为a2n,a2n-1,...,a1 变为从栈顶到栈底a1,a3,a5...,a2,a4,...a2n
void reassign(stack<int>&st)
{int e;
	queue<int>qu;
	int i, m = st.size();
	for (i = 1; i <= m; i++)
	{
		qu.push(st.top());
		st.pop();
	}
	for (i = 1; i <= m; i++)
	{
		if (i % 2 == 1)//如果i是奇数 则为a2n a2n-2 推入栈， 否则进入队列中
		{
			st.push(qu.front());
			qu.pop();
		}
		else
		{
			qu.push(qu.front());
			qu.pop();
		}
	}
	while(!qu.empty())
	{
		st.push(qu.front());
		qu.pop();
	}
}
```

## 3.//通过一个队列实现约瑟夫问题

```c++
//通过一个队列实现约瑟夫问题
void reassign(int n,int m)
{
	int i, p;
	queue<int>qu;
	for (i = 1; i <= n; i++)
	{
		qu.push(i);

	}
	i = 1;
	while (!qu.empty())
	{
		if (i % m == 0)//如果数到了m就将这个人出队 输出数据 重新从1开始数
		{
			cout << qu.front()<<" ";
			qu.pop();
			i = 1;
			
		}
		else
		{
			i++;
			qu.push(qu.front());//否则将下一个人弹出并再次入队 将进入队尾
			qu.pop();
		}

	}
}
```

c++







```c++
using namespace std;
int grid[8][8] =
{
	{1,1,1,1,1,1,1,1},
	{0,0,0,0,0,1,1,1},
	{1,0,1,1,0,1,1,1},
	{1,0,1,1,0,1,1,1},
	{1,0,1,1,1,1,1,1},
	{1,0,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,1},
	{1,1,1,1,1,1,0,0},
};//0可以走 1不可以走
typedef struct
{
	int i;
	int j;
	int pre;//pre是前驱方块在队列中的位置 从1~N-1
}box;//box是一个方块
int v[4] = {0,1,0,-1 };//水平偏移量
int h[4] = {-1,0,1,0 };//垂直偏移量

bool findpath(int xi, int yi, int xe, int ye)
{//查找从x1 yi到xe ye的路径
	box e;
	box qu[100];//自己设置非循环顺序队
	int front = -1, rear = -1;//设置队头与队尾指针
	int i, j, j1, j2, k,pre,d;
	 e.i = xi; e.j = yi;//入口方块进队
	e.pre = -1;
	rear++;
	qu[rear] = e;
	grid[xi][yi] = -1;//防止重复扫描

	while (rear != front)//队不空时循环
	{
		front++; e = qu[front];
		i = e.i; j = e.j; pre = e.pre;
		if (i == xe && j == ye)//此时到达终点
		{
			d = -1;
			
			box path[100];
			 k = front;
			while (true)//反向搜索路径 存放在path中
			{
				d++;
				path[d].i = qu[k].i;
				path[d].j = qu[k].j;
				if (qu[k].pre == -1) break;
				k = qu[k].pre;
				

			}
			for (k = d; k >= 0; k--)
			{
				if ((k - d) % 6 == 0) cout << endl;
				cout <<"(" <<path[k].i << ","<<path[k].j<<")";
			}
			cout << endl;
			return true;
		}
		else
		{
			for(i = 0;i < 4;i++)			
					if (grid[xi + v[i]][yi + h[i]] == 0 && (xi + v[i])>=0&& (xi + v[i]) < 8 && (yi + h[i])>=0&& (yi + h[i]) < 8)
					{//找到一个可走的相邻方块 即未被扫过可走 且不超过最大下标
						
						e.i = xi + v[i];
						e.j = yi + h[i];
						e.pre = front;
						rear++;
						qu[rear] = e;//将这个新方块进队
						grid[xi + v[i]][yi + h[i]] = -1;//做上标记避免来回搜索
					}
		}


	} 
	return false;

}
int main()
{
	findpath(1, 0, 7, 7);
	
}

```





## [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```java
class MyStack {
Queue<Integer>queue = new LinkedList<>();
Queue<Integer>help = new LinkedList<>();
    public MyStack() {

    }
    
    public void push(int x) {
help.offer(x);
while(!queue.isEmpty())
{
    help.offer(queue.poll());
}
Queue<Integer>temp = help;
help = queue;
queue = temp;
    }
    
    public int pop() {

return queue.poll();
    }
    
    public int top() {
return queue.peek();
    }
    
    public boolean empty() {
return queue.isEmpty();
    }
}
```



# 栈问题/单调栈

单调栈模板：

```java
vector<int> dailyTemperatures(vector<int>& T) {
vector<int> ans(T.size());
stack<int> s; // 这⾥放元素索引，⽽不是元素
for (int i = T.size() - 1; i >= 0; i--) {
while (!s.empty() && T[s.top()] <= T[i]) {
s.pop();
}
ans[i] = s.empty() ? 0 : (s.top() - i); // 得到索引间距
s.push(i); // 加⼊索引，⽽不是元素
}
return ans;
}
```



## 子数组的最小值之和

给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

 

示例 1：

输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。

------



这道题的本质在于找到数组中的**每一个数作为最小值的范围**，比如对于某个数nums[i]能够最小值以这种形式表示：左边连续m个数比nums[i]大，右边连续n个数比nums[i]大。

因此，当前目标是找到每一个数nums[i]的左右两边第一个小于等于的数nums[prev]，这两个数之间的数则均是大于nums[i]，这样便可以计算出m和n。**在一个数组中找左右两边第一个大于、小于、等于的数这种问题可以使用单调栈来解决**

维护一个单调递增栈stk;
当当前数nums[i] <= nums[stk.top()]，触发计算；
因为此时栈顶比栈里栈顶下一个元素大，比当前数大，那么栈顶就是在这两个数之间作为最小值的一个范围
栈顶下一个元素就是前一个比栈顶小的数，当前数就是后一个比栈顶小的元素
**分别计算栈顶元素到前一个小的元素和到后一个小的元素之间有多少元素，这些元素肯定都比栈顶大**

譬如：A=[3,1,2,4,1]，

到下标0的元素3辐射范围为[3]，下标1的元素1辐射范围为[3,1,2,4,1]，下标2的元素2辐射范围为[2,4]，下标3的元素4辐射范围为[4]，下标4的元素1辐射范围为[2,4,1]。

每个元素E=A[i]的辐射范围都是一个连续数组，这个辐射范围内产生的所有子数组最小值都为E，因此E在每个子数组中对答案的贡献值都为E。如果这个辐射范围内的子数组有n个，那么总贡献值为n*E。



```java
 public int sumSubarrayMins(int[] arr) {
Stack<Integer>mystack = new Stack<>();//存储的是索引而不是值
int mod = (int)1e9+7;
long a=0;
for(int i = 0;i <arr.length;i++)
{
while(!mystack.isEmpty() && arr[mystack.peek()]>=arr[i])//如果栈顶元素大于当前元素
{
    int index=mystack.pop();//栈顶表示的索引
    int left = mystack.isEmpty()?-1: mystack.peek();//栈顶的下一个元素
    a=a+  (long) (index-left)*(i-index)*arr[index];
    a %=mod;
}
mystack.add(i);//将这个索引加入栈
}//for循环是为了得到这样一个递增的栈，同时维护a元素
while(!mystack.isEmpty())//目前arr[mystack[最顶部]]到arr[mystack[栈顶]]是递增的了
{
      int index=mystack.pop();//栈顶表示的索引
    int left =mystack.isEmpty()?-1: mystack.peek();//栈顶的下一个元素
    a = a+((long)(index-left)*(arr.length-index)*arr[index]) %mod;
}
return (int)(a%mod);
    }
```

或者也可以这样解：

只要我们向左👈找到第一个比A[i]小的数A[left]以及向右👉找到第一个比E小的数A[right]，就可以确定E的辐射范围为A[left+1:right]。这就叫做下一个更小/更大的数问题。解决这类问题的通用解法即为单调栈。

下面我们具体整理一下求解思路，分为三步：

利用单调栈向左找到第一个比A[i]小的数A[left]（遍历顺序为0->n-1)，也就是E辐射范围的左边界；
利用单调栈向右找到第一个比A[i]小的数A[right]（遍历顺序为n-1->0)，也就是E辐射范围的右边界；
将每个元素的贡献值求和得到最终答案

```java
private static final int MOD = 1000000007;
    public int sumSubarrayMins(int[] arr) {
        // 处理边界情况
        if (arr == null || arr.length == 0) {
            return 0;
        }
        int n = arr.length;
        // 每个元素辐射范围的左边界
        int[] left = new int[n];
        // 每个元素辐射范围的右边界
        int[] right = new int[n];
        Deque<Integer> stack = new LinkedList<>();

        // 第一次循环先找到所有元素的左边界
        for (int i = 0; i < n; i++) {
            // 向左找第一个小于等于E的元素
            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {//这个是大于号，下面是小于等于号，不能错
                stack.pop();
            }
            // 设立一个最左边界-1
            if (stack.isEmpty()) {
                left[i] = -1;
            } else {
                left[i] = stack.peek();
            }
            // 下标入栈，方便同时得到i和A[i]
            stack.push(i);
        }

        // 第二次循环找到所有元素的右边界
        stack.clear();//注意clear方法
        for (int i = n - 1; i >= 0; i--) {
            // 向右找第一个小于E的元素
   while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
    stack.pop();
    }
            // 设立一个最右边界n
            if (stack.isEmpty()) {
                right[i] = n;
            } else {
                right[i] = stack.peek();
            }
            // 下标入栈，方便同时得到i和A[i]
            stack.push(i);
        }

        // 按照贡献度计算即可
        // 注意此处left[i]和right[i]实际上记录的是左边界-1和右边界+1，和上面思路中有些区别，便于计算
        long ans = 0;
        for (int i = 0; i < n; i++) {
            ans = (ans + (long)(i - left[i]) * (right[i] - i) * arr[i]) % MOD; 
        }
        return (int)ans;
    }


```



## [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

难度中等567

给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。

数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

 

**示例 1:**

```
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

----

我们可以使用单调栈解决本题。单调栈中保存的是下标，从栈底到栈顶的下标在数组nums 中对应的值是单调不升的。

每次我们移动到数组中的一个新的位置 i，我们就将当前单调栈中所有对应值小于 nums[i] 的下标弹出单调栈，这些值的下一个更大元素即为 nums[i]（证明很简单：如果有更靠前的更大元素，那么这些位置将被提前弹出栈）。随后我们将位置 i 入栈。

但是注意到只遍历一次序列是不够的，例如序列 \[2,3,1]，最后单调栈中将剩余 \[3,1]，其中元素 \[1] 的下一个更大元素还是不知道的。

一个朴素的思想是，我们可以把这个循环数组「拉直」，即复制该序列的前 n-1个元素拼接在原序列的后面。这样我们就可以将这个新序列当作普通序列，用上文的方法来处理。

**而在本题中，我们不需要显性地将该循环数组「拉直」，而只需要在处理时对下标取模即可。**

```java
  int n = nums.length;
        int[] ret = new int[n];
        Arrays.fill(ret, -1);
        Deque<Integer> stack = new LinkedList<Integer>();
        for (int i = 0; i < n * 2 - 1; i++) {
            while (!stack.isEmpty() && nums[stack.peek()] < nums[i % n]) {
                ret[stack.pop()] = nums[i % n];
            }
            stack.push(i % n);
        }
        return ret;
```





## [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

难度困难703

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

 **提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由数字、`'+'`、`'-'`、`'('`、`')'`、和 `' '` 组成
- `s` 表示一个有效的表达式

```java
 public int calculate(String s) {
char[]arr=s.toCharArray();
Stack<Character>punsta = new Stack<>();
Stack<Integer>numsta=new Stack<>();
int i=0,len=s.length();
numsta.push(1);
int sign=1,ans=0;
while(i<len)
{
    if(s.charAt(i)==' ')
    i++;
    else if(s.charAt(i)=='+')
    {
        sign=numsta.peek();
        i++;
    }
     else   if(s.charAt(i)=='-')
    {
        sign=-numsta.peek();
        i++;
    }
     
   else if(s.charAt(i)=='(')
{
    numsta.push(sign);
    i++;
}
else if(s.charAt(i)==')')
{
    numsta.pop();
    i++;
}
else if(Character.isDigit(s.charAt(i)))
{
    long num=0;
    while(i<len&&Character.isDigit(s.charAt(i)))
    {
num = num*10+s.charAt(i)-'0';
i++;

    }//对于连续的数字123这种，计算整个字符串实际代表的数字
    ans +=sign*num;
}

}
return ans;

    }
```





## 【LeetCode - 772】基本计算器 III

![image-20220811140311492](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220811140311492.png)

 逆波兰计算器的原理是使用逆波兰表达式来计算出表达式的值，我们人类能够熟练使用的是中缀表达式，比如2×(9+6/3-5)+4就是一个中缀表达式，但是看到上面的简单计算器就知道处理起来很麻烦。于是有一种逆波兰计算器，计算是在逆波兰表达式（也叫做后缀表达式）的基础上。
  逆波兰计算器的计算过程为：从左到右扫描后缀表达式，遇到数字就入栈，遇到操作符就从栈弹出两个数字，然后计算得到的值继续入栈，继续扫描表达式，直到扫描完毕得到结果。



现在的难点在于：如何把中缀表达式转成后缀表达式？

  这个过程已经有大神给出来了，我们记下来即可：

  1、初始化两个栈：运算符栈s1和存储中间结果的栈s2；

  2、从左到右扫描中缀表达式；

  3、遇到操作数时，压入到栈s2；

  4、遇到运算符时：

    1）如果s1为空或s1栈顶为左括号"("，则压入到s1；

    2）不满足1），则和s1栈顶运算符比较优先级，高于，则压入s1；

    3）不满足1）和2），弹出s1栈顶运算符并压入到s2，再次回到2）。

  5、遇到右括号")“时，依此弹出s1并压入s2，直到遇到左括号”)"为止，此时丢掉一对括号；

  6、重复2-5，直到扫描完毕；

  7、将s2栈弹出压入到s1，然后s1弹出全部，弹出的顺序即为后缀表达式。



```java
class Solution {
    public int calculate(String s) {
        String expression = s.replaceAll(" ", "");   // 去除空格
        List<String> infix = expressionToList(expression);  // List
        List<String> suffix = infixToSuffix(infix); // 中缀转后缀
        Stack<String> stack = new Stack<>();    // 存储中间结果
        // 逆波兰计算器
        for (int i = 0; i < suffix.size(); i++) {
            String tmp = suffix.get(i);
            if (isOper(tmp)) {
                String num2 = stack.pop();
                String num1 = stack.pop();
                String reuslt = cal(num1, tmp, num2);
                stack.push(reuslt);
            } else { // 数字直接入栈
                stack.push(tmp);
            }
        }
        return Integer.parseInt(stack.pop());
    }
/**
 * num1 和 num2 进行 oper 计算
 *
 * @param num1
 * @param oper
 * @param num2
 * @return
 */
public String cal(String num1, String oper, String num2) {
    Long result = 0l;
    Long a = Long.parseLong(num1);
    Long b = Long.parseLong(num2);
    switch (oper) {
        case "+":
            result = a + b;
            break;
        case "-":
            result = a - b;
            break;
        case "*":
            result = a * b;
            break;
        case "/":
            result = a / b;
            break;
    }
    return String.valueOf(result);
}

/**
 * 中缀转后缀
 *
 * @param infix
 * @return
 */
public List<String> infixToSuffix(List<String> infix) {
    List<String> suffix = new ArrayList<>();
    Stack<String> stack1 = new Stack<>();   // 只用于保存操作符
    Stack<String> stack2 = new Stack<>();   // 用于保存中间结果
    for (int i = 0; i < infix.size(); i++) {
        String tmp = infix.get(i);
        if (isOper(tmp)) {   // 操作符要根据情况来入栈 1
            if (stack1.isEmpty() || "(".equals(tmp)) {
                // 如果 stack1 是空的，或者 tmp 是左括号，直接入栈
                stack1.push(tmp);
            } else { // stack1 不是空的，且 tmp 不是左括号
                if (")".equals(tmp)) {
                    // tmp 是右括号，则把 stack1 遇到左括号之前，全部倒入 stack2
                    while (!"(".equals(stack1.peek())) {
                        stack2.push(stack1.pop());
                    }
                    stack1.pop();   // 丢掉左括号
                } else {
                    // tmp 是 +-*/ 其中之一
                    while (!stack1.isEmpty() && priority(stack1.peek()) >= priority(tmp)) {
                        // 在 tmp 能够碾压 stack1 的栈顶操作符之前，把 stack1 的栈顶操作符倒入 stack 2 中
                        stack2.push(stack1.pop());
                    }
                    // 离开 while 时，要么 stack1 已经倒空了，要么就是现在 tmp 可以压住 stack.peek() 了
                    stack1.push(tmp);
                }
            }
        } else { // 操作数直接入栈 2
            stack2.push(tmp);
        }
    }

    // stack1 剩余操作符全部倒入 stack2
    while (!stack1.isEmpty()) {
        stack2.push(stack1.pop());
    }

    // stack2 的逆序才是结果，所以要再倒一次
    while (!stack2.isEmpty()) {
        stack1.push(stack2.pop());
    }

    // 现在 stack1 的元素倒出来的顺序就是后缀表达式
    while (!stack1.isEmpty()) {
        suffix.add(stack1.pop());
    }

    return suffix;
}

/**
 * 字符串转为中缀 List
 *
 * @param expression
 * @return
 */
public List<String> expressionToList(String expression) {
    List<String> list = new ArrayList<>();
    int len = expression.length();
    String keepNum = "";
    for (int i = 0; i < len; i++) {
        char c = expression.charAt(i);
        if (isNum(c)) {
            if (i != len - 1 && isNum(expression.charAt(i + 1))) {
                // 如果下一个字符也是数字
                keepNum += c;
            } else {
                // 当前是最后一个字符，或者下一个开始不是数字
                keepNum += c;
                list.add(keepNum);
                keepNum = "";
            }
        } else {
            list.add(c + "");
        }
    }
    return list;
}

/**
 * 判断字符 c 是不是数字
 *
 * @param c
 * @return
 */
public boolean isNum(char c) {
    return c >= '0' && c <= '9';
}

/**
 * 判断字符串 str 是不是操作符
 *
 * @param str
 * @return
 */
public boolean isOper(String str) {
    return "+".equals(str) || "-".equals(str) || "*".equals(str) || "/".equals(str) ||
            "(".equals(str) || ")".equals(str);
}

/**
 * 返回操作符的优先级，+- 为 0，* / 为 1
 *
 * @return
 */
public int priority(String oper) {
    if ("+".equals(oper) || "-".equals(oper)) {
        return 0;
    } else if ("*".equals(oper) || "/".equals(oper)) {
        return 1;
    } else {
        return -1;
    }
}
```
如果是含有负数的，那么中缀转后缀改成这样：

```java
 /**
     * 中缀转后缀
     *
     * @param infix
     * @return
     */
    public static List<String> infixToSuffix(List<String> infix) {
        List<String> suffix = new ArrayList<>();
        Stack<String> stack1 = new Stack<>();   // 只用于保存操作符
        Stack<String> stack2 = new Stack<>();   // 用于保存中间结果
        int sign=1;
        for (int i = 0; i < infix.size(); i++) {
            String tmp = infix.get(i);

            if (isOper(tmp)) {
                if(tmp.equals("-")&&i==0){
                    sign=-1;
                    continue;
                }
                if(tmp.equals("-")&&infix.get(i-1).equals("(")) {
                    sign = -1;
                continue;
                }
                // 操作符要根据情况来入栈 1
                if (stack1.isEmpty() || "(".equals(tmp)) {
                    // 如果 stack1 是空的，或者 tmp 是左括号，直接入栈
                    stack1.push(tmp);
                } else { // stack1 不是空的，且 tmp 不是左括号
                    if (")".equals(tmp)) {
                        // tmp 是右括号，则把 stack1 遇到左括号之前，全部倒入 stack2
                        while (!"(".equals(stack1.peek())) {
                            stack2.push(stack1.pop());
                        }
                        stack1.pop();   // 丢掉左括号
                    } else {
                        // tmp 是 +-*/ 其中之一
                        while (!stack1.isEmpty() && priority(stack1.peek()) >= priority(tmp)) {
                            // 在 tmp 能够碾压 stack1 的栈顶操作符之前，把 stack1 的栈顶操作符倒入 stack 2 中
                            stack2.push(stack1.pop());
                        }
                        // 离开 while 时，要么 stack1 已经倒空了，要么就是现在 tmp 可以压住 stack.peek() 了
                        stack1.push(tmp);
                    }
                }
            } else { // 操作数直接入栈 2
                if(sign==-1) {
                    tmp = "-" + tmp;
                sign=1;
                }
                stack2.push(tmp);
            }
        }

        // stack1 剩余操作符全部倒入 stack2
        while (!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }

        // stack2 的逆序才是结果，所以要再倒一次
        while (!stack2.isEmpty()) {
            stack1.push(stack2.pop());
        }

        // 现在 stack1 的元素倒出来的顺序就是后缀表达式
        while (!stack1.isEmpty()) {
            suffix.add(stack1.pop());
        }

        return suffix;
    }
```



## 用后缀表达式作计算器

（1）若取出的字符是操作数，则分析出完整的运算数，该操作数直接送入S2栈。

（2）若取出的字符是运算符，则将该运算符与S1栈栈顶元素比较，如果该运算符(不包括括号运算符)优先级高于S1栈栈顶运算符（包括左括号）优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符（包括左括号）低于（不包括等于）该[运算符优先级](https://baike.baidu.com/item/运算符优先级/4752611)时停止弹出运算符，最后将该运算符送入S1栈。

（3）若取出的字符是“（”，则直接送入S1栈顶。

（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个出栈，依次送入S2栈，此时抛弃“（”。

（5）重复上面的1~4步，直至处理完所有的输入字符。

```java
  
    public int calculate(String s) {
 List<String> expressionList = expressionToList(s);
      
        //将中缀表达式转换为后缀表达式
        List<String> suffixList = parseToSuffixExpression(expressionList);
       
        //根据后缀表达式计算结果
        int calculateResult = calculate(suffixList);
        return calculateResult;
    }
    private static List<String> parseToSuffixExpression(List<String> expressionList) {
        //创建一个栈用于保存操作符
        Stack<String> opStack = new Stack<>();
        //创建一个list用于保存后缀表达式
        List<String> suffixList = new ArrayList<>();
        for(String item : expressionList){
            //得到数或操作符
            if(isOperator(item)){
                //是操作符 判断操作符栈是否为空
                if(opStack.isEmpty() ||"(".equals(opStack.peek())|| priority(item) > priority(opStack.peek())){
                    //为空或者栈顶元素为左括号或者当前操作符大于栈顶操作符直接压栈
                    opStack.push(item);
                }else {
                    //否则将栈中元素出栈如队，直到遇到大于当前操作符或者遇到左括号时
                    while (!opStack.isEmpty() && !"(".equals(opStack.peek())){
                        if(priority(item) <= priority(opStack.peek())){
                            suffixList.add(opStack.pop());
                        }
                         else break;
                    }
                    //当前操作符压栈
                    opStack.push(item);
                }
            }else if(isNumber(item)){
                //是数字则直接入队
                suffixList.add(item);
            }else if("(".equals(item)){
                //是左括号，压栈
                opStack.push(item);
            }else if(")".equals(item)){
                //是右括号 ，将栈中元素弹出入队，直到遇到左括号，左括号出栈，但不入队
                while (!opStack.isEmpty()){
                    if("(".equals(opStack.peek())){
                        opStack.pop();
                        break;
                    }else {
                        suffixList.add(opStack.pop());
                    }
                }
            }
        }
        //循环完毕，如果操作符栈中元素不为空，将栈中元素出栈入队
        while (!opStack.isEmpty()){
            suffixList.add(opStack.pop());
        }
        return suffixList;
    }
    /**
     * 判断字符串是否为操作符
     * @param op
     * @return
     */
    public static boolean isOperator(String op){
        return op.equals("+") || op.equals("-") || op.equals("*") || op.equals("/");
    }

    /**
     * 判断是否为数字
     * @param num
     * @return
     */
    public static boolean isNumber(String num){
        return num.matches("\\d+");
    }

    /**
     * 获取操作符的优先级
     * @param op
     * @return
     */
    public static int priority(String op){
        if(op.equals("*") || op.equals("/")){
            return 1;
        }else if(op.equals("+") || op.equals("-")){
            return 0;
        }
        return -1;
    }
    private static List<String> expressionToList(String expression) {
        int index = 0;
        expression.replaceAll(" ","");
        List<String> list = new ArrayList<>();
        do{
            char ch = expression.charAt(index);
            
             if(ch >= '0' && ch <= '9'){
                //是数字,判断多位数的情况
                String str = "";
                int i = index;
                while (index < expression.length() && expression.charAt(index) >='0' && expression.charAt(index) <= '9'){
                    str += expression.charAt(index);
                    index ++;
                }
                list.add(str);

              //  index++;
            }
           else{

                   index ++ ;
                   list.add(ch+"");

           
            }
        }while (index < expression.length());
        return list;
    }
   int calculate(List<String> list) {
        Stack<Integer> stack = new Stack<>();
        for(int i=0; i<list.size(); i++){
            String item = list.get(i);
            if(item.matches("\\d+")){
                //是数字
                stack.push(Integer.parseInt(item));
            }else {
                //是操作符，取出栈顶两个元素
                int num2 = stack.pop();
                int num1 = stack.pop();
                int res = 0;
                if(item.equals("+")){
                    res = num1 + num2;
                }else if(item.equals("-")){
                    res = num1 - num2;
                }else if(item.equals("*")){
                    res = num1 * num2;
                }else if(item.equals("/")){
                    res = num1 / num2;
                }
                stack.push(res);
            }
        }
        return stack.pop();
    }
```

在只有+-*/时也可以这样：

```java
 public int calculate(String s) {
arr = new char[s.length()];
Deque<Integer>stack=new LinkedList<>();
int num = 0;
    char preSign = '+';
for(int i = 0;i < s.length();i++)
{
if(Character.isDigit(s.charAt(i))) {
                num = num * 10 + s.charAt(i) - '0';
            }
  if (!Character.isDigit(s.charAt(i)) && s.charAt(i) != ' ' || i == s.length()- 1) 
                  {
switch(preSign){

   case '+':
                        stack.push(num);
                        break;
                    case '-':
                        stack.push(-num);
                        break;
                    case '*':
                        stack.push(stack.pop() * num);
                        break;
                    default:
                        stack.push(stack.pop() / num);
                }
                preSign = s.charAt(i);
                num = 0;

                  }
}
 int ans = 0;
        while (!stack.isEmpty()) {
            ans += stack.pop();
        }
        return ans;

    }
```





## [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

难度中等

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

**示例 1：**

```
输入：s = "bcabc"
输出："abc"
```

**示例 2：**

```
输入：s = "cbacdcbc"
输出："acdb"
```

----

思路：用类似单调栈的结果（不一定要使用栈这个数据结构，也可以模拟它）

首先考虑一个简单的问题：给定一个字符串 s，如何去掉其中的一个字符ch，使得得到的字符串字典序最小呢？答案是：找出最小的满足 `s[i]>s[i+1]`的下标 i，并去除字符 s[i]。为了叙述方便，下文中称这样的字符为「关键字符」。

在理解这一点之后，就可以着手本题了。一个直观的思路是：我们在字符串 ss 中找到「关键字符」，去除它，然后不断进行这样的循环。但是这种朴素的解法会创建大量的中间字符串，我们有必要寻找一种更优的方法。

我们从前向后扫描原字符串。每扫描到一个位置，我们就尽可能地处理所有的「关键字符」。假定在扫描位置 s[i−1] 之前的所有「关键字符」都已经被去除完毕，在扫描字符 s[i]时，新出现的「关键字符」只可能出现在 s[i]或者其后面的位置。

于是，我们使用单调栈来维护去除「关键字符」后得到的字符串，单调栈满足栈底到栈顶的字符递增。如果栈顶字符大于当前字符 s[i]，说明栈顶字符为「关键字符」，故应当被去除。去除后，新的栈顶字符就与 s[i]相邻了，我们继续比较新的栈顶字符与 s[i]的大小。重复上述操作，直到栈为空或者栈顶字符不大于s[i]。

我们还遗漏了一个要求：原字符串 s 中的每个字符都需要出现在新字符串中，且只能出现一次。为了让新字符串满足该要求，之前讨论的算法需要进行以下两点的更改。

在考虑字符 s[i]时，`如果它已经存在于栈中，则不能加入字符 s[i]。为此，需要记录每个字符是否出现在栈中。`

在弹出栈顶字符时，如果字符串在后面的位置上再也没有这一字符，则不能弹出栈顶字符。`为此，需要记录每个字符的剩余数量`，当这个值为 0 时，就不能弹出栈顶字符了。



```java
public String removeDuplicateLetters(String s) {
boolean[]vis =new boolean[26];
int[]num=new int[26];
for(int i=0;i<s.length();i++)
num[s.charAt(i)-'a']++;//统计每个字符出现次数
StringBuilder str = new StringBuilder();//其实是用这个字符串模拟了类似栈的结构
for(int i=0;i<s.length();i++)
{
    char ch = s.charAt(i);
    if(!vis[s.charAt(i)-'a'])
    {
        while(str.length()>0&&str.charAt(str.length()-1)>ch)
        {
            if(num[str.charAt(str.length()-1)-'a']>0){
            vis[str.charAt(str.length()-1)-'a']=false;
            str.deleteCharAt(str.length()-1);//如果栈顶的字符大于目前的字符且栈顶字符的出现次数大于1则移除
            }//这里str.charAt(str.length()-1)就是栈顶
            else break;
        }
            vis[s.charAt(i)-'a']=true;
            str.append(s.charAt(i));
    }

    num[ch-'a']--;
}
return str.toString();
    }
```



## [678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/)

难度中等446

给定一个只包含三种字符的字符串：`（ `，`）` 和 `*`，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

1. 任何左括号 `(` 必须有相应的右括号 `)`。
2. 任何右括号 `)` 必须有相应的左括号 `(` 。
3. 左括号 `(` 必须在对应的右括号之前 `)`。
4. `*` 可以被视为单个右括号 `)` ，或单个左括号 `(` ，或一个空字符串。
5. 一个空字符串也被视为有效字符串。

----


```java
    public boolean checkValidString(String s) {
        Stack<Integer>stak1=new Stack<>();
        Stack<Integer>st2= new Stack<>();
        for(int i=0;i<s.length();i++)
        {
            if(s.charAt(i)=='(')
            stak1.push(i);
            else if(s.charAt(i)=='*')
            st2.push(i);
            else{
                if(!stak1.isEmpty())
                {
                    stak1.pop();

                }
                else
                {if(!st2.isEmpty())
                st2.pop();
                else return false;
                }
            }
        }
        while(!stak1.isEmpty()&&!st2.isEmpty())
        {
            int index1=stak1.peek();
            stak1.pop();
            int index2=st2.peek();
            st2.pop();
            if(index1>index2) return false;
        }
 return stak1.isEmpty();
//return true;
    }
```



## [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

难度困难1645

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

 

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

----

![image-20220211125716554](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220211125716554.png)

```java
   public int longestValidParentheses(String s) {
char[]arr = s.toCharArray();
int count=0;
if(s.length()==0||s.length()==1) return count;
 Deque<Integer>mysta = new LinkedList<>();
mysta.push(-1);//注意这里先添加了-1这个元素，所以最后的长度只需要求i-mysta.peek()
for(int i = 0;i<arr.length;i++)
{
    if(arr[i]==')')
    {
        mysta.pop();
     if(mysta.isEmpty())
     {
         mysta.push(i);
     }
     else{
         count = Math.max(count,i-mysta.peek());
     }
        
    }
    else   {
        mysta.push(i);
    }
}
return count;
    }
```



## [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

难度困难

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

![image-20220212133015124](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220212133015124.png)

----

![image-20220212133625874](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220212133625874.png)

这样以来，我们得到它们左侧的柱子编号分别为 [-1, 0, -1, -1, 3, 4, 5, 3][−1,0,−1,−1,3,4,5,3]。用相同的方法，我们从右向左进行遍历，也可以得到它们右侧的柱子编号分别为 [2, 2, 3, 8, 7, 7, 7, 8][2,2,3,8,7,7,7,8]，这里我们将位置 8 看作「哨兵」。

在得到了左右两侧的柱子之后，我们就可以计算出每根柱子对应的左右边界，并求出答案了。

```java
    public int largestRectangleArea(int[] heights) {
int[]left= new int[heights.length];
int[]right= new int[heights.length];
Deque<Integer>queue = new ArrayDeque<>();
//queue.push(-1);
for(int i =0;i < heights.length;i++)
{
    while(!queue.isEmpty()&&heights[queue.peek()]>=heights[i])//注意是大于等于
    queue.pop();
left[i] = queue.isEmpty()?-1:queue.peek();//-1实际上是哨兵结点，表示左边没有元素了
queue.push(i);
}
queue.clear();
for(int i = heights.length-1;i>=0;i--)
    {
        while(!queue.isEmpty() && heights[queue.peek()]>= heights[i])
        queue.pop();
       right[i] =( queue.isEmpty()?heights.length:queue.peek());
queue.push(i);
    }
    int max=0;
    for(int i =0;i < heights.length;i++)
{
    int temp = (right[i] - left[i]-1)*heights[i];
max = Math.max(max,temp);
}
return max;
    }
```

## [456. 132 模式](https://leetcode-cn.com/problems/132-pattern/)

难度中等631

给你一个整数数组 `nums` ，数组中共有 `n` 个整数。**132 模式的子序列** 由三个整数 `nums[i]`、`nums[j]` 和 `nums[k]` 组成，并同时满足：`i < j < k` 和 `nums[i] < nums[k] < nums[j]` 。

如果 `nums` 中存在 **132 模式的子序列** ，返回 `true` ；否则，返回 `false` 。

---

![image-20220321005929599](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220321005929599.png)

```java
//要找到某个元素A左边小于它的值和右边小于它的值，且需要保存右边小于A的所有值中的最大值，因为左边小于A的值要小于右边小于A的值
public boolean find132pattern(int[] nums) {
        if(nums.length <3) return false;
 Deque<Integer> candidateK = new LinkedList<Integer>();
        candidateK.push(nums[nums.length - 1]);
        int maxK = Integer.MIN_VALUE;
for(int i = nums.length-2;i>=0;i--)
{
    if(nums[i] < maxK) return true;
    while(!candidateK.isEmpty() && nums[i] > candidateK.peek())
    {
       maxK= candidateK.pop();//维护一个被移除的元素中的最大值
    
    }    
    if(nums[i] > maxK)//如果新的被遍历的元素大于之前被移除的元素的最大值，则将其放入队列中 
    candidateK.push(nums[i]);
}
return false;
    }
```

## 链表实现栈

1.当要push的时候，相当于新new一个头结点，然后让新节点指向单链表的头结点。以新节点作为单链表的头节点即可。

2.当要pop的时候，只要将链表的头指针后移到它的next，将next作为新的头结点即可

3.当要peak的时候，只要返回头结点的值就好了

```java
/**
/**
 * 用单链表实现栈
 * 
 * 表示链表的一个节点
 * @author ly
 *
 */
public class Node {
	
	Object element;
	Node next;
	
	public Node(Object element){
		this(element,null);
	}
	
	/**
	 * 创建一个新的节点
	 * 让他的next指向，参数中的节点
	 * @param element
	 * @param n
	 */
	public Node(Object element,Node n){
		this.element=element;
		next=n;
	}
	
	public Object getElement() {
		return element;
	}
	
}
/**
 * 用链表实现的栈，内含push pop peak 方法
 * @author ly
 *
 */
public class ListStack {
	
	Node header;//栈顶元素
	int elementCount;//栈内元素个数
	int size;//栈的大小
	
	/**
	 * 构造函数，构造一个空的栈
	 */
	public ListStack(){
		header=null;
		elementCount=0;
		size=0;
	}
	
	/**
	 * 通过构造器自定义栈的大小
	 * @param size
	 */
	public ListStack(int size) {
		header=null;
		elementCount=0;
		this.size=size;
	}
	
	public void setHeader(Node header) {
		this.header=header;
	}
	
	public boolean isFull() {
		if (elementCount==size) {
			return true;
		}
		
		return false;
	}
	
	public boolean isEmpty() {
		if (elementCount==0) {
			return true;
		}
		
		return false;
	}
	
	/**
	 * 入栈
	 * @param value
	 */
	public void push(Object value) {
		if (this.isFull()) {
			throw new RuntimeException("Stack is Full");
		}
		//注意这里面试将原来的header作为参数传入，然后以新new出来的Node作为header
		header=new Node(value, header);
		elementCount++;
	}
	
	/**
	 * 出栈
	 * @return
	 */
	public Object pop() {
		if (this.isEmpty()) {
			throw new RuntimeException("Stack is empty");
		}
		Object object=header.getElement();
		
		header=header.next;
		
		elementCount--;
		
		return object;
	}
	
	/**
	 * 返回栈顶元素
	 */
	public Object peak(){
		
		if (this.isEmpty()) {
			throw new RuntimeException("Stack is empty");
		}
		
		return header.getElement();
	}
 

```

## 双栈排序

给定一个乱序的栈，设计算法将其升序排列。

ps: 允许额外使用一个栈来辅助操作 

> 输入
> [4, 2, 1, 3]
> 输出
> [1, 2, 3, 4]

------

代码：

```java
  public Stack<Integer> stackSort(Stack<Integer> stk) {
       Stack<Integer> temp = new Stack<Integer>();
    
       while(!stk.isEmpty()) {
           int num = stk.pop();
           while (!temp.isEmpty() && temp.peek() > num) {
               int t = temp.pop();//辅助栈中的元素弹出
               stk.push(t);//再放入原栈中去
               
           }
           temp.push(num);
       }
       return temp;//返回辅助栈即可。总体思路：比较Temp栈顶与原栈的栈顶，如果前者数字更大，
       // 则放到原栈中去，再把原栈中那个更小的压入到辅助栈中，注意是一开始用一个变量t存储了原栈的栈顶元素
   }
```

## [735. 行星碰撞](https://leetcode.cn/problems/asteroid-collision/)

难度中等346

给定一个整数数组 `asteroids`，表示在同一行的行星。

对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。

找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。

 

**示例 1：**

```
输入：asteroids = [5,10,-5]
输出：[5,10]
解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。
```

**示例 2：**

```
输入：asteroids = [8,-8]
输出：[]
解释：8 和 -8 碰撞后，两者都发生爆炸。
```

---------------

用栈 \textit{st}st 模拟行星碰撞，从左往右遍历行星数组 \textit{asteroids}asteroids，当我们遍历到行星 \textit{aster}aster 时，使用变量}alive 记录行星aster 是否还存在（即未爆炸）。

当行星 aster 存在且 aster<0，栈顶元素非空且大于 0 时，说明两个行星相互向对方移动：如果栈顶元素大于等于−aster，则行星 aster 发生爆炸，将 alive 置为false；如果栈顶元素小于等于−aster，则栈顶元素表示的行星发生爆炸，执行出栈操作。重复以上判断直到不满足条件，如果最后alive 为真，说明行星aster 不会爆炸，则将 aster 入栈。



```java
   public int[] asteroidCollision(int[] asteroids) {
Deque<Integer>stack = new ArrayDeque<>();
for(int anstor:asteroids){
boolean alive = true;
while(alive && anstor<0&& !stack.isEmpty() && stack.peek() > 0){
    alive = stack.peek()<-anstor;
    if(stack.peek()<=-anstor){
     
        stack.pop();
    }
}
if(alive) stack.push(anstor);

}
int[]ans = new int[stack.size()];
for(int i =stack.size()-1;i >=0;i--)
ans[i] = stack.pop();
return ans;
    }
```

## [331. 验证二叉树的前序序列化](https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/)

难度中等400

序列化二叉树的一种方法是使用 **前序遍历** 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 `#`。

![image-20220820163903092](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220820163903092.png)

例如，上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。

你可以认为输入格式总是有效的

例如它永远不会包含两个连续的逗号，比如 "1,,3" 。
注意：不允许重建树。



----------------

简单方法：

```java
    public boolean isValidSerialization(String preorder) {
String[]arr=preorder.split(",");
int tot = 1;
for(int i = 0;i < arr.length;i++){
tot--;
if(tot<0) return false;
if(!arr[i].equals("#"))
tot+=2;
}
return tot==0;
    }
```





另外的方法：栈
我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。

二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：

如果遇到了空节点，则要消耗一个槽位；

如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。

此外，还需要将根节点作为特殊情况处理。

我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处剩余槽位的数量，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减 1；当遇到非空节点时，将栈顶元素减 1 后，再向栈中压入一个 2。无论何时，如果栈顶元素变为 0，就立刻将栈顶弹出。

遍历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。



```java
  public boolean isValidSerialization(String preorder) {
Deque<Integer>queue = new LinkedList<>();
queue.push(1);
int len = preorder.length();
int i = 0;
while(i <len){
    if(queue.isEmpty()){
        return false;
    }
    if(preorder.charAt(i)==',') {

            i++;
    }
    else if(preorder.charAt(i)=='#'){
        int top = queue.poll()-1;
        if(top >0)
            queue.push(top);
            i++;
    }
    else{
        while(i <len && preorder.charAt(i)!=',')//可能出现数字位数超过1位的情况，比如123
        i++;
        int top = queue.pop()-1;//占用的槽位减去一个，但还要加两个槽位

        if(top>0){
            queue.push(top);
        }
        queue.push(2);
        i++;
    }
}
return queue.isEmpty();
    }
```



## [1673. 找出最具竞争力的子序列](https://leetcode.cn/problems/find-the-most-competitive-subsequence/)

难度中等102

给你一个整数数组 `nums` 和一个正整数 `k` ，返回长度为 `k` 且最具 **竞争力** 的 `nums` 子序列。

数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。

在子序列 `a` 和子序列 `b` 第一个不相同的位置上，如果 `a` 中的数字小于 `b` 中对应的数字，那么我们称子序列 `a` 比子序列 `b`（相同长度下）更具 **竞争力** 。 例如，`[1,3,4]` 比 `[1,3,5]` 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， `4` 小于 `5` 。

 

**示例 1：**

```
输入：nums = [3,5,2,6], k = 2
输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。
```

-----------------------

要尽可能地让前面的元素最小，然后后面的元素也要最小，同时需要满足答案数组的个数为k 不能小于k（比如如果原数组最小的元素是最后一个，但是k>1，那么最小的元素不能作为第一个元素）

采用单调栈，这里一个关键注意是不能弹出过多的元素，否则剩余的元素无法填满，那么会导致结果的数组个数小于k

```java
 public int[] mostCompetitive(int[] nums, int k) {
Deque<Integer>stack=new ArrayDeque<>();
//remain可以理解为最多能弹出的个数
int remain=nums.length-k;
for(int i = 0;i<nums.length;i++)
{
   if(stack.isEmpty())
   stack.push(nums[i]);
   else{
        //注意关键细节：需要判断剩余元素的数量是否能填满
        //如果remain>0且栈顶元素大于当前元素 弹出
        while(!stack.isEmpty()&& nums[i]<stack.peek()&& remain>0){
stack.pop();
        remain--;
  }
  stack.push(nums[i]);
   }
}
//注意：如果栈内的元素大于k 需要弹出多余的，比如为1 2 3 4的时候会一直入栈，这样就弹出后面的元素 后面的元素刚好也是更大的元素 因为remain+k=nums.length
for(int i = 0;i<remain;i++)
stack.pop();
int[]ans=new int[k];
for(int i =k-1;i>=0;i--)
ans[i]=stack.pop();
return ans;
    }
```

## [726. 原子的数量](https://leetcode.cn/problems/number-of-atoms/)

难度困难281

给你一个字符串化学式 `formula` ，返回 **每种原子的数量** 。

原子总是以一个大写字母开始，接着跟随 0 个或任意个小写字母，表示原子的名字。

如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。

- 例如，`"H2O"` 和 `"H2O2"` 是可行的，但 `"H1O2"` 这个表达是不可行的。

两个化学式连在一起可以构成新的化学式。

- 例如 `"H2O2He3Mg4"` 也是化学式。

由括号括起的化学式并佐以数字（可选择性添加）也是化学式。

- 例如 `"(H2O2)"` 和 `"(H2O2)3"` 是化学式。

返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。

--------------------------

对于括号序列相关的题目，通用的解法是使用递归或栈。本题中我们将使用栈解决。

从左到右遍历该化学式，并使用哈希表记录当前层遍历到的原子及其数量，因此初始时需将一个空的哈希表压入栈中。对于当前遍历的字符：

如果是左括号，将一个空的哈希表压入栈中，进入下一层。

如果不是括号，则读取一个原子名称，若后面还有数字，则读取一个数字，否则将该原子后面的数字视作 1。然后将原子及数字加入栈顶的哈希表中。

如果是右括号，则说明遍历完了当前层，若括号右侧还有数字，则读取该数字 num，否则将该数字视作 1。然后将栈顶的哈希表弹出，将弹出的哈希表中的原子数量与 num 相乘，加到上一层的原子数量中。



```java
int i = 0;
int n;
String formula;
    public String countOfAtoms(String formula) {
char[] arr=formula.toCharArray();
this.formula=formula;
this.n=formula.length();
TreeMap<String,Integer>map=new TreeMap<>();
Stack<Map<String,Integer>>stack=new Stack<>();
 stack.push(new HashMap<>());
while(i<arr.length)
{
  if(arr[i]=='('){
      i++;
        stack.push(new HashMap<>());
  }

  else if(arr[i]==')'){
      i++;
      int num=parseNum();
      Map<String,Integer>topMap=stack.pop();
      Map<String,Integer>stay=stack.peek();
       for (Map.Entry<String, Integer> entry : topMap.entrySet()) {
                    String atom = entry.getKey();
                    int v = entry.getValue();
                    stay.put(atom, stay.getOrDefault(atom, 0) + v * num); // 将括号内的原子数量乘上 num，加到上一层的原子数量中
                }
  }
  else{
      String letter=parseAtom();
      int num=parseNum();
      Map<String,Integer>topMap=stack.peek();
      topMap.put(letter,topMap.getOrDefault(letter,0)+num);
  }
}
StringBuilder ans=new StringBuilder();
map=new TreeMap<>(stack.pop());
for(Map.Entry<String,Integer>entry:map.entrySet()){
    if(entry.getValue()!=1)
    ans.append(entry.getKey()).append(entry.getValue());
else{
    ans.append(entry.getKey());
}
}
return ans.toString();
    }
     public String parseAtom() {
        StringBuffer sb = new StringBuffer();
        sb.append(formula.charAt(i++)); // 扫描首字母
        while (i < n && Character.isLowerCase(formula.charAt(i))) {
            sb.append(formula.charAt(i++)); // 扫描首字母后的小写字母
        }
        return sb.toString();
    }

    public int parseNum() {
        if (i == n || !Character.isDigit(formula.charAt(i))) {
            return 1; // 不是数字，视作 1
        }
        int num = 0;
        while (i < n && Character.isDigit(formula.charAt(i))) {
            num = num * 10 + formula.charAt(i++) - '0'; // 扫描数字
        }
        return num;
    }
```



# 模拟队列

因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front 及rear 分别记录队列前后端的下标，front 会随着数据输出而改变，而rear 则是随着数据输入而改变，

当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析
1) 将尾指针往后移：rear+1 , 当front == rear 【空】
2) 若尾指针rear 小于队列的最大下标maxSize-1，则将数据存入rear 所指的数组元素中，否则无法存入数据。
rear == maxSize - 1[队列满]

```java
// 使用数组模拟队列-编写一个ArrayQueue 类
class ArrayQueue {
private int maxSize; // 表示数组的最大容量
private int front; // 队列头
private int rear; // 队列尾
private int[] arr; // 该数据用于存放数据, 模拟队列
// 创建队列的构造器
public ArrayQueue(int arrMaxSize) {
maxSize = arrMaxSize;
arr = new int[maxSize];
front = -1; // 指向队列头部，分析出front 是指向队列头的前一个位置.
    rear = -1; // 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)
}
// 判断队列是否满
public boolean isFull() {
return rear == maxSize - 1;
    }
// 判断队列是否为空
public boolean isEmpty() {
return rear == front;
}
// 添加数据到队列
public void addQueue(int n) {
// 判断队列是否满
if (isFull()) {
System.out.println("队列满，不能加入数据~");
return;
}
rear++
    arr[rear] = n;
}
// 获取队列的数据, 出队列
public int getQueue() {
// 判断队列是否空
if (isEmpty()) {
// 通过抛出异常
throw new RuntimeException("队列空，不能取数据");
}
front++; //front后移
    arr[rear] = n;
}
// 获取队列的数据, 出队列
public int getQueue() {
// 判断队列是否空
if (isEmpty()) {
// 通过抛出异常
throw new RuntimeException("队列空，不能取数据");
}
front++; //判断
if (isEmpty()) {
throw new RuntimeException("队列空的，没有数据~~");
}
return arr[front + 1];
}
}
```







# 大数运算



数组模拟数字进行大数运算

因为int类型的数字有长度限制，超过一定数后表示不出来了，所以在大数中可以使用数组表示

如一个阶乘运算：

```java
  public static void jiecheng(int n)
    {
        int[]ints = new int[20];//足够大的数组
        ints[ints.length-1] = 1;
        for(int i = 1;i <= n;i++)
        {
             demo(ints,i);
        }
        for(int i = 0;i < ints.length;i++)
        {
            System.out.print(ints[i]);
        }
    }
    public static void demo(int []ints,int number)
    {
        for(int i = 0;i < ints.length;i++)
        {
            ints[i]*=number;
        }
        //进位和余位
        for(int i = ints.length-1;i>0;i--)
        {
            int carry = ints[i]/10;
            ints[i] = ints[i] % 10;
            ints[i-1] = ints[i-1]+carry;
        }
       
    }
    public static void main(String[] args) throws InterruptedException {
        jiecheng(5);
    }
```

## 两个大数相加



 1、是整数； 2、两个数无限大，long都装不下； 3、不能用BigInteger； 4、不能用任何包装类提供的运算方法； 5、两个数都是以字符串的方式提供。

/**
     * 思路：
          * 字符串逐位相加，需要进位则进位处理，考虑两个问题：
          * 1、char怎么转换为integer, 减去'0'即可
               * 2、怎么处理对应位相加?反转字符串相加，正确处理进位即可，
             *    这样个位对应个位，十位对应十位，剩余的直接追加   */

```java
public static String add(String str1, String str2) {
    char[]arr1 = new StringBuilder(str1).reverse().toString().toCharArray();
    char[]arr2 =  new StringBuilder(str2).reverse().toString().toCharArray();
    int maxlen = arr1.length>arr2.length?arr1.length:arr2.length;
    int [] newlen = new int[maxlen+1];
    for (int i = 0; i < maxlen; i++) {
        int an1 = i < arr1.length?arr1[i]-'0':0;
        int an2 = i < arr2.length?arr2[i]-'0':0;
        newlen[i] = an1+an2;
    }
    for (int i = 0; i < newlen.length; i++)
    {
        if(newlen[i] >= 10)
        {
            newlen[i+1] += newlen[i]/10;
            newlen[i] %=10;

        }
    }
    StringBuilder ans = new StringBuilder();
    for (int i = newlen.length-1; i >=0;i--) {
        ans.append(newlen[i]);
    }
    if(ans.toString().charAt(0)=='0')
    {
        return ans.toString().substring(1,ans.length());//去掉开头可能有的0
    }
    return ans.toString();

}
public static void main(String[] args) {
    System.out.println(  add("9234","22999999999"));
}
```



## 大数乘法

（字符串相乘）

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

----

```java
   public String multiply(String num1, String num2) {
LinkedList<Integer>temp =  new LinkedList<>();
if(num2.equals("0")||num1.equals("0")) return "0";
int[]ans = new int[num1.length()+num2.length()];
for(int i = num1.length()-1;i>=0;i--)
{
    for(int j = num2.length()-1;j>=0;j--)
    {
        int digi1 = num1.charAt(i)-'0';
        int digi2 = num2.charAt(j)-'0';
        int tot = ans[i+j+1]+digi1*digi2;
        ans[i+j+1]=tot%10;
        ans[i+j] += tot/10;
     }
}
String ut ="";
boolean flag = true;
for(int i = 0;i < ans.length;i++)
{
    if(ans[i]==0&&flag)
    continue;
    flag = false;
    if(!flag)
ut+=ans[i];
}
return ut;
    }
```





# 特殊的算法

## 100亿数据找出最大的1000个数字

这是互联网领域一个比较经典的算法问题（top k），如何在巨大的数据中找出最大，或者访问量最高的前10个，前100个或者前1000个数据。比如在2亿用户记录中找出信用等级最高的，在上亿个搜索词汇中找出被搜索次数最高的10个关键字。前提是数据存储在文件中

一般遇到这个问题，第一反应会想到排序，但是稍微对内存有点了解的人立刻都会否定这个答案，大量的数据导入内存且不说内存够不够，就算足够服务器上其他的服务都不需要内存了吗？那么接下来的思路就是，如果不允许全部导入内存，还要找出最大的1000个数字，那就要用到外部排序（选择）的算法了。

解决的思路有下面几个：

1.采用小顶堆算法，我们知道完全二叉树有几个非常重要的特性，就是假如该二叉树中总共有N个节点，那么该二叉树的深度就是log2N，对于小顶堆来说移动根元素到 底部或者移动底部元素到根部只需要log2N，相比N来说时间复杂度优化太多了（1亿的logN值是26-27的一个浮点数）。基本的思路就是先从文件中取出1000个元素构建一个小顶堆数组k，然后依次对剩下的100亿-1000个数字进行遍历m，如果m大于小顶堆的根元素，即k[0]，那么用m取代k[0]，对新的数组进行重新构建组成一个新的小顶堆。这个算法的时间复杂度是O((100亿-1000)log(1000))，即O((N-M)logM)，空间复杂度是M

这个算法优点是性能尚可，空间复杂度低，IO读取比较频繁，对系统压力大。

2.采用分区法，将100亿个数据分成1000个分区，每个分区上1000万个数据，在每个分区上上再细分成100个分区，即总共分成1000*100个分区，然后启动多线程进行处理，各个分区上采用小顶堆算法取出最大的1000个数据，分层进行合并然后重新计算不同层上的最大1000个数，最终递归到最上层。但linux系统上一个进程能启动的默认线程数是1024个，所以要么调整最大线程数，要么在线程调用处做一些处理，比如一个线程完成一个分区之后再去处理相邻的分区，或者在分区的时候把所有的分区数目限制在1024之内。这个算法切合了map-reduce的思想，利用了多线程和多处理器的优势，减少了多余的比较和IO读取，性能比第一种会更好但算法更复杂一点，要考虑的情况也更多。



## 快慢指针找数组中重复数字



---

数组形式的链表
题目设定的问题是 N+1 个元素都在 [1,n] 这个范围内。这样我们可以用那个类似于 ‘缺失的第一个正数’ 这种解法来做，但是题意限制了我们不能修改原数组，我们只能另寻他法。也就是本编题解讲的方法，将这个题目给的特殊的数组当作一个链表来看，数组的下标就是指向元素的指针，把数组的元素也看作指针。如 0 是指针，指向 nums[0]，而 nums[0] 也是指针，指向 nums[nums[0]].
这样我们就可以有这样的操作

int point = 0;
while(true){
    point = nums[point]; // 等同于 next = next->next; 
}

链表中的环
假设有这样一个样例：[1,2,3,4,5,6,7,8,9,5]。如果我们按照上面的循环下去就会得到这样一个路径: 1 2 3 4 5 [6 7 8 9] [6 7 8 9] [6 7 8 9] . . .这样就有了一个环，也就是6 7 8 9。point 会一直在环中循环的前进。
这时我们设置两个一快(fast)一慢(slow)两个指针，一个每次走两步，一个每次走一步，这样让他们一直走下去，直到他们在重复的序列中相遇，

```java
int fast = 0, slow = 0;
while(true){
    fast = nums[nums[fast]];
    slow = nums[slow];
    if(fast == slow)
        break;
}
```

如上图，slow和fast会在环中相遇，先假设一些量：起点到环的入口长度为m，环的周长为c，在fast和slow相遇时slow走了n步。则fast走了2n步，fast比slow多走了n步，而这n步全用在了在环里循环（n%c==0）。


如上图，slow和fast会在环中相遇，先假设一些量：起点到环的入口长度为m，环的周长为c，在fast和slow相遇时slow走了n步。则fast走了2n步，fast比slow多走了n步，而这n步全用在了在环里循环（n%c==0）。
当fast和last相遇之后，我们设置第三个指针finder，它从起点开始和slow(在fast和slow相遇处)同步前进，当finder和slow相遇时，就是在环的入口处相遇，也就是重复的那个数字相遇。

为什么 finder 和 slow 相遇在入口
fast 和 slow 相遇时，slow 在环中行进的距离是n-m，其中 n%c==0。这时我们再让 slow 前进 m 步——也就是在环中走了 n 步了。而 n%c==0 即 slow 在环里面走的距离是环的周长的整数倍，就回到了环的入口了，而入口就是重复的数字。
我们不知道起点到入口的长度m，所以弄个 finder 和 slow 一起走，他们必定会在入口处相遇。



```java
public int findDuplicate(int[] nums) {

int len=nums.length;
//1-len+1之间
int slow=0,fast=0;
do{
slow=nums[slow];
fast=nums[nums[fast]];
}while(slow!=fast);
slow=0;
do{
    slow=nums[slow];
    fast=nums[fast];
}while(slow!=fast);
return slow;
    }
```



## 左程云：从左往右的尝试模型

![image-20211206105757500](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20211206105757500.png)

```java
public static int convert(string str)
{
    if(str == null ||str,length == 0)
        return 0;
    return process(str.toCharAr,0);//i从0开始
}
public int process(char[] str,int i)
{
    if(i == str.length)
return 1;//直接返回
        if(str[i] == '0')
        return 0;
    if(str[i] == '1')
    {
        int res = process(str,i+1);//i自己作为单独的部分，后续有多少种方法
        if(i + 1 < str.length)
        {
res+=process(str,i+2);//i和i+1作为单独的部分，后续有多少种方法
        }
        return res;
    }
    if(Str[i] == '2')
    {
        int res = process(str,i+1i自己作为单独的部分
      if(i+1 <str.length && (str[i+1] >='0' && str[i+1] <= '6'))//最高26个字母，所以i为2时i+1最高只有26个
        {
            res+=process(str,i+2);
        }
        return res;
    }
                          //其他的情况str[i]!=1且!=2
    return process(str,i+1);//如果str[i] == '3' ~'9'的话
}
```

## [135. 分发糖果](https://leetcode-cn.com/problems/candy/)

难度困难751

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

 

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

-----

![image-20220209171206392](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220209171206392.png)

## [168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

难度简单492

给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。

例如：

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

 

**示例 1：**

```
输入：columnNumber = 1
输出："A"
```

------

```java
class Solution {
    public String convertToTitle(int columnNumber) {
char[]arr= new char[]{'0','A','B','C','D','E','F','G','H','I','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
StringBuilder ans=new StringBuilder();
while(columnNumber!=0)
{
    --columnNumber;//要先减一才行
    int i=(columnNumber-1)%26;
  //  ans+=arr[i];
  ans.append((char)(columnNumber%26+'A'));//注意这里char后面的内容要加括号，不然最后结果都是数字
    columnNumber/=26;

}
return ans.reverse().toString();
    }
}
```

## 杨辉三角

```java
 public List<List<Integer>> generate(int numRows) {

List<List<Integer>> mylist= new LinkedList<>();
for(int i=0;i<numRows;i++){
List<Integer>temp = new LinkedList<>();

for(int j=0;j<i+1;j++)
{
  if(j==0||j==i) temp.add(1);
  else
  temp.add(mylist.get(i-1).get(j-1)+mylist.get(i-1).get(j));
}
mylist.add(temp);

}
return mylist;

  }
```

## 原地交换法找出数组中某个重复元素

![image-20220211020645527](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220211020645527.png)

代码：

```java
    public int findRepeatNumber(int[] nums) {
int i = 0;
while(i < nums.length)
//注意，这里用for循环会出错
{
    if(nums[i]==i) {i++;continue;}
     if(nums[nums[i]]==nums[i]) return nums[i];
    int temp = nums[i];
    nums[i] = nums[temp];
    nums[temp] = temp;
   
}
return -1;
    }
```



## [57. 插入区间（合并区间）](https://leetcode-cn.com/problems/insert-interval/)

难度中等549

给你一个 **无重叠的** *，*按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

 

**示例 1：**

```
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
```

----

![image-20220211025554083](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220211025554083.png)



```java
   public int[][] insert(int[][] intervals, int[] newInterval) {
 int left = newInterval[0],right = newInterval[1];
 List<int[]>temp = new ArrayList<>();
 boolean flag = false;
 for(int[]interval:intervals)
 {
   if(right < interval[0])
   {
       if(!flag)
       {
           temp.add(new int[]{left,right});
           flag = true;
       }
       temp.add(interval);
   }
   else if(left > interval[1])
   {
       temp.add(interval);
   }
   else
   {
       left = Math.min(left,interval[0]);
       right = Math.max(right,interval[1]);
     //  temp.add(new int[min,max]);
   }
 }
 if(!flag)
 temp.add(new int[]{left,right});
 int[][] ans = new int[temp.size()][2];
 for(int i = 0;i <temp.size();i++)
 ans[i] = temp.get(i);
       //也可以这样写：temp.toArray(new int[ans.size()][]);
 return ans;

    }
```

## 区间交集

给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。

返回这 两个区间列表的交集 。

形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。

两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。

---

这题一开始自己用的是两个for循环，官方答案是一个for循环（虽然觉得自己的两个for也并不会差别太大？)

官方答案的：

```java
public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
//if(secondList.length == 0) return new int[];
List<int[]> ans = new ArrayList();
    int i = 0, j = 0;

    while (i < firstList.length && j < secondList.length) {
      // Let's check if A[i] intersects B[j].
      // lo - the startpoint of the intersection
      // hi - the endpoint of the intersection
      int lo = Math.max(firstList[i][0], secondList[j][0]);
      int hi = Math.min(firstList[i][1], secondList[j][1]);
      if (lo <= hi)
        ans.add(new int[]{lo, hi});

      // Remove the interval with the smallest endpoint
      if (firstList[i][1] < secondList[j][1])
        i++;
      else
        j++;
    }
    return ans.toArray(new int[ans.size()][]);
```



## [1288. 删除被覆盖区间](https://leetcode-cn.com/problems/remove-covered-intervals/)

难度中等59

给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。

只有当 `c <= a` 且 `b <= d` 时，我们才认为区间 `[a,b)` 被区间 `[c,d)` 覆盖。

在完成所有删除操作后，请你返回列表中剩余区间的数目。

 

**示例：**

```
输入：intervals = [[1,4],[3,6],[2,8]]
输出：2
解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。
```

---

首先是对数组进行排序，这里注意如果第一个元素相同，则按照第二个元素逆序来排，否则按照第一个元素的正序来排

![image-20220211033715291](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220211033715291.png)

```java
    public int removeCoveredIntervals(int[][] intervals) {

int tot=0,prevend =0;
Arrays.sort(intervals,new Comparator<int[]>() {
@Override
public int compare(int[]a,int[]b)
{
    return a[0]==b[0]?b[1]-a[1]:a[0]-b[0];
} });
for(int i = 0;i < intervals.length;i++){

    int end = intervals[i][1];
  if(prevend <end)
  {
      tot++;
      prevend = end;
  }
}
return tot;
    }
```

## 构造最长回文串

给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。

在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。

 

示例 1:

输入:s = "abccccdd"
输出:7
解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。

----

技巧：题目不要求顺序，可以利用hashset来构造，每遇到一个新字符只需要添加到hashset中，下次再遇到同样的就移除

```java
 public int longestPalindrome(String s) {
HashSet<Character>myset = new HashSet<>();
int count=0;
for(int i= 0;i<s.length();i++)
{
if(myset.contains(s.charAt(i)))
{
    count++;
    myset.remove(s.charAt(i));
}
else
myset.add(s.charAt(i));
}
return myset.size()==0?count*2:count*2+1;
    }
```

## 最长回文子序列

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

 

**示例 1：**

```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

```java
 public int longestPalindromeSubseq(String s) {
int len = s.length();
int[][]dp = new int[len][len];
for(int i =len-1;i>=0;i--)
{
    dp[i][i] = 1;
    for(int j = i+1;j<len;j++)
    {
        if(s.charAt(i)==s.charAt(j))
        {
            dp[i][j]=dp[i+1][j-1]+2;
        }
        else dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
    }
}
return dp[0][len-1];
    }
```



----

![image-20220211063657710](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220211063657710.png)

## [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

难度中等778

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

-----

```java
 public int countSubstrings(String s) {
boolean[][]dp = new boolean[s.length()][s.length()];
int len = s.length();

for(int i =len-1;i>=0;i--)
{
    dp[i][i] = true;
    for(int j = i+1;j<len;j++)
    {
        if(s.charAt(i) == s.charAt(j))
        {
            if(j-i==1) dp[i][j] = true;
            else dp[i][j] = dp[i+1][j-1];
        }
        else
dp[i][j] =false;
}
}
int tot = 0;
for(int i = 0;i<len;i++)
for(int j = 0;j < len;j++)
   if(dp[i][j]==true) tot++;
return tot;
    }
```



## 两次遍历[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)：

难度简单213

给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。

返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。

两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。

 

**示例 1：**

```
输入：s = "loveleetcode", c = "e"
输出：[3,2,1,0,1,0,0,1,2,2,1,0]
解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。
距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。
对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。
距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。
```

---

从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。

从右想做遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。

```java
    public int[] shortestToChar(String s, char c) {
int[]ans = new int[s.length()];
int prev = Integer.MIN_VALUE/2;//注意这个值
for(int i = 0;i <s.length();i++)
{
    if(s.charAt(i) == c) prev = i;
    ans[i] = i-prev;
}
prev = Integer.MAX_VALUE/2;//注意这个值 除以2是防止溢出
for(int i = s.length()-1;i>=0;i--)
{
    if(s.charAt(i)==c) prev = i;
ans[i] = Math.min(ans[i],prev-i);
}
return ans;
    }
```

## [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

难度中等1131

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

 



**示例 1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

---

按照身高从大到小排序后，每个人前面的人都大于等于自己，然后再按第二个元素从小到大排

```java
public int[][] reconstructQueue(int[][] people) {
Arrays.sort(people,new Comparator<int[]>(){
    public int compare(int[]a,int[]b)
    {
        if(a[0] != b[0]) return b[0]-a[0];//按从大到小的身高排列
        return a[1]-b[1];//如果身高相同，按第二个元素从小到大排列
    }
});
     List<int[]> ans = new ArrayList<int[]>();
        for (int[] person : people) {
            ans.add(person[1], person);//依次插入到数组中
        }
return ans.toArray(new int[ans.size()][]);
    }
```

## 给定一个数 n，如 23121；给定一组数字 A 如 {2,4,9}，求由 A 中元素组成的、小于 n 的最大数

如小于 23121 的最大数为 22999



```javascript
\#include <bits/stdc++.h>
using namespace std;

int main()
{
string s = "23121";
string a = "249";
string res;
sort(a.begin(), a.end());
bool flag = false;

for (int i = 0; i < s.size(); i ++)
   for (int j = 0; j < a.size(); j ++){
           if(flag)
           {
             res += a[a.size() - 1];
             break;
        }
           else if (s[i] == a[j]) 
           {
              res +=a[j];
              break;
        }
           else if (s[i] < a[j]){
               if (j - 1 >= 0) {
               res += a[j - 1];
               flag = true; 
               break;
           }
           else 

           return -1；
   }

} 
cout << res;

return 0;
```

## 整数转换英文表示

将非负整数 num 转换为其对应的英文表示。

 

示例 1：

输入：num = 123
输出："One Hundred Twenty Three"
示例 2：

输入：num = 12345
输出："Twelve Thousand Three Hundred Forty Five"
示例 3：

输入：num = 1234567
输出："One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"



----

由于非负整数 num 的最大值为 2^{31}-2 31−1，因此最多有 10 位数。将整数转换成英文表示中，将数字按照 33 位一组划分，将每一组的英文表示拼接之后即可得到整数 num 的英文表示。

每一组最多有 33 位数，可以使用递归的方式得到每一组的英文表示。根据数字所在的范围，具体做法如下：

小于 20 的数可以直接得到其英文表示；

大于等于 20 且小于 100 的数首先将十位转换成英文表示，然后对个位递归地转换成英文表示；

大于等于 100 的数首先将百位转换成英文表示，然后对其余部分（十位和个位）递归地转换成英文表示。

![image-20220324231805872](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220324231805872.png)

----

```java
class Solution {
    String[] singles = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"};
    String[] teens = {"Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    String[] tens = {"", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    String[] thousands = {"", "Thousand", "Million", "Billion"};

    public String numberToWords(int num) {
        if (num == 0) {
            return "Zero";
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 3, unit = 1000000000; i >= 0; i--, unit /= 1000) {
            int curNum = num / unit;
            if (curNum != 0) {
                num -= curNum * unit;
                StringBuffer curr = new StringBuffer();
                recursion(curr, curNum);
                curr.append(thousands[i]).append(" ");
                sb.append(curr);
            }
        }
        return sb.toString().trim();
    }

    public void recursion(StringBuffer curr, int num) {
        if (num == 0) {
            return;
        } else if (num < 10) {
            curr.append(singles[num]).append(" ");
        } else if (num < 20) {
            curr.append(teens[num - 10]).append(" ");
        } else if (num < 100) {
            curr.append(tens[num / 10]).append(" ");
            recursion(curr, num % 10);
        } else {
            curr.append(singles[num / 100]).append(" Hundred ");
            recursion(curr, num % 100);
        }
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/integer-to-english-words/solution/zheng-shu-zhuan-huan-ying-wen-biao-shi-b-ivik/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## [233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/)

难度困难441

给定一个整数 `n`，计算所有小于等于 `n` 的非负整数中数字 `1` 出现的个数。

 

**示例 1：**

```
输入：n = 13
输出：6
```

**示例 2：**

```
输入：n = 0
输出：0
```

----

这里要用归纳整理法，先得到一个统一的方法可以计算出每个位数上1的个数，然后再每一位进行统计，从个位数字开始统计，可以设置一个muti位从1开始，每次算完以后muti*10,计算十位、百位..

```java
 public int countDigitOne(int n) {
     long multik = 1;//multik从个位开始，个位数字是1，十位是10，计算每个数位上的1
     int ans = 0;
     for(int k = 0;n>=multik;k++){
         //这个用math.max的步骤很巧妙，省去了很多繁琐的if判断情况，以十位数字的1举例，如果n<10 则十位数字上1的个数为0 如果n>=10 &&n<20 十位数字上的1为n%100-10+1 n>20,十位数字上的1是10 
         ans += (n/(multik * 10)) * multik + Math.min(Math.max(0,n%(multik*10)-multik+1),multik);
         multik *=10;
     }
     return ans;
    }
```

## [133. 克隆图](https://leetcode.cn/problems/clone-graph/)

难度中等527

给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin)** 图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。

图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。

```
class Node {
    public int val;
    public List<Node> neighbors;
}
```

 

**测试用例格式：**

简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（`val = 1`），第二个节点值为 2（`val = 2`），以此类推。该图在测试用例中使用邻接列表表示。

**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。

给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝** 作为对克隆图的引用返回。



------------------

使用一个哈希表存储所有已被访问和克隆的节点。哈希表中的 key 是原始图中的节点，value 是克隆图中的对应节点。

从给定节点开始遍历图。如果某个节点已经被访问过，则返回其克隆图中的对应节点。

如下图，我们给定无向边边 A - B，表示 A 能连接到 B，且 B 能连接到 A。如果不对访问过的节点做标记，则会陷入死循环中。

如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中。注意：在进入递归之前，必须先创建克隆节点并保存在哈希表中。如果不保证这种顺序，可能会在递归中再次遇到同一个节点，再次遍历该节点时，陷入死循环。

递归调用每个节点的邻接点。每个节点递归调用的次数等于邻接点的数量，每一次调用返回其对应邻接点的克隆节点，最终返回这些克隆邻接点的列表，将其放入对应克隆节点的邻接表中。这样就可以克隆给定的节点和其邻接点。

```java
class Solution {
    private HashMap <Node, Node> visited = new HashMap <> ();
    public Node cloneGraph(Node node) {
        if (node == null) {
            return node;
        }

        // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回
        if (visited.containsKey(node)) {
            return visited.get(node);
        }

        // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表
        Node cloneNode = new Node(node.val, new ArrayList());
        // 哈希表存储
        visited.put(node, cloneNode);

        // 遍历该节点的邻居并更新克隆节点的邻居列表
        for (Node neighbor: node.neighbors) {
            cloneNode.neighbors.add(cloneGraph(neighbor));
        }
        return cloneNode;
    }
}


```







## 最大值减去最小值小于等于num的子数组数量

要求时间复杂度o(n)

------------

首先介绍普通的解法，找到arr的所有子数组，一共有O（N2）个，然后对每一个子数组做遍历找到其中的最小值和最大值，这个过程时间复杂度为O（N），然后看看这个子数组是否满足条件。统计所有满足的子数组数量即可。普通解法容易实现，但是时间复杂度为O（N3），本书不再详述。最优解可以做到时间复杂度O（N），额外空间复杂度O（N），在阅读下面的分析过程之前，请读者先阅读本章“生成窗口最大值数组”问题，本题所使用到的双端队列结构与解决“生成窗口最大值数组”问题中的双端队列结构含义基本一致。 生成两个双端队列qmax和qmin。当子数组为arr[i..j]时，qmax维护了窗口子数组arr[i..j]的最大值更新的结构，qmin维护了窗口子数组arr[i..j]的最小值更新的结构。当子数组arr[i..j]向右扩一个位置变成arr[i..j+1]时，qmax和qmin结构可以在O（1）的时间内更新，并且可以在O1）的时间内得到arr[i..j+1]的最大值和最小值。当子数组arr[i..j]向左缩一个位置变成arr[i+1..j]时，qmax和qmin结构依然可以在O（1）的时间内更新，并且在O（1）的时间内得到arr[i+1..j]的最大值和最小值。 通过分析题目满足的条件，可以得到如下两个结论： 如果子数组arr[i..j]满足条件，即max（arr[i..j]）-min（arr[i..j]）<=num，那么arr[i..j]中的每一个子数组，即arr[k..l]（i<=k<=l<=j）都满足条件。我们以子数组arr[i..j-1]为例说明，arr[i..j-1]最大值只可能小于或等于arr[i..j]的最大值，arr[i..j-1]最小值只可能大于或等于arr[i..j]的最小值，所以arr[i..j-1]必然满足条件。同理，arr[i..j]中的每一个子数组都满足条件。 如果子数组arr[i..j]不满足条件，那么所有包含arr[i..j]的子数组，即arr[k..l]（k<=i<=j<=l）都不满足条件。
步骤:

1.生成两个双端队列qmax和qmin，含义如上文所说。生成两个整型变量i和j，表示子数组的范围，即arr[i..j]。生成整型变量res，表示所有满足条件的子数组数量。 

2.令j不断向右移动（j++），表示arr[i..j]一直向右扩大，并不断更新qmax和qmin结构，保证qmax和qmin始终维持动态窗口最大值和最小值的更新结构。一旦出现arr[i..j]不满足条件的情况，j向右扩的过程停止，此时arr[i..j-1]、arr[i..j-2]、arr[i..j-3]、...、arr[i..i]一定都是满足条件的。也就是说，所有必须以arr[i]作为第一个元素的子数组，满足条件的数量为j-i个。于是令res+=j-i。 

3.当进行完步骤2，令i向右移动一个位置，并对qmax和qmin做出相应的更新，qmax和qmin从原来的arr[i..j]窗口变成arr[i+1..j]窗口的最大值和最小值的更新结构。然后重复步骤2，也就是求所有必须以arr[i+1]作为第一个元素的子数组中，满足条件的数量有多少个。 

4.根据步骤2和步骤3，依次求出以arr[0]、arr[1]、...、arr[N-1]作为第一个元素的子数组中满足条件的数量分别有多少个，累加起来的数量就是最终的结果。 上述过程中，所有的下标值最多进qmax和qmin一次，出qmax和qmin一次。i和j的值也不断增加，并且从来不减小。所以整个过程的时间复杂度为O（N）。 最优解全部实现请参看如下代码中的getNum方法。

```java
public int(int[]arr,int num)
{
    if(arr==null||arr.length==0) return 0;
    LinkedList<Integer>qmin = new LinkedList<>();
LinkedList<Integer>qmax = new LinkedList<>();    
   int i=0,j=0,res=0;
      while(i < arr.length)
      {
        while(j<arr.length)
        {
            while(!qmin.isEmpty() && arr[qmin.peekLast()]>=arr[j])
                qmin.pollLast();//更新最小值
            qmin.addLast(j);
            while(!qmax.isEmpty()&&arr[qmax.peekLast()]<=arr[j])
                qmax.pollLast();
            qmax.addLast(j);
            if(arr[qmax.getFirst()]-arr[qmin.getFirst()]>num) break;//不满足时j停止向后扩充
            j++;
                
        }
          if(qmin.peekFirst()==i)
              qmin.pollFirst();
     if(qmax.peekFirst()==i)
              qmax.pollFirst();     
          
          res += j-i;//用于存储总数
          i++;//i向后移
          
      }
return res;
}
```

## 辅助数组：[915. 分割数组](https://leetcode.cn/problems/partition-array-into-disjoint-intervals/)

难度中等102

给定一个数组 `nums` ，将其划分为两个连续子数组 `left` 和 `right`， 使得：

- `left` 中的每个元素都小于或等于 `right` 中的每个元素。
- `left` 和 `right` 都是非空的。
- `left` 的长度要尽可能小。

*在完成这样的分组后返回 `left` 的 **长度*** 。

用例可以保证存在这样的划分方法。

--------------------

```java
  public int partitionDisjoint(int[] nums) {
if(nums.length==2) return 1;
int[]left = new int[nums.length];
int[]right = new int[nums.length];
int m = nums[0];
for(int i = 0;i < nums.length;i++){
m = Math.max(m,nums[i]);
left[i] = m;
}
m = nums[nums.length-1];
for(int i = nums.length-1;i >=0;i--){
m = Math.min(m,nums[i]);
right[i] = m;
}
for(int i = 1;i < nums.length;i++){
if(left[i-1]<=right[i]) return i;
}
return nums.length-2;
    }
```

## [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

难度中等653

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

--------------



![image-20220916223215306](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220916223215306.png)

```java
  public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
  Map<Integer,Integer>map = new HashMap<>();
        for (int i : nums1) {
            for (int i1 : nums2) {
                map.put(i+i1,map.getOrDefault(i+i1,0)+1);
            }
        }
        int ans = 0;
        for (int i : nums3) {
            for (int i1 : nums4) {
                ans += map.getOrDefault(-(i+i1),0);
            }
        }
        return ans;
    }
```

## [396. 旋转函数](https://leetcode.cn/problems/rotate-function/)

难度中等234

给定一个长度为 `n` 的整数数组 `nums` 。

假设 `arrk` 是数组 `nums` 顺时针旋转 `k` 个位置后的数组，我们定义 `nums` 的 **旋转函数** `F` 为：

- `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]`

返回 *`F(0), F(1), ..., F(n-1)`中的最大值* 。

生成的测试用例让答案符合 **32 位** 整数。

 

**示例 1:**

```
输入: nums = [4,3,2,6]
输出: 26
解释:
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。
```

-------------------

![image-20220924122242687](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220924122242687.png)

```java
    public int maxRotateFunction(int[] nums) {
int[]newnum = new int[nums.length];
int max = Integer.MIN_VALUE,sum = Arrays.stream(nums).sum(),total=0;
for(int i = 0;i < nums.length;i++){
total +=i*nums[i];
}
int res = total;
for(int i = nums.length-1;i>=0;i--){
total +=sum - nums[i]*nums.length;
res = Math.max(res,total);
}
return res;
    }
```

## [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

难度中等290

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

-------------------

![image-20221001173422391](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221001173422391.png)

count=9×start×digit

根据以上分析，可将求解分为三步：

确定 n 所在 数字 的 位数 ，记为digit ；
确定 n 所在的 数字 ，记为 num ；
确定 n 是num 中的哪一数位，并返回结果。

![image-20221001173505321](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20221001173505321.png)

```java
 public int findNthDigit(int n) {
    int digit = 1;
        long count = 9,num = 1;
        while(n > count){
            n -=count;
            digit++;
            num *=10;
            count = num*digit*9;
        }
        long totalBit = num + (n-1)/digit;
        return Long.toString(totalBit).charAt((n-1)%digit)-'0'; 
    }
```

## [357. 统计各位数字都不同的数字个数](https://leetcode.cn/problems/count-numbers-with-unique-digits/)

难度中等311

给你一个整数 `n` ，统计并返回各位数字都不同的数字 `x` 的个数，其中 `0 <= x < 10的n次方` 。

 

**示例 1：**

```
输入：n = 2
输出：91
解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x < 100 范围内的所有数字。 
```

---------------------



![image-20230117185737187](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230117185737187.png)

```java
public int countNumbersWithUniqueDigits(int n) {

if(n==0) return 1;

int res=10,cur=9;
for(int i=0;i<n-1;i++){
    cur=cur*(9-i);
    res+=cur;
}
return res;
    }
```

## [880. 索引处的解码字符串](https://leetcode.cn/problems/decoded-string-at-index/)

难度中等174

给定一个编码字符串 `S`。请你找出 **解码字符串** 并将其写入磁带。解码时，从编码字符串中 **每次读取一个字符** ，并采取以下步骤：

- 如果所读的字符是字母，则将该字母写在磁带上。
- 如果所读的字符是数字（例如 `d`），则整个当前磁带总共会被重复写 `d-1` 次。

现在，对于给定的编码字符串 `S` 和索引 `K`，查找并返回解码字符串中的第 `K` 个字母。

 

**示例 1：**

```
输入：S = "leet2code3", K = 10
输出："o"
解释：
解码后的字符串为 "leetleetcodeleetleetcodeleetleetcode"。
字符串中的第 10 个字母是 "o"。
```

--------------------------

逆向思维法：先得到size,再从后往前遍历

一般来说，当解码的字符串等于某个长度为 size 的单词重复某些次数（例如 apple 与 size=5 组合重复6次）时，索引 K 的答案与索引 K % size 的答案相同。

我们可以通过逆向工作，跟踪解码字符串的大小来使用这种洞察力。每当解码的字符串等于某些单词 word 重复 d 次时，我们就可以将 k 减少到 K % (Word.Length)。



```java
    public String decodeAtIndex(String s, int k) {
StringBuilder sb=new StringBuilder();
//这里必须要定义为long类型，不然会越界异常
long size=0;
for (int i = 0; i < s.length(); ++i) {
            char c = s.charAt(i);
            if (Character.isDigit(c))
                size *= c - '0';
            else
                size++;
        }

for (int i = s.length()-1; i >= 0; --i) {
            char c =s.charAt(i);
            k %= size;
            if (k == 0 && Character.isLetter(c))
                return Character.toString(c);

            if (Character.isDigit(c))
                size /= c - '0';
            else
                size--;
        }

return null;
    }
```

## [462. 最小操作次数使数组元素相等 II](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/)

难度中等279

给你一个长度为 `n` 的整数数组 `nums` ，返回使所有数组元素相等需要的最小操作数。

在一次操作中，你可以使数组中的一个元素加 `1` 或者减 `1` 。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：2
解释：
只需要两次操作（每次操作指南使一个元素加 1 或减 1）：
[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
```



--------

![image-20230131150833727](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230131150833727.png)

比如说一个数组[1,2,3,4,5,6],target是1和6之间的数，则不管是几，移动次数都是5，如果这个数字在[1,6]之外，比如7，那么就是7-1+7-6，即2*target-num1-num2,这里7-1一定是大于6-1的，所以如果范围在这个区间外面，移动次数一定会更大的

```java
public int minMoves2(int[] nums) {
if(nums.length==1) return 0;

int ans=0;
Arrays.sort(nums);
int n=nums[nums.length/2];

for(int i:nums)
ans+=Math.abs(n-i);
return ans;
}
```



# 优先级队列

## [179. 最大数](https://leetcode-cn.com/problems/largest-number/)

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。

**示例 1：**

```
输入：nums = [10,2]
输出："210"
```

**示例 2：**

```
输入：nums = [3,30,34,5,9]
输出："9534330"
```

```java
public String largestNumber(int[] nums) {
PriorityQueue<String>queue = new PriorityQueue<>((x,y)->(y+x).compareTo(x+y));
for(int i:nums)
queue.offer(String.valueOf(i));
String ans="";
while(queue.size()>0)
{
ans+=queue.poll();
}
if(ans.charAt(0)=='0') return"0";
return ans;

    }
```





## [918. 环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

首先关于一般数组的最大和：

```java
    int maxSubArray(vector<int>& nums) {

int pre = 0;
int sum = nums[0];
for(const auto &i: nums){
    pre = max(pre+i,i);
    sum = max(pre,sum);
}
return sum;
    }

```

然后环形数组最大和的关键是知道最大和是怎么产生的，其实有两种情况，一个是最大和是数组中间的数字之和（从第0索引到第length-1个索引之间某几个数之和），另一个是由两端的产生，（即包含0和length-1索引，但中间有的元素不包含），第二种情况是有负数的情况，如[8,-1,-1,1],这样需要用所有元素之和减去最小子数组来求，有一种特殊情况，如果全为负数这时候所有元素之和减去最小子数组为0，这个环形数组的最大和应该是元素中最大的那个数，概况：

对于环形数组，分两种情况。
(1)答案在数组中间，就是最大子序和。例如[1,-2,3,-2]；
(2)答案在数组两边，例如[5,-3,5]最大的子序和就等于数组的总和SUM-最小的子序和。(一种特殊情况是数组全为负数，也就是SUM-最小子序和==0，最大子序和等于数组中最大的那个)。

```java
public int maxSubarraySumCircular(int[] nums) {
int premax = 0,premin = 0,maxval = nums[0],minval = nums[0],sum=0;
for(int i = 0;i < nums.length;i++)
{
    premax = Math.max(premax+nums[i],nums[i]);
    maxval = Math.max(maxval,premax);
    premin = Math.min(premin+nums[i],nums[i]);
    minval =  Math.min(minval,premin);
    sum+=nums[i];
}
return Math.max(maxval,sum-minval ==0?maxval:sum-minval);
    }
```

## [1094. 拼车](https://leetcode-cn.com/problems/car-pooling/)

难度中等146

假设你是一位顺风车司机，车上最初有 `capacity` 个空座位可以用来载客。由于道路的限制，车 **只能** 向一个方向行驶（也就是说，**不允许掉头或改变方向**，你可以将其想象为一个向量）。

这儿有一份乘客行程计划表 `trips[][]`，其中 `trips[i] = [num_passengers, start_location, end_location]` 包含了第 `i` 组乘客的行程信息：

- 必须接送的乘客数量；
- 乘客的上车地点；
- 以及乘客的下车地点。

这些给出的地点位置是从你的 **初始** 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。

请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 `true`，否则请返回 `false`）。

示例 1：

输入：trips = [[2,1,5],[3,3,7]], capacity = 4
输出：false
示例 2：

输入：trips = [[2,1,5],[3,3,7]], capacity = 5
输出：true
示例 3：

输入：trips = [[2,1,5],[3,5,7]], capacity = 3
输出：true

-------------------

首先按分别按上车地点和下车地点维护两个小顶堆。每次比较堆顶元素，并维护当前容量，若下车地点更小（或相等），先下车（当前容量增加），否则上车（当前容量减小），上车时要判断当前容量是否变成负值，若变成负值应直接返回false。
注意，因为最后一个下车地点一定大于最后一个上车地点，因此按上车地点维护的小顶堆一定先变为空。



```java
 public boolean carPooling(int[][] trips, int capacity) {
PriorityQueue<int[]>up = new PriorityQueue<>((a,b)->a[1]-b[1]);//按上车地点进行排序
PriorityQueue<int[]>down = new PriorityQueue<>((a,b)->a[2]-b[2]);
for(int i = 0;i<trips.length;i++)
{
    up.offer(trips[i]);
    down.offer(trips[i]);
}
while(!up.isEmpty())
{
    int start = up.peek()[1];
    int end = down.peek()[2];
    if(end<=start)
    {
        int[] temp=down.poll();//下车，容量增加
        capacity+=temp[0];
    }
    else
    {
        int[] temp = up.poll();
        capacity-=temp[0];
    }
    if(capacity<0) return false;
}
return true;
    }
```

## [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

难度中等

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。

 

**示例 1：**

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

**示例 2：**

```
输入：n = 1
输出：1
解释：1 通常被视为丑数。
```

---

要得到从小到大的第 n个丑数，可以使用最小堆实现。

初始时堆为空。首先将最小的丑数 1加入堆。

每次取出堆顶元素 xx，则 xx 是堆中最小的丑数，由于 2x, 3x, 5x 也是丑数，因此将 2x, 3x, 5x 加入堆。

上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。

在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。



```java
 public int nthUglyNumber(int n) {
int[]ug=new int[]{2,3,5};
PriorityQueue<Long>queue = new PriorityQueue<>();
Set<Long>myset = new HashSet<>();//在添加元素的过程中可能出现非常大的数，因此要用long类型
queue.offer(1L);//1是丑数
myset.add(1L);
 int ans=1;
for(int i = 0;i<n;i++)
{
  long heap=queue.poll();
   ans = (int)heap;//强制转化为int类型
  for(int j = 0;j < ug.length;j++)
  {
      long temp = heap*ug[j];
      if(myset.add(temp))//用于去重，如果hashset可以添加成功则证明这个元素没有出现过，可以添加到堆中
      queue.offer(temp);
  }  

}
return ans;
    }
  
```



## 前k个出现频率最高的数字



```java
   public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();
        for (int num : nums) {
            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);
        }

        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数
        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] m, int[] n) {
                return m[1] - n[1];//这一步比较不能写反，否则结果是错的
            }
        });
        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {
            int num = entry.getKey(), count = entry.getValue();
            if (queue.size() == k) {
                if (queue.peek()[1] < count) {
                    queue.poll();
                    queue.offer(new int[]{num, count});
                }
            } else {
                queue.offer(new int[]{num, count});
            }
        }
        int[] ret = new int[k];
        for (int i = 0; i < k; ++i) {
            ret[i] = queue.poll()[0];
        }
        return ret;
    }
}


```

## 用优先级队列合并k个有序链表

```java
class Status implements Comparable<Status> {
        int val;
        ListNode ptr;
        public Status(int val,ListNode ptr)
        {
            this.val=val;
            this.ptr=ptr;
        }
        
        public int compareTo(Status s2)
        {
return ptr.val-s2.val;
        }
    }
    PriorityQueue<Status>queue=new PriorityQueue<Status>();
    public ListNode mergeKLists(ListNode[] lists) {
for(ListNode node:lists)
if (node != null) {
queue.offer(new Status(node.val,node));
}
ListNode head=new ListNode(0);
ListNode tail=head;
while(!queue.isEmpty())
{
    Status f=queue.poll();
    tail.next=f.ptr;
    tail=f.ptr;
    if(f.ptr.next!=null)
    queue.offer(new Status(f.ptr.next.val,f.ptr.next));//这一步比较巧妙，没有直接展开上面的所有链表结点，而是先将链表数组中的元素按照第一个结点的大小加入优先级队列，后再对每一个结点中寻找下一个结点加入队列
}
return head.next;
    }
```



## 对二维数组自定义排序

```java
Arrays.sort(intervals,new Comparator<int[]>() {
@Override
public int compare(int[]a,int[]b)
{
    return a[0]==b[0]?b[1]-a[1]:a[0]-b[0];
} });
```

## 滑动窗口的最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

------

由于出现了最大值，用优先级队列可以维护每次窗口的最大值，其中用数组下标用来排除窗口之外的元素

```java
 public int[] maxSlidingWindow(int[] nums, int k) {
int[]ans = new int[nums.length+1-k];
PriorityQueue<int[]>queue = new PriorityQueue<int[]>(new Comparator<int[]>(){
    @Override
    public int compare(int[]a1,int[]a2)
    {
        return a1[0]==a2[0]?a2[1]-a1[1]:a2[0]-a1[0];
    }
});
for(int i = 0;i <k;i++)
queue.offer(new int[]{nums[i],i});
int index = 0;
ans[0]= queue.peek()[0];
for(int i = k;i<nums.length;i++)
{
      queue.offer(new int[]{nums[i],i});
   while(queue.peek()[1] <= i-k)//注意这里是while循环不是if判断
    queue.poll();
  
   
      ans[i-k+1] = queue.peek()[0];
  
}
return ans;
    }
```

也可以用双端队列：

![image-20220211100522678](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220211100522678.png)

```java
   public int[] maxSlidingWindow(int[] nums, int k) {
int[]ans = new int[nums.length+1-k];
Deque<Integer>queue = new LinkedList<>();

for(int i = 0;i <k;i++)
{
while(!queue.isEmpty()&& nums[i]>=nums[queue.peekLast()])
queue.pollLast();
queue.offerLast(i);
}
int index = 0;
ans[0]= nums[queue.peekFirst()];
for(int i = k;i<nums.length;i++)
{
   while(!queue.isEmpty()&& nums[i]>=nums[queue.peekLast()])
queue.pollLast();
 queue.offerLast(i);
   while(queue.peekFirst() <= i-k)//注意这里是while循环不是if判断
    queue.pollFirst();
  
   
      ans[i-k+1] = nums[queue.peekFirst()];
  
}
return ans;
    }
```

## [703. 数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)

难度简单321

设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。

请实现 `KthLargest` 类：

- `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。
- `int add(int val)` 将 `val` 插入数据流 `nums` 后，返回当前数据流中第 `k` 大的元素。

 

**示例：**

```
输入：
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
输出：
[null, 4, 5, 5, 8, 8]
```

----

首先需要观察特征，可以近似于数组中实际上只保存前k大的数然后取k个数其中的最小数即可

```java
int number;
PriorityQueue<Integer>queue ;
    public KthLargest(int k, int[] nums){
this.number = k;
queue= new PriorityQueue<>();
for(int i :nums)
{
add(i);
}
    }
    
    public int add(int val) {
queue.offer(val);
if(queue.size()>number)
queue.poll();
return queue.peek();
    }
```

## 会议室

给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si < ei)，
为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。

示例 1:
输入: [[0, 30],[5, 10],[15, 20]]
输出: 2

示例 2:
输入: [[7,10],[2,4]]

输出: 1

----

```java
开始时间一样，先结束的在前；开始早的在前
优先队列存储会议结束的时间，堆顶是结束时间早的
下一个会议开始时间早于堆顶的房间结束时间，该会议新开一个room，push进队列
int  minMeetingRooms(int[][]newlen)
  {
      Arrays.sort(newlen, new Comparator<int[]>() {
          @Override
          public int compare(int[] o1, int[] o2) {
              return o1[0]==o2[0]?o1[1]-o2[1]:o1[0]-o2[0];
          }
      });

PriorityQueue<Integer> queue = new PriorityQueue<Integer>();
queue.offer(newlen[0][1]);//优先级队列只存放结束时间

      for(int i = 1;i < newlen.length;i++)
      {
          if(newlen[i][0] >= queue.peek())//如果这个会议的开始时间大于上一个队列的结束时间，则可以用原来的房间
              queue.poll();
          queue.offer(newlen[i][1]);
      }
  return queue.size();
  }
```











## [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

难度中等438

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

----



![image-20220220175044175](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220220175044175.png)

利用这一特性，我们可以将判断是否为递归的出口看作 A && B 表达式中True，并继续执行表达式 B 的部分，否则递归结束。当然，你也可以用逻辑运算符 || 给出类似的实现，这里我们只提供结合逻辑运算符 && 的递归实现。

```java
public int sumNums(int n) {
boolean flag= (n>0)&&(n = n+sumNums(n-1))>0;
return n;

    }
```

## [166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)

难度中等366

给定两个整数，分别表示分数的分子 `numerator` 和分母 `denominator`，以 **字符串形式返回小数** 。

如果小数部分为循环小数，则将循环的部分括在括号内。

如果存在多个答案，只需返回 **任意一个** 。

对于所有给定的输入，**保证** 答案字符串的长度小于 `104` 。

示例 1：

输入：numerator = 1, denominator = 2
输出："0.5"
示例 2：

输入：numerator = 2, denominator = 1
输出："2"
示例 3：

输入：numerator = 2, denominator = 3
输出："0.(6)"

-----

计算长除法时，首先计算结果的整数部分，将以下部分依次拼接到结果中：

如果结果是负数则将负号拼接到结果中，如果结果是正数则跳过这一步；

将整数部分拼接到结果中；

将小数点拼接到结果中。

完成上述拼接之后，根据余数计算小数部分。

计算小数部分时，每次将余数乘以 10，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成 0 或者找到循环节。

如果余数变成 0，则结果是有限小数，将小数部分拼接到结果中。

如果找到循环节，则找到循环节的开始位置和结束位置并加上括号，然后将小数部分拼接到结果中。

如何判断是否找到循环节？注意到对于相同的余数，计算得到的小数的下一位数字一定是相同的，因此如果计算过程中发现某一位的余数在之前已经出现过，则为找到循环节。为了记录每个余数是否已经出现过，需要使用哈希表存储每个余数在小数部分第一次出现的下标。

```java
 public String fractionToDecimal(int numerator, int denominator) {
     long numeratorLong = (long) numerator;//分子
        long denominatorLong = (long) denominator;//分母
      StringBuilder sb = new StringBuilder();
       
        if(  numeratorLong%denominator == 0) 
        return String.valueOf(numeratorLong / denominatorLong);
        if(numeratorLong<0 ^ denominatorLong < 0) //两个异或，如果为true说明不是两个异号
        sb.append('-');
          // 整数部分
        numeratorLong = Math.abs(numeratorLong);
        denominatorLong = Math.abs(denominatorLong);
        long ans = numeratorLong/denominatorLong;
        sb.append(ans);
sb.append('.');//小数点别忘了
StringBuilder smallnum = new StringBuilder();//小数
Map<Long,Integer>mymap = new HashMap<>();//long是数字，integer是索引
long remainindex = numeratorLong % denominatorLong;//余数
int index = 0;
while(remainindex != 0 && !mymap.containsKey(remainindex))
{
     mymap.put(remainindex,index);
    remainindex = remainindex *10;
    long temp = remainindex/denominatorLong;
    remainindex %= denominator;//注意这一步不要忘记，余数要模上分母得到新的余数，不断循环
    smallnum.append(temp);
   
    index++;
}
if(remainindex != 0)
{
    //有余数
    int begin = mymap.get(remainindex);
    smallnum.insert(begin,'(');
    smallnum.append(')');
}
sb.append(smallnum);
return sb.toString();
    }
```

## 76.重构字符串

给定一个字符串 s ，检查是否能重新排布其中的字母，使得两相邻的字符不同。

返回 s 的任意可能的重新排列。若不可行，返回空字符串 "" 。

 

示例 1:

输入: s = "aab"
输出: "aba"
示例 2:

输入: s = "aaab"
输出: ""

----

这里很巧妙，优先级队列是对字符进行排序的，而且是按照字符在数组中出现的次数排序（这个自己一直没想到方法要怎么排，用treemap进行了自定义排序但发现这样不可行，比如vvvlo这种情况，会输出vlovv，最后两个出现次数一样的还是连在一起了）

然后另一个巧妙点是拼接的时候一次取出两个字符，这样两个字符必然是不一样的字符，而且一定是取出出现次数最大的两个字符

当最大堆的元素个数大于 11 时，每次从最大堆取出两个字母，拼接到重构的字符串，然后将两个字母的出现次数分别减 11，并将剩余出现次数大于 00 的字母重新加入最大堆。由于最大堆中的元素都是不同的，因此取出的两个字母一定也是不同的，将两个不同的字母拼接到重构的字符串，可以确保相邻的字母都不相同。

如果最大堆变成空，则已经完成字符串的重构。如果最大堆剩下 11 个元素，则取出最后一个字母，拼接到重构的字符串。

对于长度为 n 的字符串，共有 n/2 次每次从最大堆取出两个字母的操作，当 n 是奇数时，还有一次从最大堆取出一个字母的操作，因此重构的字符串的长度一定是 n。

当 n 是奇数时，是否可能出现重构的字符串的最后两个字母相同的情况？如果最后一个字母在整个字符串中至少出现了 2 次，则在最后一次从最大堆取出两个字母时，该字母会先被选出，因此不会成为重构的字符串的倒数第二个字母，也不可能出现重构的字符串最后两个字母相同的情况。

所以在循环的时候条件是queue.size()>1而不是>0

```java
  public String reorganizeString(String s) {
int []arr=new int [26];
int len=s.length();
for(char item:s.toCharArray())
arr[item-'a']++;
int same=0;//相同的字母数
int totnum = 0;//字母种类数
for(int i = 0;i < 26;i++)
{
        same=Math.max(arr[i],same);
       
    
}

    String ans="";
    char pre='1';
     if (same > (len + 1) / 2) {
            return "";
        }
 PriorityQueue<Character> queue = new PriorityQueue<Character>(new Comparator<Character>() {
            public int compare(Character letter1, Character letter2) {
                return arr[letter2 - 'a'] - arr[letter1 - 'a'];
            }
        });
        for (char c = 'a'; c <= 'z'; c++) {
            if (arr[c - 'a'] > 0) {
                queue.offer(c);
            }
        }
 //Arrays.sort(arr);//降序排列
 Map<Integer,Integer>mymap = new TreeMap<>();
 for(int i =0;i<26;i++ )
 if(arr[i]!=0)
 mymap.put(i,arr[i]);
while (queue.size() > 1) {
Character letter1=queue.poll();
Character letter2 = queue.poll();
ans+=letter1;
ans+=letter2;
  int index1 = letter1 - 'a', index2 = letter2 - 'a';
            arr[index1]--;
            arr[index2]--;
            if (arr[index1] > 0) {
                queue.offer(letter1);
            }
            if (arr[index2] > 0) {
                queue.offer(letter2);
            }
}
      if (queue.size() > 0) {
            ans+=queue.poll();
        }
int max=0;

return ans;
    }
```

## [I. 队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)

难度中等407

请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的**均摊**时间复杂度都是O(1)。

若队列为空，`pop_front` 和 `max_value` 需要返回 -1

这里pop_front是弹出最先进去的元素。

------------------------





思路：维护两个队列，一个用于取出最大值，一个 普通队列用于弹出最新进去的元素：

本算法基于问题的一个重要性质：当一个元素进入队列的时候，它前面所有比它小的元素就不会再对答案产生影响。

举个例子，如果我们向队列中插入数字序列 1 1 1 1 2，那么在第一个数字 2 被插入后，数字 2 前面的所有数字 1 将不会对结果产生影响。因为按照队列的取出顺序，数字 2 只能在所有的数字 1 被取出之后才能被取出，因此如果数字 1 如果在队列中，那么数字 2 必然也在队列中，使得数字 1 对结果没有影响。

按照上面的思路，我们可以设计这样的方法：从队列尾部插入元素时，我们可以提前取出队列中所有比这个元素小的元素，使得队列中只保留对结果有影响的数字。这样的方法等价于要求维持队列单调递减，即要保证每个元素的前面都没有比它小的元素。

那么如何高效实现一个始终递减的队列呢？我们只需要在插入每一个元素 value 时，从队列尾部依次取出比当前元素 value 小的元素，直到遇到一个比当前元素大的元素 value' 即可。

上面的过程保证了只要在元素 value 被插入之前队列递减，那么在 value 被插入之后队列依然递减。
而队列的初始状态（空队列）符合单调递减的定义。
由数学归纳法可知队列将会始终保持单调递减。
上面的过程需要从队列尾部取出元素，因此需要使用双端队列来实现。另外我们也需要一个辅助队列来记录所有被插入的值，以确定 pop_front 函数的返回值。

保证了队列单调递减后，求最大值时只需要直接取双端队列中的第一项即可。





```java
Deque<Integer>deque;
Queue<Integer>queue;

    public MaxQueue() {
deque = new LinkedList<>();
queue = new LinkedList<>();
    }
    
    public int max_value() {
        if(deque.size()==0) return -1;
return deque.peekFirst();
    }
    
    public void push_back(int value) {
        while(deque.size()>0&& value>deque.peekLast()){
            deque.pollLast();
        }
        deque.offerLast(value);
queue.offer(value);

    }
    
    public int pop_front() {
if(queue.size()==0) return -1;
int top = queue.poll();
if(top == deque.peekFirst())
{
    deque.pollFirst();
}
return top;
    }
```

## 分治：[856. 括号的分数](https://leetcode.cn/problems/score-of-parentheses/)

难度中等460

给定一个平衡括号字符串 `S`，按下述规则计算该字符串的分数：

- `()` 得 1 分。
- `AB` 得 `A + B` 分，其中 A 和 B 是平衡括号字符串。
- `(A)` 得 `2 * A` 分，其中 A 是平衡括号字符串。

 

**示例 1：**

```
输入： "()"
输出： 1
```

**示例 2：**

```
输入： "(())"
输出： 2
```

**示例 3：**

```
输入： "()()"
输出： 2
```



--------------------

根据题意，一个平衡括号字符串 s 可以被分解为 A+B或 (A) 的形式，因此我们可以对 s 进行分解，分而治之。

如何判断 s 应该分解为 A+B 或(A) 的哪一种呢？我们将左括号记为 11，右括号记为 -1−1，如果 s 的某个非空前缀对应的和bal=0，那么这个前缀就是一个平衡括号字符串。如果该前缀长度等于 s 的长度，那么 s 可以分解为 (A) 的形式；否则 s 可以分解为 A+B 的形式，其中 A 为该前缀。将 s 分解之后，我们递归地求解子问题，并且 s 的长度为 2 时，分数为 1。



```java
public int scoreOfParentheses(String s) {
    if(s.length()==2){
        return 1;
    }
    int score = 0,len = 0;
    for (int i = 0; i < s.length(); i++)
    {
        score +=s.charAt(i)=='('?1:-1;
        if(score==0){
            //注意是设置为i+1不是i
            len = i+1;
            break;
        }
    }
    if(len == s.length()){
        return 2*scoreOfParentheses(s.substring(1,s.length()-1));
    }
    else{
        return scoreOfParentheses(s.substring(0,len))+scoreOfParentheses(s.substring(len,s.length()));
    }
}
```

## [480. 滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/)

难度困难406

中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

- `[2,3,4]`，中位数是 `3`
- `[2,3]`，中位数是 `(2 + 3) / 2 = 2.5`

给你一个数组 *nums*，有一个长度为 *k* 的窗口从最左端滑动到最右端。窗口中有 *k* 个数，每次窗口向右移动 *1* 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

 

**示例：**

给出 *nums* = `[1,3,-1,-3,5,3,6,7]`，以及 *k* = 3。

```
窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
```

---------------------

首先是关于中位数，需要维护两个优先级队列，其中是大的一半，另一边是小的一半，如果为奇数那么小的一半的peek()就是中位数，如果是偶数，那么就是两个队列peek（)的一半

注意：一个从小到大的优先队列，那么peek()取出来是最小的

```java
 public double[] medianSlidingWindow(int[] nums, int k) {
        DualHeap dh = new DualHeap(k);
        for (int i = 0; i < k; ++i) {
            dh.insert(nums[i]);
        }
        double[] ans = new double[nums.length - k + 1];
        ans[0] = dh.getMedian();
        for (int i = k; i < nums.length; ++i) {
            dh.insert(nums[i]);
            dh.erase(nums[i - k]);
            ans[i - k + 1] = dh.getMedian();
        }
        return ans;
    }
}

class DualHeap {
    // 大根堆，维护较小的一半元素
    private PriorityQueue<Integer> small;
    // 小根堆，维护较大的一半元素
    private PriorityQueue<Integer> large;
    // 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数
    private Map<Integer, Integer> delayed;

    private int k;
    // small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素
    private int smallSize, largeSize;
//比如1 2 3 4 5 6 7 8分成两个队列，一个放4 3 2 1，一个放5 6 7 8，那么前者peek是4 后者是5
    public DualHeap(int k) {
        //这个队列是从大到小 要让从大到小的队列先放元素
        this.small = new PriorityQueue<Integer>(new Comparator<Integer>() {
            public int compare(Integer num1, Integer num2) {
                //num2-num1会发生溢出，只能这样写
                return num2.compareTo(num1);
                
            }
        });
        //这个是从小到大 peek是最小的
        this.large = new PriorityQueue<Integer>(new Comparator<Integer>() {
            public int compare(Integer num1, Integer num2) {
                return num1.compareTo(num2);
            }
        });
        this.delayed = new HashMap<Integer, Integer>();
        this.k = k;
        this.smallSize = 0;
        this.largeSize = 0;
    }

    public double getMedian() {
        return (k & 1) == 1 ? small.peek() : ((double) small.peek() + large.peek()) / 2;
    }

    public void insert(int num) {
        if (small.isEmpty() || num <= small.peek()) {
            small.offer(num);
            ++smallSize;
        } else {
            large.offer(num);
            ++largeSize;
        }
        makeBalance();
    }

    public void erase(int num) {
        delayed.put(num, delayed.getOrDefault(num, 0) + 1);
        if (num <= small.peek()) {
            --smallSize;
            if (num == small.peek()) {
                prune(small);
            }
        } else {
            --largeSize;
            if (num == large.peek()) {
                prune(large);
            }
        }
        makeBalance();
    }

    // 不断地弹出 heap 的堆顶元素，并且更新哈希表
    private void prune(PriorityQueue<Integer> heap) {
        while (!heap.isEmpty()) {
            int num = heap.peek();
            if (delayed.containsKey(num)) {
                delayed.put(num, delayed.get(num) - 1);
                if (delayed.get(num) == 0) {
                    delayed.remove(num);
                }
                heap.poll();
            } else {
                break;
            }
        }
    }

    // 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求
    private void makeBalance() {
        if (smallSize > largeSize + 1) {
            // small 比 large 元素多 2 个
            large.offer(small.poll());
            --smallSize;
            ++largeSize;
            // small 堆顶元素被移除，需要进行 prune
            prune(small);
        } else if (smallSize < largeSize) {
            // large 比 small 元素多 1 个
            small.offer(large.poll());
            ++smallSize;
            --largeSize;
            // large 堆顶元素被移除，需要进行 prune
            prune(large);
        }
    }
```

------

## [剑指 Offer II 061. 和最小的 k 个数对](https://leetcode.cn/problems/qn8gGX/)

难度中等67

给定两个以升序排列的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。

定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。

请找到和最小的 `k` 个数对 `(u1,v1)`, ` (u2,v2)` ...  `(uk,vk)` 。

 

**示例 1:**

```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
    [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```



![image-20230325193704369](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20230325193704369.png)

```java
  public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        PriorityQueue<int[]> pq = new PriorityQueue<>(k, (o1, o2)->{
            return nums1[o1[0]] + nums2[o1[1]] - nums1[o2[0]] - nums2[o2[1]];
        });
        List<List<Integer>> ans = new ArrayList<>();
        int m = nums1.length;
        int n = nums2.length;
        for (int i = 0; i < Math.min(m, k); i++) {
            pq.offer(new int[]{i,0});
        }
        while (k-- > 0 && !pq.isEmpty()) {
            int[] idxPair = pq.poll();
            List<Integer> list = new ArrayList<>();
            list.add(nums1[idxPair[0]]);
            list.add(nums2[idxPair[1]]);
            ans.add(list);
            if (idxPair[1] + 1 < n) {
                pq.offer(new int[]{idxPair[0], idxPair[1] + 1});
            }
        }
        
        return ans;
    }


```



# [18. 四数之和](https://leetcode-cn.com/problems/4sum/)

难度中等1101

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

```java
 List<List<Integer>>ans = new LinkedList<>();
    public List<List<Integer>> fourSum(int[] nums, int target) {
List<Integer>mylist = new LinkedList<>();
if(nums==null||nums.length<4) return ans;
Arrays.sort(nums);
for(int i = 0;i<nums.length-3;i++)
{
     if(i>0 && nums[i]==nums[i-1])
     continue;
     if((long)nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;//没有四数之和为目标值
     if((long)nums[nums.length-1]+nums[nums.length-2]+nums[nums.length-3]+nums[i]<target) continue;
    for(int j = i+1;j<nums.length-2;j++)
    {
  if(j>i+1&&nums[j-1]==nums[j])//去重
{
    continue;
}
    int left = j+1,right = nums.length-1;
    while(left<right)
    {
        if(nums[i]+ nums[j] + nums[left] + nums[right]==target)
        {
            ans.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
            while(left<right && nums[left]==nums[left+1])
            left++;
              left++;
        while(left<right && nums[right]==nums[right-1])
        right--;
        right--;
        }
      else if(nums[i]+ nums[j] + nums[left] + nums[right]<target)
left++;
else right--;
    }
    }
}
return ans;
    }
```



# 智力题



## 赛马问题



- 64匹马，8个跑道，问最少比赛多少场，可以选出跑得最快的4匹马

- - Assumptions：每场比赛每个跑道只允许一匹马，且不存在并列情形



- **step1：需8场比赛**

- - 首先把64匹马随机分为8组并标记组别，遍历组别，比赛8次，并记录每组赛马名次(eg：A1>A2>...>A7>A8
  - 首先可直接剔除各组后四名赛马，剩余64-4*8=32匹赛马待定



- **step2：需1场比赛**

- - 选出每组排名第一的赛马进行一次比赛，记录结果，不失一般性地，记为：A1>B1>C1>D1>E1>F1>G1>H1
  - 根据这轮比赛结果，首先可以剔除E、F、G、H这四组所有赛马（因为本组第一都未进入前4），剩余16匹马

![img](https://pic4.zhimg.com/80/v2-b740151b48b343b61adde04bbd0f5e2b_1440w.jpg)

- - 其次可以确定A1就是全场MVP，属全场N01，剩余15匹马待定

  - 还可以进一步细化

  - - D组2-4名赛马：D2>D3>D4，不可能是Top4，可剔除这3匹，剩余15-3=12匹赛马待定

  - C组3-4名赛马:C3>C4，不可能是Top4，可剔除这2匹，剩余12-2=10匹赛马待定

  - - B组第4名赛马：B4，也不可能是Top4，可剔除这1匹，剩余10-1=9匹赛马待定



- **step3：需1场or2场比赛**

- - 当前剩余待定9匹赛马：A2>A3>A4,B1>B2>B3,C1>C2,D1

  - 因为可以确定B1>C1>D1，因此挑选：A2>A3>A4,B1>B2>B3,C1>C2（ 或者 A2>A3>A4,B1>B2>B3,C1>D1）等8匹马进行一场比赛，剩余一匹赛马D1或者C2待定，重点关注C1名次

  - **仅需1场比赛情形**

  - - 当C1排名第3及以后，则选出本场前3名赛马，外加大佬A1，即为所求的Top4匹马

  - **需2场比赛情形**

  - - 因为已知B1>C1,所以C1本场名次区间为[2,8]

    - 当C1排名第2时，可推知B1排名本场第一，因此A1>B1>C1即为全场Top3匹马，此时可剔除B1,C1两匹马，剩余9-2=7匹马待定（如下）

    - - 本轮上场剩余6匹：A2>A3>A4，B2>B3,C2
      - 未上场1匹：D1

    - 将本场剩余7匹赛马再进行一场比赛，一决高低，记录名次，选出本场排名第一的赛马，加上A1>B1>C1，即为全场Top4匹马

- 答案：

- 最少需要10场or11场

-----

![preview](https://pic1.zhimg.com/v2-3a430aad55598addb9ac144bef99eeac_r.jpg)

25匹马，5个赛道，求选出速度最快的3匹马最少需要多少次比赛？

答案：7次（一个赛道一匹马）
由于场地只有5个赛道，每次最多5匹马比赛，将25匹马分为5组（A、B、C、D、E），每组5匹（编号1、2、3、4、5）。

分成五组，每组五匹，选出每组第一名

首先，进行5场比赛，每场比赛给每组排名。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201012114538336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlYWxZdXpob3U=,size_16,color_FFFFFF,t_70#pic_center)

假设名次与编号一致，选出每组前三名。

再将每个赛道的第一名拉出来比赛一次，选出前三名。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201012114843467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlYWxZdXpob3U=,size_16,color_FFFFFF,t_70#pic_center)



则假设最终名次也是按照上图顺序，即A1名次最高，E1名次最低。D组和E组全部淘汰。A1也是25匹马中的第一，接下来需要选出第二名和第三名。
由于A1是冠军，比A1速度稍慢的是A2和B1，亚军只可能在他们两个之中产生。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201012115117513.png#pic_center)

假设A2是亚军，那么季军需要在A3、B1中选择。
假设B1是亚军，那么季军需要在A2、B2、C1中选择。
综上，只需要A2、A3、B1、B2、C1再比赛一场即可。



所以，一共至少需要7场比赛，才能选出25匹马中的前三名。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201012120130999.png#pic_center)
