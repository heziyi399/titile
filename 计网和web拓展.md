



# 网络协议分层

为什么要对网络协议分层：

**「复杂的系统需要分层，因为每一层都需要专注于一类事情。我们的网络分层的原因也是一样，每一层只专注于做一类事情。」**

**「为什么计算机网络要分层呢？」** ,我们再来较为系统的说一说：

1. **「各层之间相互独立」**：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）**「。这个和我们对开发时系统进行分层是一个道理。」**
2. **「提高了整体灵活性」** ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。**「这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。」**
3. **「大问题化小」** ：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **「这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。」**

分层参考模型的设计是非常经典的理念：
 层次化的模型设计将网络的通信过程划分为更小、更简单的部件，因此有助于各个部件的独立开发、设计和故障排除；
 层与层之间相互独立，又互相依赖，每一层都有该层的功能、以及定义的协议标准。层与层之间相互配合，共同完成数据通信的过程；
 通过组件的标准化，允许多个供应商进行开发；
 通过定义在模型的每一层实现什么功能，鼓励产业的标准化

说到计算机网络分层，我想到了计算机世界非常非常有名的一句话，这里分享一下：

> **「计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。」**
>
> ![image-20220210183207839](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220210183207839.png)

![image-20210911151043774](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210911151043774.png)

TCP/IP四层协议（数据链路层、网络层、传输层、应用层）
1、应用层 应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。

![image-20220515123419415](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220515123419415.png)

![image-20220515123710007](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220515123710007.png)

网络层最常用的是IP协议，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过MTU就会再次进行分片，得到一个即将发送网络的IP报文， 网络层需要有区分设备的编号，负责将数据从一个设备传输到另一个设备，　　我们一般用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分成了四段，每段是8位。IP地址分成两种意义：　　·一个是网络号，负责标识该IP地址是属于哪个子网的；　　·一个是主机号，负责标识同一子网下的不同主机；　　怎么分的呢？这需要配合子网掩码才能算出地址的网络号和主机号。那么在寻址的过程中，先匹配到相同的网络号，才会去找对应的主机。　　除了寻址能力，协议还有另一个重要的能力就是路由。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过算法决定下一步走哪条路径。

![image-20220515124349221](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220515124349221.png)

**「应用层协议」** :





- HTTP 协议（超文本传输协议，网页浏览常用的协议）
- DHCP 协议（动态主机配置）
- DNS 系统原理（域名系统）
- FTP 协议（文件传输协议）
- Telnet协议（远程登陆协议）
- 电子邮件协议等（SMTP、POP3、IMAP）



**「HTTP 协议是基于 TCP协议的」**，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。

另外， **「HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态」** 一般我们都是通过 Session 来记录客户端用户的状态。

**SMTP:简单邮件传输(发送)协议**

「简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，基于 TCP 协议，用来发送电子邮件。」

注意⚠️：**「接受邮件的协议不是 SMTP 而是POP3协议。」**

**POP3/IMAP:邮件接收的协议**

这两个协议不多做阐述，只需要了解 **「**POP3 和 IMAP 两者都是负责邮件接收的协议」即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。「SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。」**

IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。

**FTP:文件传输协议**

「文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。」

FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：

> FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：
>
> 1. 控制连接：用于传送控制信息（命令和响应）
> 2. 数据连接：用于数据传送；
>
> 这种将命令和数据分开传送的思想大大提高了 FTP 的效率。



**Telnet:远程登陆协议**

远程登陆协议，通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。

「Telnet协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。」

**SSH:安全的网络传输协议**

SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。

**「Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。」**

传输层（Transport layer）

**「传输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务」**。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。

**「运输层主要使用以下两种协议：」**

1. **「传输控制协议TCP」**（Transmisson Control Protocol）--提供**「面向连接」**的，**「可靠的」**数据传输服务。
2. **「用户数据协议UDP」**（User Datagram Protocol）--提供**「无连接」**的，尽最大努力的数据传输服务（**「不保证数据传输的可靠性」**）。

2、传输层 

建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务（负责向两台主机之间的通信提供“通用的”数据传输服务），包括处理差错控制和流量控制等问题。应用进程利用该服务传送应用层报文，该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。

- TCP 协议

- - 报文段结构
  - 可靠数据传输
  - 流量控制
  - 拥塞控制

- UDP 协议

- - 报文段结构
  - RDT（可靠数据传输协议）

3、网络层

计网中进行通信的两个计算机可能会经过很多个数据链路，也可能还要经过很多通信子网，网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据段封装成ip数据报（也叫分组）和包进行传送。

 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。

4、数据链路层 

通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路，

![image-20220209114947281](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220209114947281.png)

![image-20220209115158966](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220209115158966.png)

![image-20220209115053392](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220209115053392.png)

# 两台主机之间通信的过程

PC的用户在WEB浏览器中访问Server的WEB服务（这里我们暂且不去关注底层的HTTP交互、DNS交互等细节。重点看通信过程），PC的这次操作将触发HTTP应用为用户构造一个应用数据。当然这个数据最终要传递到Server并最终“递交”到Server的HTTP应用来处理，但是HTTP不关心数据怎么传、怎么寻址、怎么做差错校验等等，那么这些事情就交由专门的
Layer来完成，所以HTTP应用数据还的经过一番“折腾”才能从PC传出去到达Server，现在开始。

由于HTTP基于TCP，因此这个应用数据交由TCP/IP模型中的主机到主机层进一步处理。在该层，**上层HTTP应用数据被封装上一个TCP的头部**，在TCP头部中，这里我们重点关注两个字段，一个是源端口号，另一个是目的端口号，源端口号为随机，目的端口号为80（HTTP服务对应的默认端口号是80）。然后这个数据segment被交给下一个Layer处理。

到了IP层，IP协议为这个上层下来的数据封装上一个IP头，以便该数据能够在IP网络中被网络设备转发（路由）。IP头当中，我们重点关注源IP地址、目的IP地址、协议号这三个字段。其中源地址存放的是PC自己的IP地址192.168.1.1 ， 目的地址存放的是Server 的IP地址192.168.2.1，而协议号字段则存放的是值6，这个值是一个well-known值，也就是行业约定的、
众所周知的值，该值对应上层协议类型TCP，表示我这个IP头后面封装的上层协议为TCP。搞定之后，这个数据被交给下一层处理。

为了让这个IP数据包能够在链路上传输，还要给数据包封装上一个数据链路层的头部，由于我们这里是以太网链路，因此上层下来的IP数据包被封装上一个以太网的数据帧头。这个数据帧头中源MAC地址为PC的网卡MAC，那么目的MAC呢？PC知道，数据的目的地是192.168.2.1这个IP，而本机IP是192.168.1.1/24，显然，目的地与自己并不在同一个网段，因此需要借助自己的网关，让网关来帮助自己将数据包转发出去。那么首先我得把数据转发到网关吧？因此目的MAC地址填写的就是网关192.168.1.254对应的MAC地址。但是初始情况下，PC可能并没有192.168.1.254的MAC，所以，它会发送一个ARP广播去请求192.168.1.254的MAC，R1的GE0/0/0口会收到这个ARP请求并且回送ARP响应。如此一来PC就知道了网关的MAC，它将网关MAC 0018-0011-0001填写在以太网数据帧头部的目的MAC中。另外，以
太网数据帧头的类型字段写上0x0800这个值，表示我这个数据帧头后面封装的是一个IP包。好了费了好大劲儿，这个数据帧终于搞定了

值得一提的是，事实上在物理链路中传输的是bit流，或者电气化的脉冲，只不过为了方便理解和更加直观的分析，我们往往会以IP包或者数据帧的形式来阐述通信过程。所以从物理上说，**最终这个以太网数据帧变成了一堆的101010101从网线传到了路由器R1上**

![image-20220225172953061](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220225172953061.png)

![image-20220225172916915](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220225172916915.png)

路由器R1在收到这一串的1010后，先将他们还原成数据帧。
然后会采用相应的机制检查一下数据帧在传输过程中是否有损坏，如果没有损坏，那么就瞅瞅数据帧头部中的目的MAC地址，看看目的MAC地址是不是我收到这个数据帧的GE0/0/0口的MAC，结果发现是，它很高兴，觉得这个数据帧是给我的，它查看数据帧头部的类型字段，发现是0x0800，于是它知道里头装的是一个IP包，接着它将以太网数据帧头剥去或者说解封装，然后移交给上层IP协议继续处理。

![image-20220225173416049](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220225173416049.png)

# 什么是TCP/IP和UDP

1、TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达

经常提到的TCP/IP并不单指TCP和IP两个具体的协议，而往往是互联网经常用到的整个TCP/IP协议族。

![image-20220324131405085](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220324131405085.png)

<font color="red">TCP（传输控制协议）和IP（网际协议） 是最先定义的两个核心协议，所以才统称为TCP/IP协议族</font>

2、UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。

​     我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。

**ping命令**是用来探测主机到主机之间是否可通信，如果不能**ping**到某台主机，表明不能和这台主机建立连接。**ping命令**是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机。

ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。

🔷TCP与UDP区别：
1、TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达；
2、UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；
3、TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；
4、UDP通信类似于学校广播，靠着广播播报直接进行通信。
5、TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
6、TCP是面向字节流的，UDP是面向报文（数据报）的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
7、TCP首部开销（20字节）比UDP首部开销（8字节）要大
8、UDP 的主机不需要维持复杂的连接状态表

**对某些实时性要求比较高的情况使用UDP，**比如游戏，媒体通信，实时直播，即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失的情况

🔷运行在TCP协议上的协议：
HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
FTP（File Transfer Protocol，文件传输协议），用于文件传输。
POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。
🔷运行在UDP协议上的协议：
BOOTP（Boot Protocol，启动协议），应用于无盘设备。
NTP（Network Time Protocol，网络时间协议），用于网络同步。
DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。

🔷运行在TCP和UDP协议上：
DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。
ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。
SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。
DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。
ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。

![image-20220519132000155](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220519132000155.png)







# 什么是Http协议？

Http协议是对客户端和服务器端之间数据之间实现可靠性的传输文字、图片、音频、视频等超文本数据的规范，格式简称为“超文本传输协议”
Http协议属于应用层，及用户访问的第一层就是http

## http1.0 1.1

![image-20220210014335619](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220210014335619.png)



**1. HTTP协议与TCP/IP协议的关系**

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。



小写ack是 acknowledge number 为确认号码，值是seq + 1。

1 HTTP1.0和HTTP1.1的区别
1.1 长连接(Persistent Connection)
       HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。

1.2 节约带宽
       HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。

1.3 HOST域
       在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

1.4缓存处理
       在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

1.5错误通知的管理
       在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

## HTTP1.1和HTTP2.0的区别

HTTP2 可以提高了网页的性能。
在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。
HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。

2.1 多路复用
       HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
2.2 头部数据压缩
       在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。

       HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

2.3 服务器推送
       服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。

       为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

## https

身披 SSL(SecureSocketLayer )外壳的HTTP，运行于 SSL上，SSL运行于TCP 之上， 是添加了加密和认证机制的HTTP。

由于加解密处理，会消耗更多的 CPU和内存资源

需要证书，而证书一般需要向认证机构购买

ssl基本流程：

![image-20220519125319787](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220519125319787.png)

## 常用HTTP状态码

HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。
状态码的类别：

![image-20220324135126797](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220324135126797.png)

5XX：服务端错误

## 长连接与短连接

**长连接**多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 

　　而像WEB网站的http服务一般都用**短链接**，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

# TCP 长连接与短连接

TCP 短连接的情况，client 向server 发起连接请求，server 接到请求，然后双方建立连接。client 向server 发送消息，server 回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close 操作，不过一般都是client 先发起close 操作。为什么呢，一般的server不会回复完client 后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server 间传递一次读写操作

长连接：指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，

一般需要自己做在线维持。连接→数据传输→保持连接→数据传输→保持连接→……→关闭连接 (减少多次TCP的三次握手和四次挥手)

==同一个TCP连接中可以发送很多HTTP请求 一个HTTP请求一定在某一个TCP里面发送的== 

## HTTP是不保存状态的协议,如何保存⽤户状态?

2. **如何理解HTTP协议是无状态的**

HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即服务器不保留与客户交易时的任何状态。 也就是说,上一次的请求对这次的请求没有任何影响,服务端也不会对客户端上一次的请求进行任何记录处理。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。

![image-20220210015118846](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220210015118846.png)

## 什么是http的请求体？

1、HTTP请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器那数据，先要表明我要什么吧
2、HTTP请求体由：请求行 、请求头、请求数据组成的，
3、注意：GET请求是没有请求体的

![image-20210926230411351](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210926230411351.png)

# 三次握手与四次挥手

(1). 三次握手（我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功）
第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![image-20220210160230420](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220210160230420.png)

SYN(SYNchronization) ： 在连接建立时用来同步的序列号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。

ACK ：ACK 是TCP报头的控制位之一，TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1 ACK起同步作用，SYN起应答作用

seq： (sequence number) 顺序号码
ack: (acknowledge number) 确认号码

- FIN ：释放一个连接， 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。

(2). 四次挥手（我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧）：

比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。
第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。
第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。
第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。
第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102**。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连**
**接，所以服务端结束TCP连接的时间要比客户端早一些。**

1、第一次握手：客户什么都不能确认；服务器确认了对方发送正常
2、第二次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己接收正常，对方发送正常
3、第三次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己发送、接收正常，对方发送接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。

🔷建立连接可以两次握手吗？为什么?
不可以。
因为可能会出现已失效的连接请求报文段又传到了服务器端。 > client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。
本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道client 并没有要求建立连接。

为什么要四次挥手？
TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B发出的数据；B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向A 发送数据。




所以想要愉快的结束这次对话就需要四次挥手。

![image-20220209122217614](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220209122217614.png)

为什么客户端最后还要等待2MSL？
MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，**而自己也未必全部数据都发送给对方了**，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

![image-20220209123900921](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220209123900921.png)



## 为什么服务端传回syn

![image-20220209121820272](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220209121820272.png)

![image-20220209121840557](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220209121840557.png)

## 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？

这是因为服务端的LISTEN 状态下的SOCKET 当收到SYN 报文的建连请求后，它可以把ACK和SYN（ACK 起应答作用，而SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数
据给对方之后，再发送FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK 报文和FIN 报文多数情况下都是分开发送的。

## 第三次握手失败会怎样

当客户端收到服务端的SYN+ACK 应答后，其状态变为ESTABLISHED，并会发送ACK 包给服务端，准备发送数据了。如果此时ACK 在网络中丢失，过了超时计时器后，那么Server端会重新发送SYN+ACK 包，重传次数根据/proc/sys/net/ipv4/tcp_synack_retries 来指定，默认是5 次。如果重传指定次数到了后，仍然未收到ACK 应答，那么一段时间后，Server 自动关闭这个连接。但是Client 认为这个连接已经建立，如果Client 端向Server 写数据，Server端将以RST 包响应，方能感知到Server 的错误。
在S 返回一个确认的SYN-ACK 包的时候，S 可能由于各种原因不会接到C 回应的ACK 包。
这个也就是所谓的半开放连接，S 需要耗费一定的数量的系统内存来等待这个未决的连接，虽然这个数量是受限，但是恶意者可以通过创建很多的半开放式连接来发动SYN 洪水攻击。
攻击者可以通过IP 欺骗发送SYN 包给受害者系统，这个看起来是合法的，但事实上所谓的C 根本不会进行ACK 回应服务端S 的SYN-ACK 报文，这意味着受害者将永远不会接到ACK报文。而此时，半开放连接将最终耗用受害者所有的系统资源（即使等待ACK 包有超时限制），受害者将不能再接收任何其他的请求。

## 四次挥手的timewait

![image-20220309211256339](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220309211256339.png)

小写ack=seq+1

TIME_WAIT 为主动关闭的那端最后经历的状态，持续时间为2MSL。

MSL 是 Maxmum Segment Lifetime 报文最大生存时间。一般根据实际的网络情况进行确定。

为什么要持续这么长的时间？

原因一：可靠地实现 TCP 全双工连接的终止
主动关闭端（客户端）的最后一个 ACK 确认包可能会丢失，这时服务器就会超时重传第三次挥手的 FIN 信息报，然后客户端再重传第四次挥手的 ACK 报文。如果没有这 2MSL，客户端直接关闭连接，再次接收服务器超时重传的 FIN 信息报时，会响应 RST(Reset)，用来异常的关闭连接，服务端接受 RST 包后执行异常处理（不必发送 ACK 包来确认）。

（2）为使旧的重复数据包在网络中因过期而消失
服务端发送给客户端的一些报文在传输过程中由于网络拥堵而导致严重推迟，而在它到达客户端之前服务端已经重发了该报文，并完成其任务。如果在被推迟的报文未抵达前客户端就断开了连接，随后又建立了一个与之前相同IP、Port的连接，而之前被推迟的报文在这时恰好到达，而此时此新连接非彼连接，从而会发生数据错乱，进而导致无法预知的情况。因此必须维持一段等待时间，使迟到的报文在网络中完全消失。这个时间可以时所有网络中的报文到达应该到的位置，新的连接中不会出现旧的连接的报文



注意： TCP 连接处于 2MSL 连接等待期间，定义这个连接的四元组，即，客户端 IP 地址和端口，服务端 IP 地址和端口号，不能被使用。

高并发短连接会使服务器因端口资源不足而拒绝为一部分客户服务（存在大量 TIME_WAIT），服务器资源严重浪费。这种情况下可以通过 TIME_WAIT 的重用和快速回收进行处理。

# 字节面试：连接一个不存在的 IP 地址，会发生什么？



分享两个字节面试题，都是基于场景问的网络问题。

- Q1：**客户端连接一个不存在的 IP 地址，会发生什么？**
- Q2：**客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？**

PS：这里的「连接」指的是 TCP 连接。

> Q1：客户端连接一个不存在的 IP 地址，会发生什么？

这个问题要分两种情况来思考，不同的情况得到的结论是不同的。

*第一个情况：目标 IP 地址和客户端的 IP 地址是同一个局域网（网络号相同）。*

第一种情况，客户端无法发出 SYN 报文，主要卡在数据链路层。

因为目标地址不存在 IP 地址，客户端的内核在发 arp 请求的时候，广播询问这个目标 IP 地址是谁的，由于网络中不存在该目标 IP 地址，所以没有设备应答客户端的 arp 请求。

由于**客户端无法拿到目标设备的 MAC，这样就没办法组装 MAC 头的信息，所以 SYN 报文无法发送出去**。

*第二个情况：目标 IP 地址和客户端的 IP 地址不在同一个局域网（网络号不同）。*

第二种情况，客户端会先将 SYN 报文发给路由器，然后路由器会继续转发。

由于目标 IP 地址是不存在的，该 SYN 报文会在网络中消亡，因此客户端是不会收到对 SYN 报文的确认报文的，接着**客户端会触发超时重传，重传 SYN 报文，直到重传的次数达到最大次数后，客户端的连接就会被释放**。

可能有的同学好奇，为什么这种情况客户端的 SYN 报文可以发出来？

因为当目标 IP 地址和客户端 IP 地址不在同一个局域网时，客户端客通过路由表的判断，判断到下一步是要将网络报文发送给路由器。

这时候数据链路层的 arp 请求，会广播询问 IP 地址（路由器 IP 地址）是谁的，路由器发现是自己的 IP 地址，于是就会将自己的 MAC 地址告诉客户端。

然后客户端的网络报文中 MAC 头的「目标 MAC 地址」填入的就是路由器的 MAC 地址，于是 SYN 报文就可以发送出去了。

由于目标 MAC 地址是路由器的，所以就会被路由器接收，然后路由器继续通过路由表的判断，转发给下一个路由器，直到找到目标设备。

> Q2：客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？

客户端连接的目标 IP 地址是存在的，那么 SYN 报文就能正确的抵达到目标设备。

目标设备收到 SYN 报文后，发现端口号并没有被进程监听，这时候目标设备的内核就会回 RST 报文。

客户端收到 RST 报文后，就会释放连接。

# TCP 协议如何来保证传输的可靠性

![image-20220413230127960](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220413230127960.png)

TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8 bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。

TCP报文的头部结构：

![image-20220324131615194](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220324131615194.png)

不要将确认序号ack与标志位中的ACK搞混了

（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。确认方ack=发起方seq+1，两端配对。

第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。
第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。
第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次
握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。



<font color="red">对于可靠性，TCP通过以下方式进行保证：</font>
**数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应（即不确认收到此报文），这时TCP发送数据端超时后会重发数据；
**对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

**丢弃重复数据**：对于重复数据，能够丢弃重复数据；
**应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
**超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
**流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，当接收端来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。（滑动窗口实现流量控制）<u>流量控制是为了减低发送方速率，保证接收端来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率，将窗口字段设置为0，则发送方不能发送数据。</u>

# TCP窗口机制



TCP中窗口大小是指tcp协议一次传输多少个数据。因为TCP是一个面向连接的可靠的传输协议，既然是可靠的就需要传输的数据进行确认。
TCP窗口机制有两种，一种是固定窗口大小，另一种是滑动窗口。数据在传输时，TCP会对所有数据进行编号，发送方在发送过程中始终保持着一个窗口，只有落在发送窗口内的数据帧才允许被发送；同时接收方也始终保持着一个接收窗口，只有落在窗口内的数据才会被接收。这样通过改变发送窗口和接收窗口的大小就可以实现流量控制。
TCP的窗口滑动技术通过动态改变窗口的大小来调节两台主机之间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口，一个用于接收数据，一个用于发送数据。接收方设备要求窗口大小为0时，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。
    TCP在传送数据时，第一次接受方窗口大小是由链路带宽决定的，但是接收方在接收到的数据后，返回ack确认报文，同时也告诉了发送方自己的窗口大小，此时发送方第二次发送数据时，会改变自己的窗口大小和接收方一致。
    当窗口过大时，会导致不必要的数据来拥塞我们的链路，但是窗口太小时，会造成很大的延时，比如为1时，发送方每发送一个数据，接收方就会返回一个ack报文，在发送方未接收到接收方的确认报文ack之前不会进行下一次发送。（当链路变好了或者变差了这个窗口还会发生变化，并不是第一次协商好了以后就永远不变了。）



窗口滑动协议是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待接收确认报文前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。收发两端的窗口按照以上规律不断地向前滑动，因此这种协议又称为滑动窗口协议。

![image-20220413231018856](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220413231018856.png)

## **拥塞控制**：当网络拥塞时减小数据的发送



![image-20220210013218929](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220210013218929.png)

慢开始
发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。
慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。
实时拥塞窗口大小是以字节为单位的。当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以一次传输轮次之后拥塞窗口就加倍。这就是乘法增长，和后面的拥塞避免算法的加法增长比较。
为了防止cwnd 增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh 状态变量。ssthresh 的用法如下：
当cwnd<ssthresh 时，使用慢开始算法。
当cwnd>ssthresh 时，改用拥塞避免算法。
当cwnd=ssthresh 时，慢开始与拥塞避免算法任意。

拥塞避免
拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT 就把发送方的拥塞窗口cwnd 加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。
无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh 设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。

快重传
快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

快恢复
①当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh 门限减半。但是接下去并不执行慢开始算法。
②考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd 设置为ssthresh 的大小，然后执行拥塞避免算法。



**ARQ协议**：自动重传请求。Automatic Repeat-reQuest􀘧ARQ。是osi模型中数据链路层和传输层的错误纠正协议之一，它通过使用确认和超时这两机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送一段时间之内没有收到确认帧，它通常会重新发送。

# 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

# 如何解决tcp粘包问题

1）数据包固定大小，每收到该大小字节视为一个包
2）分隔符，比如\r\n
3）自定义数据包，header 中指定body 的长度（最常使用）

# UDP 实现可靠传输？

实现一个最基础的可靠udp 通讯协议，我们只需要提供一个重传机制即可。在这我实现了一个简单的可靠udp 协议，这个协议为每一个发送出去的udp 数据包分配一个包id，每次接收方收到一个数据包时，都要回应发送方一个ack 对应这个包id。协议通过这种确认机制来保证接收方能收到发送方发出的udp 数据包，在发出的时候，发送方应该设置一个计时器，超时的话会重传数据包。
具体来说它没做这些事情：
它没有保证包的有序性。发送方连续发送几个udp 数据包，接收方可以以任何顺序收到这几个数据包。如果想要做到有序性，必须由应用层来完成。
它没做流量控制。发送方连续大量发送数据包会导致网络性能变差，丢包次数增大。
它没对数据包大小做控制。为了避免IP 层对数据包进行分片，应用层应该要保证每个数据包的大小不超过MTU。如果这个数据包会经过广域网（一般情况下）这个值应该不超过576。

# GET 与 POST 的区别？

GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：
1、 从语义上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；
2、从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；
3、从请求参数形式上看**，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头中**，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体中。
4、就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。
5、从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。





# 什么是Socket

1、网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编程界面，一个Socket由一个IP地址和一个端口号唯一确定。
2、但是，Socket所支持的协议种类也不光TCP/IP、UDP，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。
3、socket连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的
4、Socket偏向于底层。一般很少直接使用Socket来编程，框架底层使用Socket比较多，

Socket是应用层与TCP/IP协议族通信的**中间软件抽象层**，它是一组接口。在设计模式中，Socket其实就是一个外观模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

Socket通讯的过程
基于TCP：
服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。
基于UDP：
UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。我客户端只需要发送，服务端能不能接收的到我不管

# Socket和http的区别和应用场景

1、Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；
2、Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。
3、http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接
4、http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等





# 一次完整的HTTP请求所经历几个步骤?

HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：
1、建立TCP连接
怎么建立连接的，看上面的三次握手
2、Web浏览器向Web服务器发送请求行
一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET /sample/hello.jsp
HTTP/1.1。
3、Web浏览器发送请求头
浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。
4、Web服务器应答
客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。
5、Web服务器发送应答头
正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

6、Web服务器向浏览器发送数据
Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据

7、Web服务器关闭TCP连接

![image-20220324131141859](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220324131141859.png)

发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。

# 浏览器中输入：“www.xxx.com ” 之后都发生了什么？请详细阐述。

解析：经典的网络协议问题。
1、由域名→IP地址 寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。(即DNS解析)
2、建立TCP/IP连接（三次握手具体过程）
3、由浏览器发送一个HTTP请求，先发请求行再发请求头
4、经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器
5、服务器处理该HTTP请求，返回HTTP报文，也是发送应答头和应答数据
6、浏览器解析并渲染页面，并且显示在浏览器端
7、这里需要注意：

HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接
可以这样理解：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。
两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。

![image-20220210014145703](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220210014145703.png)

# IP地址的分类

整个的因特网就是一个单一的、抽象的网络。IP 地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的 32 位标识符，它是一个逻辑地址，用以屏蔽掉物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。
每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：
A类地址：以0开头，第一个字节范围：0~127；
B类地址：以10开头，第一个字节范围：128~191；
C类地址：以110开头，第一个字节范围：192~223；
D类地址：以1110开头，第一个字节范围为224~239；
E类地址：以1111开头，保留地址
1、 A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”
一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台

A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。





# 内网穿透

内网穿透的原理

内网穿透是我们在进行网络连接时的一种术语，也叫做NAT穿透，即在计算机是局域网内的时候，外网与内网的计算机的节点进行连接时所需要的连接通信，有时候就会出现内网穿透不支的情况。**内网穿透的功能就是，当我们在[端口映射](https://hsk.oray.com/)时设置时，内网穿透起到了地址转换的功能，也就是把公网的地址进行翻译，转成为一种私有的地址，然后再采用路由的方式ADSL的宽带路由器，具有一个动态或者是固定的公网IP，最后ADSL直接在交换机上，这样所有的电脑都可以共享上网**。内网穿透除了可以实现内网之间机器的网络通信功通之外，还可以解决UDP中出现的数据传输不稳定问题。

![image-20210911163859975](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210911163859975.png)

内网穿透可以通过开放的第三方端口来实现。我们可以安装[花生壳](https://hsk.oray.com/)端口映射内网穿透软件，然后再添加映射，并且配置出映射端口的信息，外网的地址是映射之后访问的[域名](https://domain.oray.com/)，同时也可以是自己或者是默认的域名。通过内网穿透，可以用域名进行对应的内网应用。如果是外网地址使用的是自己的域名，可以把域名的解析指向提示目标地址来进行使用。

[内网](https://baike.baidu.com/item/内网)的一台电脑要上因特网对外开放服务或接收数据，都需要端口映射 [1] 。

端口映射分为动态和静态。动态端口映射：[内网](https://baike.baidu.com/item/内网)中的一台电脑要访问网站，会向NAT[网关](https://baike.baidu.com/item/网关)发送[数据包](https://baike.baidu.com/item/数据包)，报头中包括对方网站IP、端口和本机IP、端口，NAT[网关](https://baike.baidu.com/item/网关)会把本机IP、端口替换成自己的公网IP、一个未使用的端口，并且会记下这个映射关系，为以后转发数据包使用。然后再把数据发给网站，网站收到数据后做出反应，发送数据到NAT[网关](https://baike.baidu.com/item/网关)的那个未使用的端口，然后NAT网关将数据转发给[内网](https://baike.baidu.com/item/内网)中的那台电脑，实现内网和公网的通讯.当连接关闭时，NAT网关会释放分配给这条连接的端口，以便以后的连接可以继续使用 [1] 。

动态端口映射其实也就是NAT[网关](https://baike.baidu.com/item/网关)的工作方式 [1] 。

静态端口映射：就是在NAT[网关](https://baike.baidu.com/item/网关)上开放一个固定的端口，然后设定此端口收到的数据要转发给[内网](https://baike.baidu.com/item/内网)哪个IP和端口，不管有没有连接，这个映射关系都会一直存在。就可以让公网主动访问[内网](https://baike.baidu.com/item/内网)的一台电脑

一个局域网内的用户，是不能由外网用户主动连通的，这有时候会造成麻烦。比如某个用户在自己机器上建设了网站，但外面的用户却无法访问。这种情况就要使用到端口映射，将外网用指着（通常由宽带路由器担任）某个端口的访问转接到局域网内某台指定的计算机上 [9] 。

## 端口映射与端口转发

端口映射与端口转发，用于发布防火墙内部的服务器或者防火墙内部的客户端计算机，有的路由器也有端口映射与端口转发功能。端口映射与端口转发实现的功能类似，但又不完全一样。端口映射是将外网的一个端口完全映射给内网一个地址的指定端口，而端口转发是将发往外网的一个端口的通信完全转发给内网一个地址的指定端口。端口映射可以实现外网到内网和内网到外网双向的通信，而端口转发只能实现外网到内网的单向通信



# 以太网

引言：

TCP/IP世界的组成元素可谓琳琅满目。为了便于分析和总结，我们将它们分为节点、管线、管理体系、应用系统等几大类组成部分。 图2.1 IP世界的“节点”“全家福” 节点，是数据信息发生路由、交换、处理、分析、转换的装置，包括路由器、交换机、防火墙、流控设备、主机、终端，还有一些节点并非只为IP设计，如语音网关，3G网络中管理体系，包括对IP网络进行配置、告警、维护、控制等所需要的所有软件和硬件。首先声明，IP网络的管理并不是强制性的，也就是说，没有专门的管理体系，IP网络也能处于工作状态。只是，没有管理的网络是脆弱和笨拙的。 应用系统，所有基于IP网络的业务和应用，包括WWW、IM系统、CRM/ERP/MIS、网络游戏、博客、微博、Wiki、SNS等。绝大部分应用系统都不是由单一软件或者硬件组成的，而是由一系列软硬件组成的复杂的生态系统。 节点、管线、管理体系、应用体系是TCP/IP网络的基本组成部分，它们各成体系又浑然天成，它们相互联系又各司其职。我们将所有这些基本组成部分称为IP世界的钢筋混凝土。 

正如建设高楼大厦，绝不是钢筋混凝土的简单堆砌，建设IP网络，也绝对不是节点、管线、管理体系、应用体系的简单叠加，他们是有层次地组织在一起的。而这种组织的最基本单元，是局域网。 从另外一种角度来说，互联网的基础架构，可以看作是许多局域网互连的集合。无数的钢筋混凝土都先从组建局域网开始，才逐步构建起TCP/IP世界的高楼大厦。经过历史演进和技术淘汰，以太网已经成为IP网络中应用最广泛的局域网类型了。

1.以太网应用的普遍性

 以太网，无需多言。看一看我们身边的企业网，我们不得不感叹，以太网，已经普遍到几乎成为“唯一”。 在前些年的计算机网络课程里面，还有令牌环网、FDDI和ARCNET，而现在它们都像刚做的一场梦，无声无息神秘消失，只留下部分教科书上支离破碎的介绍，以及他们忠实拥趸们心态复杂的回忆。 很久以前，我们就开始思索：以太网究竟是何方神圣？有什么过人之处？有什么深厚的背景？有什么显赫的家世？

> 局域网要解决的最大问题，无非是多台主机都想在网络上“发言”，在任何一个时刻，让谁先“发言”的问题。 这就像一个多人会议，没有主持人，而每次发言者只能是一个人。很可能出现两个人或者多个人同时想发言的情况，这就需要有一套合理的机制，保证这个会议能够顺利进行——畅所欲言且井然有序。 为了解决这一问题，人们探索了不少巧妙的办法。比如令牌环（环形）就采用令牌方式，整个网络里只有一个“令牌”，谁拿到令牌谁发言。令牌则在网络里按照某种机制传递。 令牌环主要缺点是有较复杂的令牌维护要求。空闲令牌的丢失，将降低环路的利用率，令牌重复也会破坏网的正常运行，故必须选某台主机作为监控站。 
>
> 往昔荣耀无需追忆，今天的全球以太网市场上，三巨头鼎力：思科网络、华为、惠普。 
>
> 

以太网被设计为总线型结构，一根主线贯穿始末，在主线上“分叉”来连接主机。 这一设计简单、便捷、灵活性强，随时可以添加、删除主机，方便非专业人士组网。因此，以太网很快流行开来。 

4.从共享总线到交换式 

以太网工作的原理我们弄清楚了。我们需要给这套机制起个名字。虽然原理并不复杂，但名字却有些绕口——CSMA/CD（载波侦听多路复用-冲突检测），这是以太网的精髓所在！ CDMA/CD是使以太网成为其垄断局域网技术的关键因素。其最大优势就是：简单！ 简单的东西，优势是简单。 简单的东西，劣势也是简单。 一根总线，被多台主机共享，其工作效率将会被降得很低。这就像那场会议，来的都是绅士，彬彬有礼、有条不紊，但会议所花费时间却很长。 更为重要的是，这种“一个说，大家听”的特质是其在安全上的弱点，因为网络上任何主机都可以选择是否监听线路上传输的所有信息。说给你听的，你听，没说给你听的，你也可以听，哪有隐私可言，哪有安全可言！ 这种模式的以太网被称为共享式以太网，以细缆（被称为10Base2，2是指最远可传送接近200m）、粗缆（被称为10Base5，铜缆传送距离最远可达500m）和HUB+以太双绞线（从三类线到六类线或者更高，最常用的是五类线或超五类线）为传送介质组建网络，其安全问题和效率问题一直被人们诟病。如果这种趋势发展下去，随着应用越来越广泛，其被取代只是时间问题。 幸运的是，1990年，**交换式以太网技术诞生了**。它能同时提供多条传输路径，从而显著提高网络的整体带宽，同时也为网络安全性提供了保证。**交换式以太网核心设备是以太网交换机，而非共享总线**。CSMA-CD依然有效，但共享总线结构的传统模式被彻底颠覆了！ 下面是共享总线型以太网、以HUB为中心的以太网和交换式以太网的区别示意图。 为了最大程度的减少冲突，提高网络速度和使用效率，当今的以太网大都以以太网交换机为核心来进行网络连接和组织，这样，以太网的拓扑结构就成了星型。  



![image-20210722164215111](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210722164215111.png)

以太网交换机根据其处理的协议层不同，分为二层交换机和三层交换机（现在根据市场需要，商家们还提出了4层、7层交换机）。这里的“层”是指ISO/OSI的7层结构。二层是指数据链路层，也就是处理以太网帧的相关操作，三层是指IP层，处理IP层的操作。 二层交换机在操作过程中不断地收集资料，并建立它本身的地址表，这个表并不复杂，主要标明每个MAC地址是在哪个端口上被发现的。当交换机接收到一个数据包时，会检查该数据包的目的地址，检索一下自己的地址表，并决定把数据包从哪个端口发出去。 这与HUB不同。HUB组成的共享式以太网，某个站点发送的数据会出现在HUB所有端口上（不管是否为其所需），不但效率低，安全性也差。 以太网交换机的引入，使得网络节点间可独享带宽。只有一个例外——对于二层广播报文（比如下文讲到的ARP公告），二层交换机会对所有主机广播——当然，这也是必须的。 当多个二层交换机用以太网线连接起来（称之为“级联”），二层交换网络上的所有设备都会收到广播消息。如果这个以太网太大，泛滥的广播信息会造成网络效率大幅降低。这就是令人头痛的==“广播风暴”==。 解决这个问题的方法，是在一个二层交换网络内进一步划分为多个虚拟的局域网（VLAN）。这里的“虚拟”，是“逻辑”的意思。也就是说，按照一定的逻辑关系将主机划分为若干群组，这种群组是逻辑组，和主机所在的物理位置无关。 在实际应用中，比如一个企业，可以把每个部门的计算机划分为一个VLAN；一个学校，把不同的院系划分为不同的VLAN。根据需要，可以把一个屋子的主机划分为两个VLAN，也可以把不同屋子的主机划分到同一个VLAN里面去。 



在一个VLAN内，由一台主机发出的信息只能被具有相同虚拟网编号的其他主机接收，局域网的其他成员则收不到这些信息。各部门、各院系、各处室内部广播“，井水不犯河水”。 因此有人把VLAN称为“广播域”.过去我们说，局域网之间可以直接进行通信，无需路由器。但是划分VLAN后，这种情况将发生变化——在一个以太网内的主机，如果被划分在不同的VLAN里，他们之间的通信，必须经过路由设备（路由器或者三层交换机）进行。 如果一个大型企业，局域网被划分为50个VLAN，VLAN之间的通信需要占用大量路由器端口和处理能力。解决了“广播风暴”，却带来了成本压力——路由器可不便宜，并且效率也会大打折扣。于是，三层交换的概念就在这种情况下被提出。 三层交换机是在二层交换机的基础上增加三层路由功能。 爱思考的读者第一感觉就是，只要把二层交换机的内核加上路由器的内核，组装在一起，不就是三层交换机了么？从理论上说，这是站得住脚的，但是在工业实践中，三层交换机和路由器采用的转发机制不完全相同。 早期的或者低端的路由器通常用软件来实现，转发能力成为瓶颈。三层交换机的路由查找是针对“流”的，它利用高速缓存技术，在成本不高的情况下实现快速转发。而传统路由器的转发采用最长匹配的方式，实现复杂，效率较低。 估计很多读者已经迫不及待地等待下一节内容了。





# 网络协议



![image-20210804202146925](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210804202146925.png)

![image-20210804202300103](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210804202300103.png)

![image-20210804203005488](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210804203005488.png)

![image-20210809003808529](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210809003808529.png)

![image-20210809005313670](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210809005313670.png)

![image-20210809005540303](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210809005540303.png)

![image-20210809005712036](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210809005712036.png)



![image-20210811204501278](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210811204501278.png)

![image-20210811204533559](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210811204533559.png)

![image-20210811204617450](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210811204617450.png)



![image-20210812224104157](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210812224104157.png)









# 信息大脑——主机 

主机从来都觉得自己是IP世界的主人，IP世界所有其他元素都是为它服务的。 没错，站在自己的角度看世界，谁都会认为自己是绝对的主角。 TCP/IP世界的信息，是在主机之间进行交互的。PC、服务器、工控机，这些都是主机！还有人会问，上网本是不是主机？各种PAD是不是主机？智能手机是不是主机？这些问题的确让我们有点难以回答。广义点讲，具有计算、存储能力的通信终端，都可以归为主机，本书并不打算过多地纠缠于这些概念的严肃厘清（其实再严肃也很难厘清），这方面的似是而非无伤大雅。 

服务器是一种运行管理软件以控制对网络或网络资源（磁盘驱动器、打印机等）进行访问的计算机，并能够为在网络上的计算机提供资源，使其犹如工作站那样地进行操作。 工控机（Industrial Personal Computer）是一种加固的增强型个人计算机，它可以作为一个工业控制器在工业环境中可靠运行。 我们知道，在工业现场，一般都有强烈的震动，灰尘特别多，还有很高的电磁场干扰，并且一般工厂都是连续作业的，工人三班倒，计算机极少关机。 

.虚拟主机 

一台服务器，只提供一种资源，这种资源对硬件和带宽的要求并不高，无论是CPU、内存还是硬盘，都是一种浪费。能不能在这台服务器上运行多个应用呢？ 虚拟主机将在这样的应用中大显身手。 虚拟主机是在网络服务器上划分出一定的磁盘空间供用户放置站点和应用组件，提供必要的站点功能与数据存放，以及必要的传输功能。 CPU和内存，可以同时处理多个进程；硬盘是文件系统，多个应用之间并不冲突，甚至还互相有关联。 这一方案的出现，对IP世界产生了重大贡献！由于多台虚拟主机共享一台真实主机的资源，每个用户承受的硬件费用、网络维护费用、通信线路费用均大幅度降低，互联网真正成为人人用得起的网络，这对中小企业而言意义重大。 每一个虚拟主机都具有独立的域名和完整的互联网服务器（支持WWW、FTP、电子邮箱或其他互联网服务）功能。从用户角度根本看不出他们在同一台服务器上。 当然，虚拟主机不是万能的，它也会受到性能限制。一台主机只能够支持一定数量的虚拟主机，具体数量视主机性能而定；当超过这个数量时，性能急剧下降。 虚拟主机暂时介绍到这里，在云计算一节里，我们还会提到一个与此类似的概念——虚拟化。 





![image-20210803104432474](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210803104432474.png)

![image-20210803113248009](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210803113248009.png)

![image-20210803113342285](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210803113342285.png)





## MAC地址

MAC这个名词的英文全称是Media Access Control，是指“媒体访问控制”。可以把它理解为信号在通信线路介质传送中的一种最基本的管理和控制能力。 这里的“管理”，是指通过某些标准化操作，避免传送发生错误；而“控制”，是指通过某些标准化操作，让信号按照既定策略传送和转换。媒体访问控制，其实就是对物理层传送的0和1进行最基本的管理和控制。通过MAC层，将物理层获取的信号送到更高层去处理，让更高层专注于路由、传输和应用，无须操心底层的传送过程
以太网的每一个节点（网卡、交换机和路由器的每个端口）都具有一个MAC地址（也就是物理地址），由IEEE统一管理。由设备商固化在设备中。MAC地址长度为48位二进制，前24位由设备商标识符，后24位是设备商自行分配的序列号，常表示为12位的十六进制数。如MAC地址000000001110000011111100001110011000000000110100，表示为十六进制是00e0.fc39.8034或00e0fc398034或00-e0-fc-39-80-34。 MAC地址就像身份证号码一样具有唯一性。当然，这种唯一性也不是绝对的。身份证还能造假，更何况MAC地址。 











# 应用层

应用层协议很多

 ping是应用程序，而不是协议，前面说过它利用ICMP报文检测网络连接，是调试网络环境的必备工具。 telnet协议是一种远程登录协议，它使我们能在本地完成远程任务，Ping命令是常用的命令之一，一般用于侦测本机到目标主机的网络是否畅通。

OSPF（Open Shortest Path First，开放最短路径优先）协议是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。 DNS（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。 应用层协议（或程序）可能跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议（或程序）通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。 



## DNS协议

用户使用终端（电脑、手机、Pad 等）上网时，电脑会设置一组 DNS
（即缓存DNS，又叫Local DNS）作为一层“代理”、“缓存”，为当地局域网
或其他用户提供高性能的解析迭代查询。这个缓存DNS一般是在用户连上网
时自动分配的，不需要手工配置。当用户访问网站时，如
www.example.com，会向缓存 DNS发送example对应的地址的查询请求。当
缓存DNS收到请求后，如果其有相应的缓存且没过期，则直接响应；否则，
向根DNS、顶级域DNS、主域名对应的权威DNS或更下级的权威DNS进行查
询，直到查询到最终的地址，然后返回给客户端。

我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux使用/etc/resolv.conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下： 

![image-20210830133329324](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210830133329324.png)

Linux下一个常用的访问DNS服务器的客户端程序是host，比如下面的命令是向首选DNS服务器查询机器www.baidu.com的IP地址： 

root@iZuf64cvuzy0uruzobicmgZ:~# host -t A www.baidu.com
www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 112.80.248.75
www.a.shifen.com has address 112.80.248.76

host命令的输出告诉我们，机器名www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。host命令使用DNS协议和DNS服务器通信，其-t选项告诉DNS协议使用哪种查询类型。我们这里使用的是A类型，即通过机器的域名获得其IP地址（但实际上返回的资源记录中还包含机器的别名）。关于host命令的详细使用方法，请参考其man手册。 



## socket和TCP/IP协议族的关系

![image-20210830133813489](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210830133813489.png)

​                             图1-1　TCP/IP协议族体系结构及主要协议 

 前文提到，数据链路层、网络层、传输层协议是在内核中实现的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的API（Application Programming Interface，应用程序编程接口）主要有两套：socket和XTI。XTI现在基本不再使用，本书仅讨论socket。图1-1显示了socket与TCP/IP协议族的关系。 由socket定义的这一组API提供如下两点功能：**一是将应用程序数据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，**以交付内核来发送数据，或者是从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区，以读取数据；**二是应用程序可以通过它们来修改内核中各层协议的某些头部信息或其他数据结构**，从而精细地控制底层通信的行为。比如可以通过setsockopt函数来设置IP数据报在网络上的存活时间。我们将在第5章详细讨论这一组API。 值得一提的是，socket是一套通用网络编程接口，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈（比如X.25协议栈、UNIX本地域协议栈等）。  



- [ ] 

一些web知识

# 对外提供的API如何保证幂等?

举例说明:银联提供的付款接口:需要接入商户提交付款请求时附帯: source来源,seq序列号source+seq在数据库里面做准一索引,防止多次付款（井发）时,只能处理一个请求
重点:对外提供接口为了支持写等调用,接口有两个字段必须传,一个是来源 source,另一个是来源方序列号seq,这个两个字段在提供方系统里面做联合唯一索引,这样当第三方调用时,先在本方系统里面查询一下,是否已经处理过,返回相应处理结果;没有处理过,进行相应处理,返回结果
注意,为了幂等友好,一定要先查词一下,是否处理过该笔业务,不查询直接插入业务系统,会报错,但实际已经处理

# token放redis

用拦截器统一拦截Controller层，在访问之前先校验token

将userid+token作为key-value放入redis中

[SpringBoot整合Redis（三 ) 将登录成功产生的token存入redis_帅帅的小哥哥的博客-CSDN博客_token存redis](https://blog.csdn.net/qq_42547698/article/details/90071529?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1)

# 什么是 Token?什么是JWT?如何基于 Token进行身份验证?

我们知道 Session信息需要保存一份在服务器端。这种方式会带来一些麻烦,比如需要我们保证保存 Session信思服务器的可用性、不适合移动端(不依赖 Cookie)等
有没有一种不需要自己存放 Session信息就能实现身份验证的方式呢?使用 Token即可JWT( SON WebToken)就是这种方式的实现,通过这种方式服务器端就不需要保存 Session数据了,只用在客户端保存服务端返回给客户的 Token就可以了,扩履性得到提升
**JWT本质上就一段签名的JSON格式的数据。由于它是帯有签名的,因此接收者便可以验证它的真实性**

JWT由3部分构成
Header描述MT的元数据。定义了生成签名的算法以及 Token的类型。
Payload(负载):用来存放实际需要传递的数据
Signature(签名):服务器通过 Payload、 Header和一个密钥 secret)使用 Header里面指定的签名算法(默认是HMAC SHA256)生成
在基于 Token进行身份验证的的应用程序中,服务器通过 Payload、 Headers和一个密钥 secret)的建令牌( Token)并将 Token发送给客户端,**客户端将 Token保存在 Cookie或者localstorage里面,以后客户端发出的所有请求都会携带这个令牌（你可以把它放在cookie里自动发送，但这样不能跨域，所以更好的做法是放在http header的Authorization字段中**：Authorization: Bearer Token

流程：用户向服务器发送用户名和密码登录系统

身份验证服务响应并返回了签名的jwt,上面包含了用户是谁的内容。

用户以后每次向后端发请求都在header中带上jwt.

服务端检查jwt并从中获取用户信息。

## 为什么 Cookie无法防止CSRF攻击,而 token可以

CSRF( Cross Site Request Forgery)-般被甜译为站请求伪造。那么什么是站请求伪造呢?说简单一点用你的身份去发送一些对你不友好的请求,举个简单例子:
小壮登录了某网上银行,他来到了网上银行的帖子区,看到一个帖子下面有一个链接写着科学理财,年收益率70%°,小杜好奇的点开了这个链接,结果发现自己的账户少了10000元,这是这么回事呢?原来黑客在链接中藏了一个请求,这个请求直接利用小社的身份给银行发送了一个转账请求也就是通过你的 Cookie向银行发出请求<asrc=htpi/www.mybank.com/Transfer?banked=11&money.=10000科学理财,年收益率70%<,原因是进行 Session认证的时候,我们一般使用 Cookie来存储 Session,当我们登陆后后端生成个 Session放在
Cookie中返回给客户端,服务端通过 Redis或者其他存储工具记录保存着这个5 ession,客户端登录以后每次请求都会带上这个 Session,服务端通过这个 Session来标示你这个人。如果别人通过 cookie拿到了 Session后就可以代皆你的身份访问系统了
**Session认证中 Cookie中的 Session是由览器发送到服务端的,借助这个特性,攻击者就可以通过让用户误点攻击链接,达到攻击效果**
但是,我们使用 token的话就不会存在这个问题,在我们登录成功获得 token之后,一般会选择存放在locastorage中。然后我们在前端通过某些方式会始每个发到后端的请求加上这个 token.这样就不会出现CSRF同的问题。因为,即使有个你点击了非法链接发送了请求到服务端,这个非法请求是不会携帯 token的,所以这个请求将是非法的。







# 简单一次完整的 HTTP 请求所经历的步骤？

1、DNS 解析(通过访问的域名找出其IP 地址，递归搜索)。
2、HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手。
如果是 HTTPS 请求，会略微有不同。
3.1、客户端向服务器发送请求命令（一般是 GET 或 POST 请求）。
（这个是补充内容，面试一般不用回答。
客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。）
3.2、客户端发送请求头信息和数据。
4.1、服务器发送应答头信息。
4.2、服务器向客户端发送数据。
5、服务器关闭 TCP 连接（4次挥手）。
这里是否关闭 TCP 连接，也根据 HTTP Keep-Alive 机制有关。
同时，客户端也可以主动发起关闭 TCP 连接。
6、客户端根据返回的HTML 、CSS 、JS 进行渲染。

对于浏览器（客户端）获取服务器资源的详细步骤如下所示。 

步骤1，浏览器从输入的URL中解析出服务器的域名和端口号（如果没有端口号，则为80）。 

步骤2，浏览器将服务器的域名转化为服务器的IP地址。 

步骤3，基于服务器的IP地址及端口号，建立浏览器与服务器的TCP连接。 

步骤4，浏览器向服务器发送HTTP请求报文。 

步骤5，基于浏览器请求内容，服务器向浏览器返回相应的HTTP响应报文。 

步骤6，浏览器获取响应报文并解析报文。

步骤7，关闭连接。 

# 安全问题

**什么是XSS攻击**

XSS跨站脚本攻击:黑客想尽一切方法 将一段脚本内容放到目标网站的目标浏览器上解释执行!!




# 分布式Session问题

之前的代码在我们之后一台应用系统，所有操作都在一台Tomcat上，没有什么问题。当我们部署多台系统，配合Nginx的时候会出现用户登录的问题
原因
由于 Nginx 使用默认负载均衡策略（轮询），请求将会按照时间顺序逐一分发到后端应用上。
也就是说刚开始我们在 Tomcat1 登录之后，用户信息放在 Tomcat1 的 Session 里。过了一会，请求又被 Nginx 分发到了 Tomcat2 上，这时 Tomcat2 上 Session 里还没有用户信息，于是又要登录。

解决方案：
1.Session复制
优点
无需修改代码，只需要修改Tomcat配置
缺点
Session同步传输占用内网带宽 多台Tomcat同步性能指数级下降
Session占用内存，无法有效水平扩展
2.前端存储
优点:不占用服务端内存
缺点:存在安全风险 数据大小受cookie限制 占用外网带宽 

3.Session粘滞
优点
无需修改代码 服务端可以水平扩展
缺点
增加新机器，会重新Hash，导致重新登录 应用重启，需要重新登录
4.后端集中存储
优点
安全 容易水平扩展
缺点 增加复杂度,需要修改代码



---------------------------------------解决分布式session的详细方法-------------

0、不使用session,改用jwt token



1、服务器实现的session 复制或session 共享，这类型的共享session 是和服务器紧密相关的，比如webSphere或JBOSS 在搭建集群时候可以配置实现session 复制或session 共享，但是这种方式有一个致命的缺点，就是不好扩展和移植，比如我们更换服务器，那么就要修改服务器配置。
2、利用成熟的技术做session复制，比如12306使用的gemfire，比如常见的内存数据库如redis 或memorycache，这类方案虽然比较普适，但是严重依赖于第三方，这样当第三方服务器出现问题的时候，那么将是应用的灾难。
3、将session 维护在客户端，很容易想到就是利用cookie，但是客户端存在风险，数据不安全，而且可以存放的数据量比较小，所以将session 维护在客户端还要对session 中的信息加密。
我们实现的方案可以说是第二种方案和第三种方案的合体，可以利用gemfire 实现session 复制共享，**还可以将session 维护在redis 中实现session 共享**，同时可以将session 维护在客户端的cookie 中，但是前提是数据要加密。
这三种方式可以迅速切换，而不影响应用正常执行。我们在实践中，首选gemfire 或者redis 作为session 共享的载体，一旦session 不稳定出现问题的时候，可以紧急切换cookie 维护session 作为备用，不影响应用提供服务。

4、使用nginx的ip绑定策略，同一个ip只能在指定的同一个机器访问，这样的话会失去负载均衡的意义

5、把Session存储在Redis中，这种方式不仅可以实现session共享，还可以增加redis服务器的方式水平拓展

==在单点登录中，如果cookie 被禁用了怎么办？==（2017-11-23-gxb）
单点登录的原理是后端生成一个 session ID，然后设置到 cookie，后面的所有请求浏览器都会带上 cookie，然后服务端从 cookie 里获取 session ID，再查询到用户信息。所以，保持登录的关键不是 cookie，而是通过cookie 保存和传输的 session ID，其本质是能获取用户信息的数据。除了 cookie，还通常使用 HTTP 请求头来传输。但是这个请求头浏览器不会像 cookie 一样自动携带，需要手工处理。

在微博或者微信进行评论的时候，比如你在朋友圈发了一张照片，朋友给你评论了，而你对朋友的评论进行了回复，这条朋友圈的显示中，你的回复必须在朋友之后，这是一个因果关系，而其他没有因果关系的数据，可以允许不一致。

会话一致性：将对系统数据的访问过程框定在了一个会话当中，约定了系统能保证在同一个有效的会话中实现“读己之所写”的一致性，就是在你的一次访问中，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。实际开发中有分布式的 Session 一致性问题，可以认为是会话一致性的一个应用。

# 状态码

## 401和403的 301和302

401 Unauthorized
状态码401标识认证失败，表示请求没有被认证或者认证失败。
通常由web服务器返回，而不是web应用。
场景：token失效、token缺失、token伪造，导致服务端无法识别身份。
403 Forbidden
状态码403表示授权失败，通常表示用户通过了身份验证，但缺少权限对给定的资源进行访问或者操作。
通常由web应用返回。
场景：用户登录成功，但是无权进行读写操作。

　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取
 （用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。

　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；

　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301

# 鉴权方式

我们常用的鉴权有四种：

1、HTTP Basic Authentication

2、session-cookie

3、Token 验证

4、OAuth(开放授权)

## 4.1 HTTP Basic Authentication

这种授权方式是浏览器遵守http协议实现的基本授权方式,HTTP协议进行通信的过程中，HTTP协议定义了基本认证认证允许HTTP服务器对客户端进行用户身份证的方法。

认证过程：

1． 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个ajax异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器:

Get /index.html HTTP/1.0
Host:www.google.com

2． 服务器向客户端发送验证请求代码401,（WWW-Authenticate: Basic realm=”google.com”这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）服务器返回的数据大抵如下：

HTTP/1.0 401 Unauthorised
Server: SokEvo/1.0
WWW-Authenticate: Basic realm=”google.com”
Content-Type: text/html
Content-Length: xxx

3． 当符合http1.0或1.1规范的客户端（如IE，FIREFOX）收到401返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。

4． 用户输入用户名和密码后，将用户名及密码以BASE64加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：

Get /index.html HTTP/1.0
Host:www.google.com
Authorization: Basic d2FuZzp3YW5n

注：d2FuZzp3YW5n表示加密后的用户名及密码（用户名：密码 然后通过base64加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）

5． 服务器收到上述请求信息后，将Authorization字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端。

![image-20220305120432847](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220305120432847.png)

服务器将Authorization header中的用户名密码取出，进行验证， 如果验证通过，将根据请求，发送资源给客户端。

示例代码:

```java
public class SecurityInterceptor implements HandlerInterceptor {

  private static final String SESSION_KEY = "SESSION_KEY";

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        HttpSession session = request.getSession();

        Object SESSION_OBJECT = session.getAttribute(SESSION_KEY);

        if(SESSION_OBJECT != null) { return true; }

        String authorization = request.getHeader("authorization");
        if(StringUtils.isNotEmpty(authorization)) {

            String authorizationString[] = authorization.split(" ");

            if(authorizationString.length == 2) {

                String base64String = authorizationString[1];
                String accountString = new String(Base64.decodeBase64(base64String), Charset.forName("UTF-8"));
                String account[] = accountString.split(":");

                if(account.length == 2) {

                    String password = "test";

                    AccountService accountService = (AccountService) SpringApplicationContext.getBean("AccountService");

                   Account account = accountService.getAccount();



                    if(StringUtils.equals("test", account[0]) && StringUtils.equals(password, account[1])) {

                        session.setAttribute(SESSION_KEY, true);

                        return true;
                    }
                }
            }
        }

        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);//401
        response.setCharacterEncoding("UTF-8");
        response.setHeader("WWW-Authenticate", "Basic realm=\"STOP!\"");
        response.setHeader("Content-Type", "text/html");

        response.getWriter().print("<!DOCTYPE HTML><html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /></head><body align=\"center\"><h3>没有权限，慎入！！！</h3></body></html>");

        return false;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

        //DO NOTHING!!!
    }
}
```

认证之后将认证信息放在session，以后在session有效期内就不用再认证了。

## 4.2 session-cookie

![image-20210822152903362](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210822152903362.png)

HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。**通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态**。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。

Cookie主要用于以下三个方面：

会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
个性化设置（如用户自定义设置、主题等）
浏览器行为跟踪（如跟踪分析用户行为等）
认证过程

服务器在接受客户端首次访问时在服务器端创建seesion，然后保存seesion**(我们可以将seesion保存在内存中，也可以保存在redis中，推荐使用后者)**，然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。

签名。这一步只是对sid进行加密处理，服务端会根据这个secret密钥进行解密。（非必需步骤）

浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求de 请求头中会带上该域名下的cookie信息。

服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法。

一旦用户登出，服务端和客户端同时销毁该会话在后续请求中，服务器会根据数据库验证会话id，如果验证通过，则继续处理；

## 4.3 Token 验证

认证过程

用户输入登陆凭据；
服务器验证凭据是否正确，然后返回一个经过签名的token；
客户端负责存储token，可以存在localstorage，或者cookie中
对服务器的请求在header中带上这个token；（Header 的Authorization字段）
服务器对JWT进行解码，如果token有效，则处理该请求；
一旦用户登出，客户端销毁token。
cookie与token看上去很像，那么他们到底有什么区别呢？

cookie与token性能对比

sessionid 他只是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的session，这里面才保存着用户的登陆状态。但是token本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个token是否合法就行。
session-cookie是需要cookie配合的，居然要cookie，那么在http代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的cookie,然后每次请求再默认带上该域名下的cookie。但是我们知道http代理客户端不只有浏览器，还有原生APP等等，这个时候cookie是不起作用的，或者浏览器端是可以禁止cookie的，但是token就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的cookie,storage，或者内存中，然后再下一次请求的请求头重带上这个token就行了。简单点来说cookie-session机制他限制了客户端的类型，而token验证机制丰富了客户端类型。
时效性。session-cookie的sessionid实在登陆的时候生成的而且在登出事时一直不变的，在一定程度上安全就会低，而token是可以在一段时间内动态改变的。
可扩展性。token验证本身是比较灵活的，<font color="red">**一是token的解决方案有许多，常用的是JWT，二来我们可以基于token验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权**。</font>

## 为什么token可以避免跨站请求伪造？

![image-20220214025630863](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220214025630863.png)

## 4.4 OAuth(开放授权)

OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。

我们常见的提供OAuth认证服务的厂商有支付宝，QQ，微信。

OAuth协议又有1.0和2.0两个版本。相比较1.0版，2.0版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。

典型案例

果一个用户拥有两项服务：一项服务是图片在线存储服务A，另一个是图片在线打印服务B。由于服务A与服务B是由两家不同的服务提供商提供的，所以用户在这两家服务提供商的网站上各自注册了用户，假设这两个用户名各不相同，密码也各不相同。

当用户要使用服务B打印存储在服务A上的图片时，用户该如何处理？

方法一：用户可能先将待打印的图片从服务A上下载下来并上传到服务B上打印，这种方式安全但处理比较繁琐，效率低下；

方法二：用户将在服务A上注册的用户名与密码提供给服务B，服务B使用用户的帐号再去服务A处下载待打印的图片，这种方式效率是提高了，但是安全性大大降低了，服务B可以使用用户的用户名与密码去服务A上查看甚至篡改用户的资源。

方法三：当服务B（打印服务）要访问用户的服务A（图片服务）时，通过OAUTH机制，服务B向服务A请求未经用户授权的RequestToken后，服务A将引导用户在服务A的网站上登录，并询问用户是否将图片服务授权给服务B。用户同意后，服务B就可以访问用户在服务A上的图片服务。整个过程服务B没有触及到用户在服务A的帐号信息。

OAuth相关术语

在认证和授权的过程中涉及的三方包括：

服务提供方（ServiceProvider），用户使用服务提供方来存储受保护的资源，如照片，视频，联系人列表。

用户（User），存放在服务提供方的受保护的资源的拥有者

客户端（Consumer），要访问服务提供方资源的第三方应用，通常是网站，如提供照片打印服务的网站也可以是桌面或移动应用程序。在认证过程之前，客户端要向服务提供者申请客户端标识。

OAuth相关的三个URL：

RequestToken URL:获取未授权的RequestToken服务地址；

UserAuthorization URL:获取用户授权的RequestToken服务地址；

AccessToken URL:用授权的RequestToken换取AccessToken的服务地址。


OAuth认证和授权过程

客户端（第三方软件）向OAUTH服务提供商请求未授权的RequestToken。即向RequestToken URL发起请求；
OAUTH服务提供商同意使用者的请求，并向其颁发未经用户授权的oauth_token与对应的oauth_token_secret，并返回给使用者；
使用者向OAUTH服务提供商请求用户授权的RequestToken。即向UserAuthorization URL发起请求并在请求中携带上一步服务提供商颁发的未授权的token与其密钥；
OAUTH服务提供商通过网页要求用户登录并引导用户完成授权；
RequestToken授权后，使用者将向AccessToken URL发起请求，将上步授权的RequestToken换取成AccessToken。请求的参数见上图，这个比第一步多了一个参数就是RequestToken；
OAUTH服务提供商同意使用者的请求，并向其颁发AccessToken与对应的密钥，并返回给使用者；
使用者以后就可以使用上步返回的AccessToken访问用户授权的资源。
简单整理就三个步骤

获取未授权的RequestToken
获取用户授权的RequestToken
用授权的RequestToken换取AccessToken





# Session/Cookie/Token 



Session、Cookie 与 Application
**Cookie和Session都是客户端与服务器之间保持状态的解决方案**，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。
1、Cookie 及其相关 API ：
Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

Cookie 的实现过程：

Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

也就是 Cookie 是服务器生成的，但是发送给客户端，并且由客户端来保存。每次请求加上 Cookie就行了。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。


2、Session 及其相关 API：
同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 cookie机制 ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；**若浏览器禁用Cookie的话，可以通过 URL重写机制将sessionid传回服务器。**（？）







浏览完了就走了，两个连接之间是没有任何联系的，这也是 HTTP 为无状态的原因，因为它诞生之初就没有这个需求。

但随着交互式 Web 的兴起（所谓交互式就是你不光可以浏览，还可以登录，发评论，购物等用户操作的行为），单纯地浏览 web 已经无法满足人们的要求，比如随着网上购物的兴起，需要记录用户的购物车记录，就需要有一个机制记录每个连接的关系，这样我们就知道加入购物车的商品到底属于谁了，于是 Cookie 就诞生了。

> Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行 Session 跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。

Cookie 是web 服务器发送给浏览器的一块信息，==**浏览器会在本地一个文件中给每个web 服务器存储cookie**。==以后浏览器再给特定的web 服务器发送请求时，同时会发送所有为该服务器存储的cookie。


cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，**就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来**。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。

Session 是存储在web 服务器端的一块信息。session 对象存储特定用户会话所需的属性及配置信息。当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。

Cookie 和session 的不同点：
1、无论客户端做怎样的设置，session 都能够正常工作。当客户端禁用cookie 时将无法使用cookie。

2、在存储的数据量方面：session 能够存储任意的java 对象，cookie 只能存储String 类型的对象。

存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；
存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制
占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。



工作机制如下

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugzL74BPzERPgDyibiaEEBFicZrjvvmf6FFJfcsMOPvIMEv1UF0I3DaQZGQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

以加入购物车为例，每次浏览器请求后 server 都会将本次商品 id 存储在 Cookie 中返回给客户端，客户端会将 Cookie 保存在本地，下一次再将上次保存在本地的 Cookie 传给 server 就行了，这样每个 Cookie 都保存着用户的商品 id，购买记录也就不会丢失了

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMug0PeAFeR4ia0SAicHaXASxwHTXbEHOtHqoz9PMuE8ic5knsibpxfwwGD0nA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

仔细观察上图相信你不难发现随着购物车内的商品越来越多，每次请求的 cookie 也越来越大，这对每个请求来说是一个很大的负担，我只是想将一个商品加入购买车，为何要将历史的商品记录也一起返回给 server ？购物车信息其实已经记录在 server 了，浏览器这样的操作岂不是多此一举？怎么改进呢

### Session

session是依赖Cookie实现的。session是服务器端对象
session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。

1.服务端session是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个session都分配一个唯一的sessionid，以保证每个用户都有一个不同的session对象。
 2.服务器在创建完session后，会把sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。
3.session通常有失效时间的设定，比如2个小时。当失效时间到，服务器会销毁之前的session，并创建新的session返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的失效时间根据当前的请求时间再延长2个小时。
4.session在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往sesssion对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的session对象里的登录凭证清掉。所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的。



\1. 为什么要有session的出现？
答：是由于网络中http协议造成的，因为http本身是无状态协议，这样，无法确定你的本次请求和上次请求是不是你发送的。如果要进行类似论坛登陆相关的操作，就实现不了了。

\2. session生成方式？
答：浏览器第一次访问服务器，服务器会创建一个session，然后同时为该session生成一个唯一的会话的key,也就是sessionid，然后，将sessionid及对应的session分别作为key和value保存到缓存中，也可以持久化到数据库中，然后服务器再把sessionid，以cookie的形式发送给客户端。这样浏览器下次再访问时，会直接带着cookie中的sessionid。然后服务器根据sessionid找到对应的session进行匹配；

很多时候我们通过sessionid来识别用户，Sessionid可以存放在redis中，比如：登录系统后返回给客户端带有sessionid的cookie，当用户端发起请求时会把Sessionid带上

仔细考虑下，由于用户的购物车信息都会保存在 Server 中，所以在 Cookie 里只要保存能识别用户身份的信息，知道是谁发起了加入购物车操作即可，这样每次请求后只要在 Cookie 里带上用户的身份信息，请求体里也只要带上本次加入购物车的商品 id，大大减少了 cookie 的体积大小，**我们把这种能识别哪个请求由哪个用户发起的机制称为 Session（会话机制），生成的能识别用户身份信息的字符串称为 sessionId，它的工作机制如下**

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugHRn2G9xyggKhcicwUAZ7whCU7f4pQeyoJwdZbUYP5ibSFVVriaCAV4mfA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

1. 首先用户登录，server 会为用户生成一个 session，为其分配唯一的 sessionId，这个 sessionId 是与某个用户绑定的，也就是说根据此 sessionid（假设为 abc） 可以查询到它到底是哪个用户，然后将此 sessionid 通过 cookie 传给浏览器
2. 之后浏览器的每次添加购物车请求中只要在 cookie 里带上 sessionId=abc 这一个键值对即可，server 根据 sessionId 找到它对应的用户后，把传过来的商品 id 保存到 server 中对应用户的购物车即可

可以看到通过这种方式再也不需要在 cookie 里传所有的购物车的商品 id 了，大大减轻了请求的负担！

另外通过上文不难观察出 **cookie 是存储在 client 的，而 session 保存在 server**，sessionId 需要借助 cookie 的传递才有意义。

### session 的痛点

看起来通过  cookie + session 的方式是解决了问题， 但是我们忽略了一个问题，上述情况能正常工作是因为我们假设 server 是单机工作的，但实际在生产上，为了保障高可用，一般服务器至少需要两台机器，通过负载均衡的方式来决定到底请求该打到哪台机器上。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugLdH5ibIV6Thibvic5Qm0zaDyW8eIp3voibfHvc1icwMfX7GicUZnYDibWnWBQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)balance

**如图示：客户端请求后，由负载均衡器（如 Nginx）来决定到底打到哪台机器**

假设登录请求打到了 A 机器，A 机器生成了 session 并在 cookie 里添加 sessionId 返回给了浏览器，那么问题来了：下次添加购物车时如果请求打到了 B 或者 C，由于 session 是在 A 机器生成的，此时的 B,C 是找不到 session 的，那么就会发生无法添加购物车的错误，就得重新登录了，此时请问该怎么办。主要有以下三种方式

> 1、session 复制

A 生成 session 后复制到 B, C，这样每台机器都有一份 session，无论添加购物车的请求打到哪台机器，由于 session 都能找到，故不会有问题

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugHeLZGsEod55pXopkFU3ewWKxtrJ3gONNaM2ibenQlWdkxXHKXyU0XDA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)balance (1)

这种方式虽然可行，但缺点也很明显：

1. 同一样的一份 session 保存了多份，数据冗余
2. 如果节点少还好，但如果节点多的话，特别是像阿里，微信这种由于 DAU 上亿，可能需要部署成千上万台机器，这样节点增多复制造成的性能消耗也会很大。

> 2、session 粘连

这种方式是让每个客户端请求只打到固定的一台机器上，比如浏览器登录请求打到 A 机器后，后续所有的添加购物车请求也都打到 A 机器上，Nginx 的 sticky 模块可以支持这种方式，支持按 ip 或 cookie 粘连等等，如按 ip 粘连方式如下

```
upstream tomcats {
  ip_hash;
  server 10.1.1.107:88;
  server 10.1.1.132:80;
}
```

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugV4JCovgSvfhc86NG0xQdicsoUD4UDU1PFWGOLN1qLqJSuX0iaJhmPvjg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

这样的话每个 client 请求到达 Nginx 后，只要它的 ip 不变，根据 ip hash 算出来的值会打到固定的机器上，也就不存在 session 找不到的问题了，当然不难看出这种方式缺点也是很明显，对应的机器挂了怎么办？



> 3、session 共享

这种方式也是目前各大公司普遍采用的方案，将 session 保存在 redis，memcached 等中间件中，请求到来时，各个机器去这些中间件取一下 session 即可。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugYynZic3IlPRYEwerUd6lria6kGo8d4SV5efU7ia05gEkZsDVsJ2cEbbNA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

缺点其实也不难发现，就是每个请求都要去 redis 取一下 session，多了一次内部连接，消耗了一点性能，另外为了保证 redis 的高可用，必须做集群，当然了对于大公司来说, redis 集群基本都会部署，所以这方案可以说是大公司的首选了。

🔷🔷Session 与 Cookie 的对比：
实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；
大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；
安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；
服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。







### Token：no session!



通过上文分析我们知道通过在服务端共享 session 的方式可以完成用户的身份定位，但是不难发现也有一个小小的瑕疵：搞个校验机制我还得搭个 redis 集群？大厂确实 redis 用得比较普遍，但对于小厂来说可能它的业务量还未达到用 redis 的程度，所以有没有其他不用 server 存储 session 的用户身份校验机制呢，这就是我们今天要介绍的主角：token。

==首先请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可。==

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugdxicQQmpjVu3JtpPAPc9ldWFCibAqn8k8iaDn0wXMBvWXl6b88f3pPVNQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

相信大家看了上图会发现存在两个问题

1、 token 只存储在浏览器中，服务端却没有存储，这样的话我随便搞个 token 传给 server 也行？

答：server 会有一套校验机制，校验这个 token 是否合法。

2、怎么不像 session 那样根据 sessionId 找到 userid 呢，这样的话怎么知道是哪个用户？

答：token 本身携带 uid 信息

第一个问题，如何校验 token 呢？我们可以借鉴 HTTPS 的签名机制来校验。先来看 jwt token 的组成部分

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugPWYEwl5c4y21ibILKz9cTBSY2ibW91KrjbPW057GMmut8E3ich1Btiad8A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

可以看到 token 主要由三部分组成

1. header：指定了签名算法
2. payload：可以指定用户 id，过期时间等非敏感数据
3. Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。

当 server 收到浏览器传过来的 token 时，它会首先取出 token 中的 header + payload，根据密钥生成签名，然后再与 token 中的签名比对，如果成功则说明签名是合法的，即 token 是合法的。而且你会发现 payload 中存有我们的 userId，所以拿到 token 后直接在 payload 中就可获取 userid，避免了像 session 那样要从 redis 去取的开销

**画外音：header, payload 实际上是以 base64 的形式存在的，文中为了描述方便，省去了这一步。**

你会发现这种方式确实很妙，只要 server 保证密钥不泄露，那么生成的 token 就是安全的，因为如果伪造 token 的话在签名验证环节是无法通过的，就此即可判定 token 非法。

可以看到通过这种方式有效地避免了 token 必须保存在 server 的弊端，实现了分布式存储，不过需要注意的是，token 一旦由 server 生成，它就是有效的，直到过期，无法让 token 失效，除非在 server 为 token 设立一个黑名单，在校验 token 前先过一遍此黑名单，如果在黑名单里则此  token 失效，但一旦这样做的话，那就意味着黑名单就必须保存在 server，这又回到了 session 的模式，那直接用 session 不香吗。所以一般的做法是当客户端登出要让 token 失效时，直接在本地移除 token 即可，下次登录重新生成 token 就好。

另外需要注意的是 token 一般是放在 header 的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是为了解决跨域不能共享 Cookie 的问题 （下文详述）



\5. token和session的区别？
token和session其实都是为了身份验证，session一般翻译为会话，而token更多的时候是翻译为令牌；
session服务器会保存一份，可能保存到缓存，文件，数据库；同样，session和token都是有过期时间一说，都需要去管理过期时间；
其实token与session的问题是一种时间与空间的博弈问题，session是空间换时间，而token是时间换空间。两者的选择要看具体情况而定。

虽然确实都是“客户端记录，每次访问携带”，但 token 很容易设计为自包含的，也就是说，后端不需要记录什么东西，每次一个无状态请求，每次解密验证，每次当场得出合法 /非法的结论。这一切判断依据，除了固化在 CS 两端的一些逻辑之外，整个信息是自包含的。这才是真正的无状态。 
而 sessionid ，一般都是一段随机字符串，需要到后端去检索 id 的有效性。万一服务器重启导致内存里的 session 没了呢？万一 redis 服务器挂了呢？ 

方案 A ：我发给你一张身份证，但只是一张写着身份证号码的纸片。你每次来办事，我去后台查一下你的 id 是不是有效。 
方案 B ：我发给你一张加密的身份证，以后你只要出示这张卡片，我就知道你一定是自己人。 
就这么个差别。

token的使用可以参考：json web token(JWT);

APP利用token机制进行身份认证

用户在登录APP时，APP端会发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果验证成功，就会生成相应位数的字符产作为token存储到服务器中，并且将该token返回给APP端。

以后APP再次请求时，凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让用户重新登录。其中，服务器上会给token设置一个有效期，每次APP请求的时候都验证token和有效期。

token的存储

token可以存到数据库中，但是有可能查询token的时间会过长导致token丢失（其实token丢失了再重新认证一个就好，但是别丢太频繁，别让用户没事儿就去认证）。

**为了避免查询时间过长，可以将token放到内存中。这样查询速度绝对就不是问题了，也不用太担心占据内存，就算token是一个32位的字符串，应用的用户量在百万级或者千万级，也是占不了多少内存的。**

token的加密

token是很容易泄露的，如果不进行加密处理，很容易被恶意拷贝并用来登录。加密的方式一般有：

在存储的时候把token进行对称加密存储，用到的时候再解密。文章最开始提到的签名sign：将请求URL、时间戳、token三者合并，通过算法进行加密处理。

最好是两种方式结合使用。

还有一点，在网络层面上token使用明文传输的话是非常危险的，所以一定要使用HTTPS协议





### Cookie 与 Token 的简单总结

简单地说，cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie 是纯文本格式，不包含任何可执行的代码。一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web 服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个 cookie，只要这个 cookie 存在并可以，用户就可以自由浏览这个网站的任意页面。再次说明，cookie 只包含数据，就其本身而言并不有害。

同域情况下，Cookie会在随后的请求中携带

> Cookie 有哪些局限性？

1、 Cookie 跨站是不能共享的，这样的话如果你要实现多应用（多系统）的单点登录（SSO），使用 Cookie 来做需要的话就很困难了（要用比较复杂的 trick 来实现，有兴趣的话可以看文末参考链接）

cookie的一些应用案例：

1.保存已经登录过的用户信息，下次访问网站的时候也没自动帮你登陆的一些基本信息填了，此外cookie还能保存用户首选项、主题等设置信息

2.使用cookie保存session或token,向后端发送请求的时候带上cookie

**画外音: 所谓单点登录，是指在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。**

但如果用 token 来实现 SSO 会非常简单，如下

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugeC4RTg2easMQgNBmeyOUaXlnAEZr662lNbyuLTUAXFNRNlkqNHUsQA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)img

只要在 header 中的 authorize 字段（或其他自定义）加上 token 即可完成所有跨域站点的认证。

2、 在移动端原生请求是没有 cookie 之说的，而 sessionid 依赖于 cookie，sessionid 就不能用 cookie 来传了，如果用 token 的话，由于它是随着 header 的 authoriize 传过来的，也就不存在此问题，换句话说token 天生支持移动平台，可扩展性好

综上所述，token 具有存储实现简单，扩展性好这些特点。

> token 有哪些缺点

那有人就问了，既然 token 这么好，那为什么各个大公司几乎都采用共享 session 的方式呢，可能很多人是第一次听到 token，token 不香吗? token 有以下两点劣势：

1、 token 太长了

token 是 header, payload 编码后的样式，所以一般要比 sessionId 长很多，很有可能超出 cookie 的大小限制（cookie 一般有大小限制的，如 4kb），如果你在 token 中存储的信息越长，那么 token 本身也会越长，这样的话由于你每次请求都会带上 token，对请求来是个不小的负担

2、 不太安全

网上很多文章说 token 更安全，其实不然，细心的你可能发现了，我们说 token 是存在浏览器的，再细问，存在浏览器的哪里？既然它太长放在 cookie 里可能导致 cookie 超限，那就只好放在 local storage 里，这样会造成安全隐患，因为 local storage 这类的本地存储是可以被 JS 直接读取的，另外由上文也提到，token 一旦生成无法让其失效，必须等到其过期才行，这样的话如果服务端检测到了一个安全威胁，也无法使相关的 token 失效。

**所以 token 更适合一次性的命令认证，设置一个比较短的有效期**

误解: Cookie 相比 token 更不安全，比如 CSRF 攻击

首先我们需要解释下 CSRF 攻击是怎么回事

攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过（cookie 里带来 sessionId 等身份认证的信息），所以被访问的网站会认为是真正的用户操作而去运行。

比如用户登录了某银行网站（假设为 **http://www.examplebank.com/**，并且转账地址为 **http://www.examplebank.com/withdraw?amount=1000&transferTo=PayeeName**），登录后 cookie 里会包含登录用户的 sessionid，攻击者可以在另一个网站上放置如下代码

```
<img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman">
```

那么如果正常的用户误点了上面这张图片，由于相同域名的请求会自动带上 cookie，而 cookie 里带有正常登录用户的 sessionid，类似上面这样的转账操作在 server 就会成功，会造成极大的安全风险

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWubRiaj9icTuMphaGqbbQMugB7DH9UZxqKvqfxViaTING0L1nvLCaHQglzjoqoLXI27CqVs7BZqULaA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)csrf 示意图

CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的，所以很多人据此认定 cookie 不安全。

使用 token 确实避免了CSRF 的问题，但正如上文所述，由于 token 保存在 local storage，它会被 JS 读取，**从存储角度来看**也不安全（实际上防护 CSRF 攻击的正确方式是用 CSRF token）

所以不管是 cookie 还是 token，从存储角度来看其实都不安全，都有暴露的风险，我们所说的安全更多的是强调传输中的安全，可以用 HTTPS 协议来传输， 这样的话请求头都能被加密，也就保证了传输中的安全。

其实我们把 cookie 和 token 比较本身就不合理，一个是存储方式，一个是验证方式，正确的比较应该是 session vs token。

总结

session 和 token 本质上是没有区别的，都是对用户身份的认证机制，只是他们实现的校验机制不一样而已（一个保存在 server，通过在 redis 等中间件获取来校验，一个保存在 client，通过签名校验的方式来校验），多数场景上使用 session 会更合理，但如果在单点登录，一次性命令认证上使用 token 会更合适，最好在不同的业务场景中合理选型，才能达到事半功倍的效果。



**token的生成方式？**
答：浏览器第一次访问服务器，根据传过来的唯一标识userId，服务端会通过一些算法，如常用的HMAC-SHA256算法，然后加一个密钥，生成一个token，然后通过BASE64编码一下之后将这个token发送给客户端；客户端将token保存起来，下次请求时，带着token，服务器收到请求后，然后会用相同的算法和密钥去验证token，如果通过，执行业务操作，不通过，返回不通过信息；

\5. token和session的区别？
token和session其实都是为了身份验证，session一般翻译为会话，而token更多的时候是翻译为令牌；
session服务器会保存一份，可能保存到缓存，文件，数据库；同样，session和token都是有过期时间一说，都需要去管理过期时间；
其实token与session的问题是一种时间与空间的博弈问题，session是空间换时间，而token是时间换空间。两者的选择要看具体情况而定。 虽然确实都是“客户端记录，每次访问携带”，但 token 很容易设计为自包含的，也就是说，后端不需要记录什么东西，每次一个无状态请求，每次解密验证，每次当场得出合法 /非法的结论。这一切判断依据，除了固化在 CS 两端的一些逻辑之外，整个信息是自包含的。这才是真正的无状态。 
而 sessionid ，一般都是一段随机字符串，需要到后端去检索 id 的有效性。万一服务器重启导致内存里的 session 没了呢？万一 redis 服务器挂了呢？ 

## 如果没有了cookie session还能用吗？

如果是用cookie保存的话，cookie禁用以后Session无法正常工作，但可以把sessionid放在请求的url里面：http://xxx.cn?sessionid=xxx，为了增加安全性可以对sessionid进行一次加密

Cookie 与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。
但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。
假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：

1. 手动通过URL传值、隐藏表单传递Session ID。
2. 用文件、数据库等形式保存Session ID，在跨页过程中手动调用。

# websocket和http的区别

websocket和http的区别：1、WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息，而HTTP是单向的；2、WebSocket是需要浏览器和服务器握手进行建立连接的，而http是浏览器发起向服务器的连接。

一、WebSocket 是什么？

WebSocket是HTML5规范提出的一种协议；目前除了完犊子的IE浏览器，其他浏览器都基本支持。他是一种协议，万变不离其宗，也是基于TCP协议的；和HTTP协议是并存的两种协议。

WebSocket是HTML5中的协议。HTML5 Web Sockets规范定义了Web Sockets API，支持页面使用Web Socket协议与远程主机进行全双工的通信。它引入了WebSocket接口并且定义了一个全双工的通信通道，通过一个单一的套接字在Web上进行操作。

HTML5 Web Sockets以最小的开销高效地提供了Web连接。相较于经常需要使用推送实时数据到客户端甚至通过维护两个HTTP连接来模拟全双工连接的旧的轮询或长轮询（Comet）来说，这就极大的减少了不必要的网络流量与延迟。

要使用HTML5 Web Sockets从一个Web客户端连接到一个远程端点，你要创建一个新的WebSocket实例并为之提供一个URL来表示你想要连接到的远程端点。

该规范定义了ws://以及wss://模式来分别表示WebSocket和安全WebSocket连接,这就跟http:// 以及https:// 的区别是差不多的。

一个WebSocket连接是在客户端与服务器之间HTTP协议的初始握手阶段将其升级到Web Socket协议来建立的，其底层仍是TCP/IP连接。

二、WebSocket与Socket的关系

Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。

“Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，提供一套调用TCP/IP协议的API。

在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。”

当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。

WebSocket就像HTTP一样，则是一个典型的应用层协议。

![image-20220313112137421](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220313112137421.png)

相同点

都是一样基于TCP的，都是可靠性传输协议。

都是应用层协议。

**区别**

WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。

WebSocket是需要浏览器和服务器握手进行建立连接的。而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接。

WebSocket连接的过程是：

首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；

然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；

最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。

HTTP协议

`HTTP`是单向的，客户端发送请求，服务器发送响应。举例来说，当客户端向服务器发送请求时，该请求以`HTTP`或`HTTPS`的形式发送，在接收到请求后，服务器会将响应发送给客户端。每个请求都与一个对应的响应相关联，在发送响应后客户端与服务器的连接会被关闭。每个`HTTP`或`HTTPS`请求每次都会新建与服务器的连接，并且在获得响应后，连接将自行终止。 `HTTP`是在`TCP`之上运行的无状态协议，`TCP`是一种面向连接的协议，它使用三向握手方法保证数据包传输的传递并重新传输丢失的数据包。

`HTTP`可以运行在任何可靠的面向连接的协议（例如`TCP`，`SCTP`）的上层。当客户端将`HTTP`请求发送到服务器时，客户端和服务器之间将打开`TCP`连接，并且在收到响应后，`TCP`连接将终止，每个`HTTP`请求都会建立单独的`TCP`连接到服务器，例如如果客户端向服务器发送10个请求，则将打开10个单独的`HTTP`连接。并在获得响应后关闭。（这里应该不对，http1.1以后默认长连接)

***理解上面这段关于 `HTTP`的描述时我觉得还要了解一下`HTTP`长连接的概念，以及`HTTP`与`TCP`的关系，简单概括一下就是\***：

- ***`HTTP`协议的长连接和短连接，实质上是`TCP`协议的长连接和短连接。\***
- ***每个`HTTP`连接完成后，其对应的`TCP`连接并不是每次都会关闭。从 `HTTP/1.1`起，默认使用长连接，用以保持连接特性。使用长连接的`HTTP`协议，会在响应头有加入这个头部字段：`Connection:keep-alive`\***
- ***在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输`HTTP`数据的`TCP`连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。`Keep-Alive`不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如`Apache`，`Nginx`，`Nginx`中这个默认时间是 75s）中设定这个时间。实现长连接要客户端和服务端都支持长连接。\***
- ***`HTTP`属于应用层协议，在传输层使用`TCP`协议，在网络层使用`IP`协议。`IP`协议主要解决网络路由和寻址问题，`TCP`协议主要解决如何在`IP`层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。`TCP`有可靠，面向连接的特点。\***

HTTP消息信息是用`ASCII`编码的，每个`HTTP`请求消息均包含`HTTP`协议版本（`HTTP/1.1`，`HTTP/2`），`HTTP`方法（`GET`/`POST`等），`HTTP`标头（`Content-Type`，`Content-Length`），主机信息等。以及包含要传输到服务器的实际消息的正文（请求主体）。`HTTP`标头的大小从200字节到2`KB`不等，`HTTP`标头的常见大小是700-800字节。当`Web`应用程序在客户端使用更多`cookie`和其他工具扩展代理的存储功能时，它将减少`HTTP`标头的荷载。

### WebSocket协议

`WebSocket`是双向的，在客户端-服务器通信的场景中使用的全双工协议，与`HTTP`不同，它以`ws://`或`wss://`开头。**它是一个有状态协议，这意味着客户端和服务器之间的连接将保持活动状态，直到被任何一方（客户端或服务器）终止。在通过客户端和服务器中的任何一方关闭连接之后，连接将从两端终止。**

让我们以客户端-服务器通信为例，每当我们启动客户端和服务器之间的连接时，客户端-服务器进行握手随后创建一个新的连接，该连接将保持活动状态，直到被他们中的任何一方终止。建立连接并保持活动状态后，客户端和服务器将使用相同的连接通道进行通信，直到连接终止。

新建的连接被称为`WebSocket`。一旦通信链接建立和连接打开后，消息交换将以双向模式进行，客户端-服务器之间的连接会持续存在。如果其中任何一方（客户端服务器）宕掉或主动关闭连接，则双方均将关闭连接。套接字的工作方式与`HTTP`的工作方式略有不同，状态代码`101`表示`WebSocket`中的交换协议。

# spring读取 HTTP Cookie

Spring框架提供了注释来获取任何HTTP cookie的值，而无需迭代从请求中获取的所有cookie。此注释可用于将 Cookie 的值映射到控制器方法参数。`@CookieValue`

```java
@GetMapping("/")
public String readCookie(@CookieValue(value = "username", defaultValue = "Atta") String username) {
    return "Hey! My username is " + username;
}
```

要在Spring Boot中设置cookie，我们可以使用类的方法。您需要做的就是创建一个新的类实例并将其添加到响应中。`HttpServletResponse``addCookie()``Cookie`

```java
@GetMapping("/change-username")
public String setCookie(HttpServletResponse response) {
    // create a cookie
    Cookie cookie = new Cookie("username", "Jovan");

    //add cookie to response
    response.addCookie(cookie);

    return "Username is changed!";
}
```

除了使用注释之外，我们还可以使用该类作为控制器方法参数来读取所有 cookie。此类提供的方法将浏览器发送的所有 Cookie 作为 数组返回。`@CookieValue``HttpServletRequest``getCookies()``Cookie`

```java
@GetMapping("/all-cookies")
public String readAllCookies(HttpServletRequest request) {

    Cookie[] cookies = request.getCookies();
    if (cookies != null) {
        return Arrays.stream(cookies)
                .map(c -> c.getName() + "=" + c.getValue()).collect(Collectors.joining(", "));
    }

    return "No cookies";
}
```

如果没有为 Cookie 指定过期时间，则只要会话未过期，它就会持续存在。此类 Cookie 称为**会话 Cookie**。会话 Cookie 将保持活动状态，直到用户关闭其浏览器或清除其 Cookie。上面创建的 Cookie 实际上是会话 Cookie。`username`

但是，您可以覆盖此默认行为，并使用 class 方法设置 Cookie 过期时间。`setMaxAge()``Cookie`

```java
// create a cookie
Cookie cookie = new Cookie("username", "Jovan");
cookie.setMaxAge(7 * 24 * 60 * 60); // expires in 7 days

//add cookie to response
response.addCookie(cookie);
```

HttpOnly cookie 用于防止跨站点脚本 （XSS） 攻击，并且无法通过 JavaScript 的 API 访问。当为 Cookie 设置标志时，它会告诉浏览器此特定 Cookie 只能由服务器访问。`Document.cookie``HttpOnly`

```java
// create a cookie
Cookie cookie = new Cookie("username", "Jovan");
cookie.setMaxAge(7 * 24 * 60 * 60); // expires in 7 days
cookie.setSecure(true);
cookie.setHttpOnly(true);

//add cookie to response
response.addCookie(cookie);
```

# 单点登录

在 B/S 系统中，登录功能通常都是基于 Cookie 来实现的。当用户登录成功后，一般会将登录状态记录到 Session 中，或者是给用户签发一个 Token，无论哪一种方式，都需要在客户端保存一些信息（Session ID 或 Token ），并要求客户端在之后的每次请求中携带它们。在这样的场景下，使用 Cookie 无疑是最方便的，因此我们一般都会将 Session 的 ID 或 Token 保存到 Cookie 中，当服务端收到请求后，通过验证 Cookie 中的信息来判断用户是否登录 。

单点登录（Single Sign On, SSO）是指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的应用系统。举例来说，百度贴吧和百度地图是百度公司旗下的两个不同的应用系统，如果用户在百度贴吧登录过之后，当他访问百度地图时无需再次登录，那么就说明百度贴吧和百度地图之间实现了单点登录。

单点登录的本质就是在多个应用系统中共享登录状态。如果用户的登录状态是记录在 Session 中的，要实现共享登录状态，就要先共享 Session，比如可以将 Session 序列化到 Redis 中，让多个应用系统共享同一个 Redis，直接读取 Redis 来获取 Session。

当然仅此是不够的，因为不同的应用系统有着不同的域名，尽管 Session 共享了，但是由于 Session ID 是往往保存在浏览器 Cookie 中的，因此存在作用域的限制，无法跨域名传递，也就是说当用户在 app1.com 中登录后，Session ID 仅在浏览器访问 app1.com 时才会自动在请求头中携带，而当浏览器访问 app2.com 时，Session ID 是不会被带过去的。实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。

## **实现方式一：父域 Cookie**

## 

在将具体实现之前，我们先来聊一聊 Cookie 的作用域。

Cookie 的作用域由 domain 属性和 path 属性共同决定。domain 属性的有效值为当前域或其父域的域名/IP地址，在 Tomcat 中，domain 属性默认为当前域的域名/IP地址。path 属性的有效值是以“/”开头的路径，在 Tomcat 中，path 属性默认为当前 Web 应用的上下文路径。

如果将 Cookie 的 domain 属性设置为当前域的父域，那么就认为它是父域 Cookie。Cookie 有一个特点，即父域中的 Cookie 被子域所共享，换言之，子域会自动继承父域中的Cookie。

利用 Cookie 的这个特点，不难想到，将 Session ID（或 Token）保存到父域中不就行了。没错，我们只需要将 Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，这样所有的子域应用就都可以访问到这个 Cookie 了。不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录。

总结：此种实现方式比较简单，但不支持跨主域名。

## **实现方式二：认证中心**

我们可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。

用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。（注意这个 Cookie 是认证中心的，应用系统是访问不到的。）

应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了。如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Token，拼接在目标 URL 的后面，回传给目标应用系统。

应用系统拿到 Token 之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的，其他应用系统是访问不到的。）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了。

这里顺便介绍两款认证中心的开源实现：

- Apereo CAS 是一个企业级单点登录系统，其中 CAS 的意思是”Central Authentication Service“。它最初是耶鲁大学实验室的项目，后来转让给了 JASIG 组织，项目更名为 JASIG CAS，后来该组织并入了Apereo 基金会，项目也随之更名为 Apereo CAS。
- XXL-SSO 是一个简易的单点登录系统，由大众点评工程师许雪里个人开发，代码比较简单，没有做安全控制，因而不推荐直接应用在项目中，这里列出来仅供参考。

总结：此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法。

[spring cloud oauth2 搭建认证中心（授权服务器） - 简书 (jianshu.com)](https://www.jianshu.com/p/d3901772c95a)











## **实现方式三：LocalStorage 跨域**

前面，我们说实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。

父域 Cookie 确实是一种不错的解决方案，但是不支持跨域。那么有没有什么奇淫技巧能够让 Cookie 跨域传递呢？

很遗憾，浏览器对 Cookie 的跨域限制越来越严格。Chrome 浏览器还给 Cookie 新增了一个 SameSite 属性，此举几乎禁止了一切跨域请求的 Cookie 传递（超链接除外），并且只有当使用 HTTPs 协议时，才有可能被允许在 AJAX 跨域请求中接受服务器传来的 Cookie。

不过，在前后端分离的情况下，完全可以不使用 Cookie，我们可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端。这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID （或 Token ）放在响应体中传递给前端。

在这样的场景下，单点登录完全可以在前端实现。前端拿到 Session ID （或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中。

关键代码如下：

```java
// 获取 token
var token = result.data.token;

// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML
var iframe = document.createElement("iframe");
iframe.src = "http://app1.com/localstorage.html";
document.body.append(iframe);
// 使用postMessage()方法将token传递给iframe
setTimeout(function () {
    iframe.contentWindow.postMessage(token, "http://app1.com");
}, 4000);
setTimeout(function () {
    iframe.remove();
}, 6000);

// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage
window.addEventListener('message', function (event) {
    localStorage.setItem('token', event.data)
}, false);
```

前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取 Token 并在请求中携带，这样就实现了同一份 Token 被多个域所共享。

总结：此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域。

## **补充：域名分级**

从专业的角度来说（根据《计算机网络》中的定义），.com、.cn 为一级域名（也称顶级域名），.com.cn、baidu.com 为二级域名，sina.com.cn、tieba.baidu.com 为三级域名，以此类推，N 级域名就是 N-1 级域名的直接子域名。

从使用者的角度来说，一般把可支持独立备案的主域名称作一级域名，如 baidu.com、sina.com.cn 皆可称作一级域名，在主域名下建立的直接子域名称作二级域名，如 tieba.baidu.com 为二级域名。

为了避免歧义，本人将使用“主域名“替代”一级域名“的说法。





# 单点登录解决方案：SpringSecurity + JWT

[单点登录解决方案：SpringSecurity + JWT (qq.com)](https://mp.weixin.qq.com/s/fRF7ZRpBFdAs8aRFZwqD-g)

单点登录的机制其实是比较简单的，用一个现实中的例子做比较。某公园内部有许多独立的景点，游客可以在各个景点门口单独买票。

对于需要游玩所有的景点的游客，这种买票方式很不方便，需要在每个景点门口排队买票，钱包拿 进拿出的，容易丢失，很不安全。

于是绝大多数游客选择在大门口买一张通票（也叫套票），就可以玩遍所有的景点而不需要重新再买票。他们只需要在每个景点门 口出示一下刚才买的套票就能够被允许进入每个独立的景点。

单点登录的机制也一样，如下图所示，

![image-20210905193950352](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210905193950352.png)

**用户认证：** 这一环节主要是用户向认证服务器发起认证请求，认证服务器给用户返回一个成功的令牌token，主要在认证服务器中完成，即图中的认证系统，注意认证系统只能有一个。

**身份校验：** 这一环节是用户携带token去访问其他服务器时，在其他服务器中要对token的真伪进行检验，主要在资源服务器中完成，即图中的应用系统2 3

## 三、JWT介绍

**概念说明**

从分布式认证流程中，我们不难发现，这中间起最关键作用的就是token，token的安全与否，直接关系到系统的健壮性，这里我们选择使用JWT来实现token的生成和校验。

JWT，全称JSON Web Token，官网地址https://jwt.io，是一款出色的分布式身份校验方案。可以生成token，也可以解析检验token。

**JWT生成的token由三部分组成：**

- 头部：主要设置一些规范信息，签名部分的编码格式就在头部中声明。
- 载荷：token中存放有效信息的部分，比如用户名，用户角色，过期时间等，但是不要放密码，会泄露！
- 签名：将头部与载荷分别采用base64编码后，用“.”相连，再加入盐，最后使用头部声明的编码类型进行编码，就得到了签名。

JWT生成token的安全性分析

从JWT生成的token组成上来看，要想避免token被伪造，主要就得看签名部分了，而签名部分又有三部分组成，其中头部和载荷的base64编码，几乎是透明的，毫无安全性可言，那么最终守护token安全的重担就落在了加入的盐上面了！

试想：如果生成token所用的盐与解析token时加入的盐是一样的。岂不是类似于中国人民银行把人民币防伪技术公开了？大家可以用这个盐来解析token，就能用来伪造token。这时，我们就需要对盐采用非对称加密的方式进行加密，以达到生成token与校验token方所用的盐不一致的安全效果！

非对称加密RSA介绍

**基本原理：** 同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端

- 私钥加密，持有私钥或公钥才可以解密
- 公钥加密，持有私钥才可解密

**优点：** 安全，难以破解

**缺点：** 算法比较耗时，为了安全，可以接受

**历史：** 三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA。

## 四、SpringSecurity整合JWT

1.认证思路分析

SpringSecurity主要是通过过滤器来实现功能的！我们要找到SpringSecurity实现认证和校验身份的过滤器！

回顾集中式认证流程

**用户认证：**使用`UsernamePasswordAuthenticationFilter`过滤器中`attemptAuthentication`方法实现认证功能，该过滤器父类中`successfulAuthentication`方法实现认证成功后的操作。

**身份校验：**使用`BasicAuthenticationFilter`过滤器中`doFilterInternal`方法验证是否登录，以决定能否进入后续过滤器。

分析分布式认证流程

**用户认证：**

由于分布式项目，多数是前后端分离的架构设计，我们要满足可以接受异步post的认证请求参数，需要修改`UsernamePasswordAuthenticationFilter`过滤器中`attemptAuthentication`方法，让其能够接收请求体。

另外，默认`successfulAuthentication`方法在认证通过后，是把用户信息直接放入session就完事了，现在我们需要修改这个方法，在认证通过后生成token并返回给用户。

**身份校验：**

原来BasicAuthenticationFilter过滤器中doFilterInternal方法校验用户是否登录，就是看session中是否有用户信息，我们要修改为，验证用户携带的token是否合法，并解析出用户信息，交给SpringSecurity，以便于后续的授权功能可以正常使用。

2.具体实现

为了演示单点登录的效果，我们设计如下项目结构

![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufyg01nHIrpMGoMrsthhZHxUibicxibuFhVBPT86K1z9T7xCFdCe7VjpdoSV0yUgZOjuwAbwjjALN2Gw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**导入JWT相关的依赖**

```xml
<dependencies>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.10.7</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.10.7</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.10.7</version>
        <scope>runtime</scope>
    </dependency>
    <!--jackson包-->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.9.9</version>
    </dependency>
    <!--日志包-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-logging</artifactId>
    </dependency>
    <dependency>
        <groupId>joda-time</groupId>
        <artifactId>joda-time</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
    </dependency>
</dependencies>
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufyg01nHIrpMGoMrsthhZHxX0sEWYReeFkia7bZgSeygl7wsxvvtNvwMB35V6m0SCzNt9ibcIXibB8Zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```java
public class JsonUtils {

    public static final ObjectMapper mapper = new ObjectMapper();

    private static final Logger logger = LoggerFactory.getLogger(JsonUtils.class);

    public static String toString(Object obj) {
        if (obj == null) {
            return null;
        }
        if (obj.getClass() == String.class) {
            return (String) obj;
        }
        try {
            return mapper.writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            logger.error("json序列化出错：" + obj, e);
            return null;
        }
    }

    public static <T> T toBean(String json, Class<T> tClass) {
        try {
            return mapper.readValue(json, tClass);
        } catch (IOException e) {
            logger.error("json解析出错：" + json, e);
            return null;
        }
    }

    public static <E> List<E> toList(String json, Class<E> eClass) {
        try {
            return mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, eClass));
        } catch (IOException e) {
            logger.error("json解析出错：" + json, e);
            return null;
        }
    }

    public static <K, V> Map<K, V> toMap(String json, Class<K> kClass, Class<V> vClass) {
        try {
            return mapper.readValue(json, mapper.getTypeFactory().constructMapType(Map.class, kClass, vClass));
        } catch (IOException e) {
            logger.error("json解析出错：" + json, e);
            return null;
        }
    }

    public static <T> T nativeRead(String json, TypeReference<T> type) {
        try {
            return mapper.readValue(json, type);
        } catch (IOException e) {
            logger.error("json解析出错：" + json, e);
            return null;
        }
    }
}
```

**JwtUtils**

```java
package com.dpb.utils;

import com.dpb.domain.Payload;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.joda.time.DateTime;

import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Base64;
import java.util.UUID;

/**
 * @author: 波波烤鸭
 * 生成token以及校验token相关方法
 */
public class JwtUtils {

    private static final String JWT_PAYLOAD_USER_KEY = "user";

    /**
     * 私钥加密token
     *
     * @param userInfo   载荷中的数据
     * @param privateKey 私钥
     * @param expire     过期时间，单位分钟
     * @return JWT
     */
    public static String generateTokenExpireInMinutes(Object userInfo, PrivateKey privateKey, int expire) {
        return Jwts.builder()
                .claim(JWT_PAYLOAD_USER_KEY, JsonUtils.toString(userInfo))
                .setId(createJTI())
                .setExpiration(DateTime.now().plusMinutes(expire).toDate())
                .signWith(privateKey, SignatureAlgorithm.RS256)
                .compact();
    }

    /**
     * 私钥加密token
     *
     * @param userInfo   载荷中的数据
     * @param privateKey 私钥
     * @param expire     过期时间，单位秒
     * @return JWT
     */
    public static String generateTokenExpireInSeconds(Object userInfo, PrivateKey privateKey, int expire) {
        return Jwts.builder()
                .claim(JWT_PAYLOAD_USER_KEY, JsonUtils.toString(userInfo))
                .setId(createJTI())
                .setExpiration(DateTime.now().plusSeconds(expire).toDate())
                .signWith(privateKey, SignatureAlgorithm.RS256)
                .compact();
    }

    /**
     * 公钥解析token
     *
     * @param token     用户请求中的token
     * @param publicKey 公钥
     * @return Jws<Claims>
     */
    private static Jws<Claims> parserToken(String token, PublicKey publicKey) {
        return Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token);
    }

    private static String createJTI() {
        return new String(Base64.getEncoder().encode(UUID.randomUUID().toString().getBytes()));
    }

    /**
     * 获取token中的用户信息
     *
     * @param token     用户请求中的令牌
     * @param publicKey 公钥
     * @return 用户信息
     */
    public static <T> Payload<T> getInfoFromToken(String token, PublicKey publicKey, Class<T> userType) {
        Jws<Claims> claimsJws = parserToken(token, publicKey);
        Claims body = claimsJws.getBody();
        Payload<T> claims = new Payload<>();
        claims.setId(body.getId());
        claims.setUserInfo(JsonUtils.toBean(body.get(JWT_PAYLOAD_USER_KEY).toString(), userType));
        claims.setExpiration(body.getExpiration());
        return claims;
    }

    /**
     * 获取token中的载荷信息
     *
     * @param token     用户请求中的令牌
     * @param publicKey 公钥
     * @return 用户信息
     */
    public static <T> Payload<T> getInfoFromToken(String token, PublicKey publicKey) {
        Jws<Claims> claimsJws = parserToken(token, publicKey);
        Claims body = claimsJws.getBody();
        Payload<T> claims = new Payload<>();
        claims.setId(body.getId());
        claims.setExpiration(body.getExpiration());
        return claims;
    }
}
```

**RsaUtils**

```java
package com.dpb.utils;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

/**
 * @author 波波烤鸭
 */
public class RsaUtils {

    private static final int DEFAULT_KEY_SIZE = 2048;
    /**
     * 从文件中读取公钥
     *
     * @param filename 公钥保存路径，相对于classpath
     * @return 公钥对象
     * @throws Exception
     */
    public static PublicKey getPublicKey(String filename) throws Exception {
        byte[] bytes = readFile(filename);
        return getPublicKey(bytes);
    }

    /**
     * 从文件中读取密钥
     *
     * @param filename 私钥保存路径，相对于classpath
     * @return 私钥对象
     * @throws Exception
     */
    public static PrivateKey getPrivateKey(String filename) throws Exception {
        byte[] bytes = readFile(filename);
        return getPrivateKey(bytes);
    }

    /**
     * 获取公钥
     *
     * @param bytes 公钥的字节形式
     * @return
     * @throws Exception
     */
    private static PublicKey getPublicKey(byte[] bytes) throws Exception {
        bytes = Base64.getDecoder().decode(bytes);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(bytes);
        KeyFactory factory = KeyFactory.getInstance("RSA");
        return factory.generatePublic(spec);
    }

    /**
     * 获取密钥
     *
     * @param bytes 私钥的字节形式
     * @return
     * @throws Exception
     */
    private static PrivateKey getPrivateKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException {
        bytes = Base64.getDecoder().decode(bytes);
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(bytes);
        KeyFactory factory = KeyFactory.getInstance("RSA");
        return factory.generatePrivate(spec);
    }

    /**
     * 根据密文，生存rsa公钥和私钥,并写入指定文件
     *
     * @param publicKeyFilename  公钥文件路径
     * @param privateKeyFilename 私钥文件路径
     * @param secret             生成密钥的密文
     */
    public static void generateKey(String publicKeyFilename, String privateKeyFilename, String secret, int keySize) throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        SecureRandom secureRandom = new SecureRandom(secret.getBytes());
        keyPairGenerator.initialize(Math.max(keySize, DEFAULT_KEY_SIZE), secureRandom);
        KeyPair keyPair = keyPairGenerator.genKeyPair();
        // 获取公钥并写出
        byte[] publicKeyBytes = keyPair.getPublic().getEncoded();
        publicKeyBytes = Base64.getEncoder().encode(publicKeyBytes);
        writeFile(publicKeyFilename, publicKeyBytes);
        // 获取私钥并写出
        byte[] privateKeyBytes = keyPair.getPrivate().getEncoded();
        privateKeyBytes = Base64.getEncoder().encode(privateKeyBytes);
        writeFile(privateKeyFilename, privateKeyBytes);
    }

    private static byte[] readFile(String fileName) throws Exception {
        return Files.readAllBytes(new File(fileName).toPath());
    }

    private static void writeFile(String destPath, byte[] bytes) throws IOException {
        File dest = new File(destPath);
        if (!dest.exists()) {
            dest.createNewFile();
        }
        Files.write(dest.toPath(), bytes);
    }
}
```

**在通用子模块中编写测试类生成rsa公钥和私钥**

```java
/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
public class JwtTest {
    private String privateKey = "c:/tools/auth_key/id_key_rsa";

    private String publicKey = "c:/tools/auth_key/id_key_rsa.pub";

    @Test
    public void test1() throws Exception{
        RsaUtils.generateKey(publicKey,privateKey,"dpb",1024);
    }

}
```

**导入相关的依赖**

```
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <artifactId>security-jwt-common</artifactId>
        <groupId>com.dpb</groupId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.47</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.1.0</version>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.1.10</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**创建配置文件**

```
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/srm
    username: root
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource
mybatis:
  type-aliases-package: com.dpb.domain
  mapper-locations: classpath:mapper/*.xml
logging:
  level:
    com.dpb: debug
rsa:
  key:
    pubKeyFile: c:\tools\auth_key\id_key_rsa.pub
    priKeyFile: c:\tools\auth_key\id_key_rsa
```

**提供公钥私钥的配置类**

```
package com.dpb.config;

import com.dpb.utils.RsaUtils;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;
import java.security.PrivateKey;
import java.security.PublicKey;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
@Data
@ConfigurationProperties(prefix = "rsa.key")
public class RsaKeyProperties {

    private String pubKeyFile;
    private String priKeyFile;

    private PublicKey publicKey;
    private PrivateKey privateKey;

    /**
     * 系统启动的时候触发
     * @throws Exception
     */
    @PostConstruct
    public void createRsaKey() throws Exception {
        publicKey = RsaUtils.getPublicKey(pubKeyFile);
        privateKey = RsaUtils.getPrivateKey(priKeyFile);
    }

}
```

**创建启动类**

```
/**
 * @program: springboot-54-security-jwt-demo
 * @description: 启动类
 * @author: 波波烤鸭
 */
@SpringBootApplication
@MapperScan("com.dpb.mapper")
@EnableConfigurationProperties(RsaKeyProperties.class)
public class App {

    public static void main(String[] args) {
        SpringApplication.run(App.class,args);
    }
}
```

**完成数据认证的逻辑**

pojo

```
package com.dpb.domain;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.Data;
import org.springframework.security.core.GrantedAuthority;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
@Data
public class RolePojo implements GrantedAuthority {

    private Integer id;
    private String roleName;
    private String roleDesc;

    @JsonIgnore
    @Override
    public String getAuthority() {
        return roleName;
    }
}
package com.dpb.domain;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.Data;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
@Data
public class UserPojo implements UserDetails {

    private Integer id;

    private String username;

    private String password;

    private Integer status;

    private List<RolePojo> roles;

    @JsonIgnore
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<SimpleGrantedAuthority> auth = new ArrayList<>();
        auth.add(new SimpleGrantedAuthority("ADMIN"));
        return auth;
    }

    @Override
    public String getPassword() {
        return this.password;
    }

    @Override
    public String getUsername() {
        return this.username;
    }
    @JsonIgnore
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
    @JsonIgnore
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
    @JsonIgnore
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
    @JsonIgnore
    @Override
    public boolean isEnabled() {
        return true;
    }
}
```

**Mapper接口**

```
public interface UserMapper {
    public UserPojo queryByUserName(@Param("userName") String userName);
}
```

**Mapper映射文件**

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dpb.mapper.UserMapper">
    <select id="queryByUserName" resultType="UserPojo">
        select * from t_user where username = #{userName}
    </select>
</mapper>
```

**Service**

```
public interface UserService extends UserDetailsService {

}
@Service
@Transactional
public class UserServiceImpl implements UserService {

    @Autowired
    private UserMapper mapper;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        UserPojo user = mapper.queryByUserName(s);

        return user;
    }
}
```

**自定义认证过滤器**

```
package com.dpb.filter;

import com.dpb.config.RsaKeyProperties;
import com.dpb.domain.RolePojo;
import com.dpb.domain.UserPojo;
import com.dpb.utils.JwtUtils;
import com.fasterxml.jackson.databind.ObjectMapper;
import net.bytebuddy.agent.builder.AgentBuilder;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter {

    private AuthenticationManager authenticationManager;
    private RsaKeyProperties prop;

    public TokenLoginFilter(AuthenticationManager authenticationManager, RsaKeyProperties prop) {
        this.authenticationManager = authenticationManager;
        this.prop = prop;
    }

    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            UserPojo sysUser = new ObjectMapper().readValue(request.getInputStream(), UserPojo.class);

            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(sysUser.getUsername(), sysUser.getPassword());
            return authenticationManager.authenticate(authRequest);
        }catch (Exception e){
            try {
                response.setContentType("application/json;charset=utf-8");
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                PrintWriter out = response.getWriter();
                Map resultMap = new HashMap();
                resultMap.put("code", HttpServletResponse.SC_UNAUTHORIZED);
                resultMap.put("msg", "用户名或密码错误！");
                out.write(new ObjectMapper().writeValueAsString(resultMap));
                out.flush();
                out.close();
            }catch (Exception outEx){
                outEx.printStackTrace();
            }
            throw new RuntimeException(e);
        }
    }

    public void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {
        UserPojo user = new UserPojo();
        user.setUsername(authResult.getName());
        user.setRoles((List<RolePojo>)authResult.getAuthorities());
        String token = JwtUtils.generateTokenExpireInMinutes(user, prop.getPrivateKey(), 24 * 60);
        response.addHeader("Authorization", "Bearer "+token);
        try {
            response.setContentType("application/json;charset=utf-8");
            response.setStatus(HttpServletResponse.SC_OK);
            PrintWriter out = response.getWriter();
            Map resultMap = new HashMap();
            resultMap.put("code", HttpServletResponse.SC_OK);
            resultMap.put("msg", "认证通过！");
            out.write(new ObjectMapper().writeValueAsString(resultMap));
            out.flush();
            out.close();
        }catch (Exception outEx){
            outEx.printStackTrace();
        }
    }
}
```

**自定义校验token的过滤器**

```
package com.dpb.filter;

import com.dpb.config.RsaKeyProperties;
import com.dpb.domain.Payload;
import com.dpb.domain.UserPojo;
import com.dpb.utils.JwtUtils;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
public class TokenVerifyFilter  extends BasicAuthenticationFilter {
    private RsaKeyProperties prop;

    public TokenVerifyFilter(AuthenticationManager authenticationManager, RsaKeyProperties prop) {
        super(authenticationManager);
        this.prop = prop;
    }

    public void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
        String header = request.getHeader("Authorization");
        if (header == null || !header.startsWith("Bearer ")) {
            //如果携带错误的token，则给用户提示请登录！
            chain.doFilter(request, response);
            response.setContentType("application/json;charset=utf-8");
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            PrintWriter out = response.getWriter();
            Map resultMap = new HashMap();
            resultMap.put("code", HttpServletResponse.SC_FORBIDDEN);
            resultMap.put("msg", "请登录！");
            out.write(new ObjectMapper().writeValueAsString(resultMap));
            out.flush();
            out.close();
        } else {
            //如果携带了正确格式的token要先得到token
            String token = header.replace("Bearer ", "");
            //验证tken是否正确
            Payload<UserPojo> payload = JwtUtils.getInfoFromToken(token, prop.getPublicKey(), UserPojo.class);
            UserPojo user = payload.getUserInfo();
            if(user!=null){
                UsernamePasswordAuthenticationToken authResult = new UsernamePasswordAuthenticationToken(user.getUsername(), null, user.getAuthorities());
                SecurityContextHolder.getContext().setAuthentication(authResult);
                chain.doFilter(request, response);
            }
        }
    }

}
```

**编写SpringSecurity的配置类**

```
package com.dpb.config;

import com.dpb.filter.TokenLoginFilter;
import com.dpb.filter.TokenVerifyFilter;
import com.dpb.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(securedEnabled=true)
public class WebSecurityConfig   extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserService userService;

    @Autowired
    private RsaKeyProperties prop;

    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    //指定认证对象的来源
    public void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userService).passwordEncoder(passwordEncoder());
    }
    //SpringSecurity配置信息
    public void configure(HttpSecurity http) throws Exception {
        http.csrf()
                .disable()
                .authorizeRequests()
                .antMatchers("/user/query").hasAnyRole("ADMIN")
                .anyRequest()
                .authenticated()
                .and()
                .addFilter(new TokenLoginFilter(super.authenticationManager(), prop))
                .addFilter(new TokenVerifyFilter(super.authenticationManager(), prop))
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }
}
```

**启动服务测试**

启动服务

![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufyg01nHIrpMGoMrsthhZHx0ibRulwxVLtuuOp6tepzn0XXiartqnXfpiaxzWlkezTfKyhJXcf3keGhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

通过Postman来访问测试

通过Postman来访问测试

![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufyg01nHIrpMGoMrsthhZHxYGftwlv3Pk5TNjaLS1Y2A71VPWBBbc4wYzNwRHibDUU3kJq5gsvLYBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufyg01nHIrpMGoMrsthhZHxM8qLUHBb42rtR1VuPTTy1TBgpPLKkE7YBuBHrbjTSibNHnWibX6Ka4rQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

根据token信息我们访问其他资源

![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufyg01nHIrpMGoMrsthhZHxbQZZTLbn4ZVu9n1mnyDuMoatXicKk2T7BfoRb2vXmS9M3alz8wth5eQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

2.4资源系统创建

**说明**

资源服务可以有很多个，这里只拿产品服务为例，记住，资源服务中只能通过公钥验证认证。不能签发token！创建产品服务并导入jar包根据实际业务导包即可，咱们就暂时和认证服务一样了。

接下来我们再创建一个资源服务

![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufyg01nHIrpMGoMrsthhZHxeGXGQQdKVM5ia4Pa45UUJc07TRqaGgxhpjR1O7uguiaBgPrOx1LLWiabA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**导入相关的依赖**

```
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <artifactId>security-jwt-common</artifactId>
        <groupId>com.dpb</groupId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.47</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.1.0</version>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.1.10</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**编写产品服务配置文件**

切记这里只能有公钥地址！

```
server:
  port: 9002
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/srm
    username: root
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource
mybatis:
  type-aliases-package: com.dpb.domain
  mapper-locations: classpath:mapper/*.xml
logging:
  level:
    com.dpb: debug
rsa:
  key:
    pubKeyFile: c:\tools\auth_key\id_key_rsa.pub
```

**编写读取公钥的配置类**

```
package com.dpb.config;

import com.dpb.utils.RsaUtils;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;

import javax.annotation.PostConstruct;
import java.security.PrivateKey;
import java.security.PublicKey;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
@Data
@ConfigurationProperties(prefix = "rsa.key")
public class RsaKeyProperties {

    private String pubKeyFile;

    private PublicKey publicKey;

    /**
     * 系统启动的时候触发
     * @throws Exception
     */
    @PostConstruct
    public void createRsaKey() throws Exception {
        publicKey = RsaUtils.getPublicKey(pubKeyFile);
    }

}
```

**编写启动类**

```
package com.dpb;

import com.dpb.config.RsaKeyProperties;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
@SpringBootApplication
@MapperScan("com.dpb.mapper")
@EnableConfigurationProperties(RsaKeyProperties.class)
public class App {

    public static void main(String[] args) {
        SpringApplication.run(App.class,args);
    }
}
```

**复制认证服务中，用户对象，角色对象和校验认证的接口**

复制认证服务中的相关内容即可

**复制认证服务中SpringSecurity配置类做修改**

```
package com.dpb.config;

import com.dpb.filter.TokenVerifyFilter;
import com.dpb.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(securedEnabled=true)
public class WebSecurityConfig   extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserService userService;

    @Autowired
    private RsaKeyProperties prop;

    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    //指定认证对象的来源
    public void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userService).passwordEncoder(passwordEncoder());
    }
    //SpringSecurity配置信息
    public void configure(HttpSecurity http) throws Exception {
        http.csrf()
                .disable()
                .authorizeRequests()
                //.antMatchers("/user/query").hasAnyRole("USER")
                .anyRequest()
                .authenticated()
                .and()
                .addFilter(new TokenVerifyFilter(super.authenticationManager(), prop))
                // 禁用掉session
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }
}
```

去掉“增加自定义认证过滤器”即可！

**编写产品处理器**

```
package com.dpb.controller;

import org.springframework.security.access.annotation.Secured;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @program: springboot-54-security-jwt-demo
 * @description:
 * @author: 波波烤鸭
 */
@RestController
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/query")
    public String query(){
        return "success";
    }

    @RequestMapping("/update")
    public String update(){
        return "update";
    }
}
```

**测试**



![图片](https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufyg01nHIrpMGoMrsthhZHxSYXTVDibux4iccyfRJBIPtDHoRPmXyM4XGjwEpBHboRTLzTqCtic6ETNA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

作者：波波烤鸭



# session cookie
介绍：
Web应用开发大多是基于HTTP协议的。客户端与服务端在使用HTTP协议进行交互时，协议本身并不会记录客户端的信息或是状态。这意味着HTTP协议是一个“无状态”协议，而Web应用中的很多场景是需要保存用户状态的。网站的安全性解决方案就需要对状态进行验证，访问一个受保护的资源的第一步便是检查用户是否通过登录验证。**这样的情况催生了许多用于保存用户状态的解决方案，Session-Cookie就是其中最为常见的一种**。
==Session-Cookie由Session与Cookie两部分组成，分别存储于服务端和客户端==。Session是一种用于记录用户的状态信息，被存储于服务端的数据。例如当前用户是否登录，身份与权限是怎样的，这类数据大多会存储于Session当中。 **Cookie（或者被称作HTTP Cookie）则是一小片被存储在浏览器的数据**，往往在浏览一个网站时便会产生。本身作用在于可以在访问网站的时候，记录一些状态信息到客户端。可以起到提升系统性能并且提高用户体验。在Session-Cookie体系中，**Cookie主要用于记录一串与Session关联的标识。该标识往往被称作“session-id”**。 Session与Cookie不同的是，Cookie是一个真实存在的具体实现，而Session是一个相对抽象的概念，不同的语言与开发框架对Session有不同的实现方式。这两者共同作用，使得用户即便是在使用“无状态”协议与服务端交互，依旧能在不同页面共享一些信息。流程如下：
 ·　客户发送请求到服务端。
 ·　服务端收到请求之后便会在内部创建Session，之后返回响应。在响应头中，包含Set-Cookie信息，其中内容就包含Session-id。 
 ·　当客户端收到包含Set-Cookie的响应之后，后续的所有请求就会带上Cookie。 
 ·　<font color="red">服务端可以根据Cookie中的Session-id让每个请求与Session逐一对应，实现请求间的状态共享。</font>

## 使用Spring Session管理Session

 在Spring Boot开发中，Session-Cookie默认由Web容器（例如Tomcat）维护。例如，访问一个Web容器是Tomcat的Spring Boot应用，默认返回的响应头中会设置一条键为JSESSIONID的Cookie
 Session默认情况下是保存于服务端的JVM内存当中。在该条件下当服务端程序重启时，Session将会丢失。这也意味着用户会集体掉线，如果要继续操作则需要重新登录。在某些场景下，该情况会严重影响用户的使用体验。这不得不将Session的管理从JVM内存中剥离出来。 Spring Session便提供了一套方案用于解决Session管理的问题，使其不依赖于特定的应用程序容器实现Session集群化。下面将讲解Spring Boot整合Spring Session的步骤。
（1）更新依赖 
整合Spring Session的第一个步骤是更新依赖。Spring Session可选的容器类型有四种，分别是Redis、MongoDB、JDBC和HAZELCAST。选择好对应的容器类型后，再根据类型选择对应的依赖项。比如选择Redis作为Session的外部容器，则需要引入spring-session-data-redis。 

(2)修改配置
在application.properties中：
spring:
       session:
     store-type: redis
 得益于Spring Boot的自动配置，加上该配置项之后等同于使用了注解@EnableRedisHttpSession。这将创建名为springSessionRepositoryFilter的过滤器。该过滤器负责将容器中的HttpSession替换为Spring Session。

 （3）配置Redis连接
    redis:
       #redis域名
       hostname: localhost
       #redis端口
       port: 6379
        #redis密码
       password: NlzWZLvvCF5Gzzby
 （4）检验结果 启动程序，并且成功登录之后，可以通过Redis的GUI管理工具查看对应命名空间下的存储情况

 修改SecurityConfig.java



## session并发配置
 Spring Security中默认对session的并发数并没有限制。换句话说，一个用户的账号和密码在默认条件下可以供任意数量的客户端登录。这种情况在某些场景下是难以接受的，例如，一些付费的视频，对于同账户的客户端在线数量会进行限制。Spring Security对于这样的场景也提供了支持。
 首先定义一个SessionInformationExpiredStrategy的实现作为失效策略，用于返回异常信息。ParallelismSessionExpiredStrategy.java： 

```java
@Configuration

public class Parallelismsessionexpiredstrategy implements
SessioninformationexpiredStrategy {
private final ObjectMapper objectMapper;
public void onExpiredSessionDetected(Sessioninformationexpiredevent event)throws Ioexception, Servletexception{
//返回异常信息
event. getresponse(). setContentType("application/ison; charset=utf-8");
event. getresponse().getwriter(). write(objectMapper. writevalueasstring(R.failed("达到并发上限")));
}
}


```

 SecurityConfig中加上sessionManagement配置，SecurityConfig.java：  


```java
@Configuration
@RequiredArgsConstructor
@EnableGlobalMethodSecurity(prePostEnabled = true,secureEnabled = true,jsr250Enabled = true)
public class Securityconfig extends WebSecurityConfigurerAdapter {
@override
protectedvoidconfigure(httpsecurityhttp)throws Exception{
http
//…
.sessionmanagement()//并发 Session上限为1
.maximumsessions(1)//达到上限后是否阻止登录
.maxSessionsPreventslogin( true)
//失效 Session策略
.expiredSessionStrategy(new
ParallelismSessionExpiredstrategy(mapper));//,' 
```

 其中，maxSessionsPreventsLogin用于控制达到Session并发上限后的策略，True代表将阻止后续的登录操作，False代表将会使之前登录的Session强制失效。另外，失效Session的请求结果将按照expiredSessionStrategy中配置的策略进行返回。

 ## 强制下线
Session-Cookie的特点在于服务端可以监听并控制用户的会话状态。这为会话管理模块的开发提供了很大便利。会话管理中强制下线会是一个常见需求，如果一个Web应用中出现违规操作，可以使用强制下线功能为系统提供保护。

```java
@Component
@RequiredArgsConstructor
public class SessionUtils{
private final SessionRegistry sessionRegistry;
public void expireUserSessions(String username){
for (Object principal:sessionRegistry. getAllPrincipals()){
if (principal instanceof SecurityProperties. User){
UserDetails userDetails =(UserDetails) principal;
//遍历 sessionRegistry中的 principal找到对应用户的 Session
if (userDetails. getUsername () equals (username)){
for (SessionInformation information:
sessionRegistry. getAllSessions (userDetails, true)){
//让 session立刻失效
information.expireNow(); 
}
}
}
}

```
需要某个用户强制下线时调用 SessionUtils的expireUserSessions()命令即可。

# JWT
基于Session-Cookie模式的身份验证，这类模式的特点在于后端会维护用户的状态。在常见身份验证方式中，有一种方式与Session-Cookie有着鲜明差异，它不用于后端维护用户状态，这一方式正是将介绍的对象——JWT。
==JWT是一个开放标准（RFC 7519），它定义了一种紧凑且自包含的方式，用于在各端之间将安全信息以JSON对象的形式进行传递==。由于此信息是经过数字签名的，因此可以被验证和信任。另外，还可以使用HMAC或者RSA算法对JWT进行加密。 

## jwt的组成
JWT以紧凑的三部分组成，各部分以（.）分隔，形如xxxx.yyy.zzz。这三部分分别是： 
·　Header（标头）。通常由两部分组成，令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。 
·　Payload（负载）。负载中包含不同类型的声明（Claims）。有已注册声明（预定义声明，包含签发人、超时时间等信息）、公有声明和私有声明（由签发者用于在各端传递安全信息的声明，可随意定义）。 
·　Signature（签名）。基于标头中定义的加密算法进行加密的签名。例如，加密算法为HMACSHA256的话，签名过程将会是：  签名的作用在于保证消息在传输过程中是未被更改的，并且如果使用私钥进行签名，还可以对发送者身份进行进一步的认证。
 基于JWT加密并且可携带安全信息的特点，后端可以将原本保存于Session中的信息保存至JWT的私有声明，然后要求客户端在每次请求中都携带JWT。  以这种方式实现后端服务的无状态化。

JWT带来后端无状态化的同时，也带来了不少好处： 
（1）跨域与CORS 传统的认证方式中，Cookies是默认只能用于单个域名和子域名间进行消息传递。如果碰到域名不同的情况（也就是跨域），整个处理过程会变得繁琐。JWT不依赖Cookie，大多以Authorization:Bearer {JWT}这样的格式作为请求头进行传递，不会被跨域请求所影响。 
（2）跨平台解决方案 同样是受限于Cookies的特性，移动平台与Cookies并不能很好地融合，存在诸多限制。JWT相比Cookie-Session更适合作为跨平台的认证解决方案。 
（3）方便扩展，提升后端性能 Session-Cookie的验证过程中基本都需要对存储模块进行访问，特别在于分布式架构中的认证过程，后端服务需要对外部存储进行访问，其中必然存在数据传输带来的时间损耗。**JWT的验证过程中仅需要根据加密算法对JWT进行验签解密。相对来说，不会有扩展和性能方面的困扰**。  

　

## JWT工作流程

　 通常情况下JWT通过访问一个用于登录的URL来获取。登录成功后，客户端将会在之后的请求的每个请求体中，以Authorization: Bearer {JWT}的格式将JWT设置为请求头。服务端将会对JWT内容进行验签解密，并做出相应的响应。


# OAuth 2.0

第三方应用授权在互联网服务中被广泛地运用。在这一功能的背后，大多会使用到OAuth这一授权技术。OAuth是一个用于授权的网络标准，目前主流的版本为2.0版.
 使用OAuth 2.0这一授权标准，可以让第三方应用程序获取用户在某一网络服务（例如QQ、GitHub）上有限的账户访问权限。比如，使用QQ的第三方授权可以获取用户的QQ昵称头像等信息。实现方式是通过将身份验证这一环委托给承载用户账户的服务器（通常被称作认证服务器，Authorization Server），并授权第三方应用（通常被称作资源服务器，Resource Server）访问用户账户。 
 OAuth 2.0中涉及四个角色之间的信息交换，分别是： ·
 　用户：用户拥有授权／资源服务器上的账户，在流程中授予客户端访问账户的权限。 ·
 　授权服务器：负责验证用户身份，向第三方应用颁发令牌。 ·　资源服务器：负责保管用户账户。
 ·　第三方应用（客户端）：想要访问用户账户的应用程序。 
OAuth 2.0提供四种不同的授权模式以适应各种应用场景： ·　授权码模式 ·　密码模式 ·　简化模式  客户端模式









# 基于jwt的token验证、原理及流程



## 一、什么是JWT

Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).

该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。

JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

## 二、JWT的组成

1、JWT生成编码后的样子

```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.UQmqAUhUrpDVV2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q
```

2、JWT由三部分构成

第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).

**header**

jwt的头部承载两部分信息：

- 声明类型，这里是jwt
- 声明加密的算法 通常直接使用 HMAC SHA256

完整的头部就像下面这样的JSON：

```
{
  'typ': 'JWT',
  'alg': 'HS256'
}
```

然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分

```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
```

**playload**

载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分

- 标准中注册的声明
- 公共的声明
- 私有的声明

标准中注册的声明 (建议但不强制使用) ：

- iss: jwt签发者
- sub: jwt所面向的用户
- aud: 接收jwt的一方
- exp: jwt的过期时间，这个过期时间必须要大于签发时间
- nbf: 定义在什么时间之前，该jwt都是不可用的.
- iat: jwt的签发时间
- jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。

公共的声明 ：

公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.

私有的声明 ：

私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。

定义一个payload:

```
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

然后将其进行base64加密，得到Jwt的第二部分

```
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
```

**signature**

jwt的第三部分是一个签证信息，这个签证信息由三部分组成：

- header (base64后的)
- payload (base64后的)
- secret

这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串(头部在前)，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。

```
UQmqAUhUrpDVV2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q
```

**密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和验证，所以需要保护好。**

![图片](https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhq9KXcAeh9jicfMk7QPRvULQiaQldeibBlmavZ9PXib0ZNibo7iaWMmia7hXob7sRoeR05xFN4mcOJAmo0ZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

3、签名的目的

最后一步签名的过程，实际上是对头部以及载荷内容进行签名。一般而言，加密算法对于不同的输入产生的输出总是不一样的。对于两个不同的输入，产生同样的输出的概率极其地小（有可能比我成世界首富的概率还小）。所以，我们就把“不一样的输入产生不一样的输出”当做必然事件来看待吧。

所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的

服务器应用在接受到JWT后，会首先对头部和载荷的内容用同一算法再次签名。那么服务器应用是怎么知道我们用的是哪一种算法呢？别忘了，我们在JWT的头部中已经用alg字段指明了我们的加密算法了。

如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。

> 注意：在JWT中，不应该在载荷里面加入任何敏感的数据，比如用户的密码。

4、如何应用

一般是在请求头里加入Authorization，并加上Bearer标注：

```
fetch('api/user/1', {
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
```

服务端会验证token，如果验证通过就会返回相应的资源。

5、安全相关

- 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。
- 保护好secret私钥，该私钥非常重要。
- 如果可以，请使用https协议

6、对Token认证的五点认识

- 一个Token就是一些信息的集合；
- 在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；
- 服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
- 基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
- 因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；

## 三、传统的session认证

我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。

但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来。

### 基于session认证所显露的问题

**Session:** 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。

**扩展性:** 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。

**CSRF:** 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。

### 基于token的鉴权机制

基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

流程上是这样的：

- 用户使用用户名密码来请求服务器
- 服务器进行验证用户的信息
- 服务器通过验证发送给用户一个token
- 客户端存储token，并在每次请求时附送上这个token值
- 服务端验证token值，并返回数据

这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了 Access-Control-Allow-Origin:*。

**四、token的优点**

- 支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输。
- 无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息。
- 更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可。
- 去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可。
- 更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。
- CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。
- 性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多。
- 不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理。
- 基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）。
- 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。
- 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
- 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。
- 它不需要在服务端保存会话信息, 所以它易于应用的扩展。

## 五、JWT的JAVA实现

Java中对JWT的支持可以考虑使用JJWT开源库；JJWT实现了JWT, JWS, JWE 和 JWA RFC规范；

下面将简单举例说明其使用：

**1、生成Token码**

```
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;
import java.security.Key;
import io.jsonwebtoken.*;
import java.util.Date;    
 
//Sample method to construct a JWT
 
private String createJWT(String id, String issuer, String subject, long ttlMillis) {
 
//The JWT signature algorithm we will be using to sign the token
SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;
 
long nowMillis = System.currentTimeMillis();
Date now = new Date(nowMillis);
 
//We will sign our JWT with our ApiKey secret
byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(apiKey.getSecret());
Key signingKey = new SecretKeySpec(apiKeySecretBytes, signatureAlgorithm.getJcaName());
 
  //Let's set the JWT Claims
JwtBuilder builder = Jwts.builder().setId(id)
                                .setIssuedAt(now)
                                .setSubject(subject)
                                .setIssuer(issuer)
                                .signWith(signatureAlgorithm, signingKey);
 
//if it has been specified, let's add the expiration
if (ttlMillis >= 0) {
    long expMillis = nowMillis + ttlMillis;
    Date exp = new Date(expMillis);
    builder.setExpiration(exp);
}
 
//Builds the JWT and serializes it to a compact, URL-safe string
return builder.compact();
}
```

**2、解码和验证Token码**

```
import javax.xml.bind.DatatypeConverter;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.Claims;
 
//Sample method to validate and read the JWT
private void parseJWT(String jwt) {
//This line will throw an exception if it is not a signed JWS (as expected)
Claims claims = Jwts.parser()        
  .setSigningKey(DatatypeConverter.parseBase64Binary(apiKey.getSecret()))
   .parseClaimsJws(jwt).getBody();
System.out.println("ID: " + claims.getId());
System.out.println("Subject: " + claims.getSubject());
System.out.println("Issuer: " + claims.getIssuer());
System.out.println("Expiration: " + claims.getExpiration());
}
```

Java中**org.eclipse.microprofile.jwt.Claims\**类\****

import org.eclipse.microprofile.jwt.Claims; //导入依赖的package包/类 @RunAsClient @Test(groups = TEST_GROUP_CDI_PROVIDER,    description = "Verify that the injected jti claim is as expected") public void verifyInjectedJTI2() throws Exception {    Reporter.log("Begin verifyInjectedJTI\n");    String uri = baseURL.toExternalForm() + "/endp/verifyInjectedJTI";    WebTarget echoEndpointTarget = ClientBuilder.newClient()        .target(uri)        .queryParam(Claims.jti.name(), "a-123")        .queryParam(Claims.auth_time.name(), authTimeClaim);    Response response = echoEndpointTarget.request(MediaType.APPLICATION_JSON).header(HttpHeaders.AUTHORIZATION, "Bearer " + token).get();    Assert.assertEquals(response.getStatus(), HttpURLConnection.HTTP_OK);    String replyString = response.readEntity(String.class);    JsonReader jsonReader = Json.createReader(new StringReader(replyString));    JsonObject reply = jsonReader.readObject();    Reporter.log(reply.toString());    Assert.assertTrue(reply.getBoolean("pass"), reply.getString("msg"));



# 常用的HTTP方法有哪些？

GET：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。
HEAD：获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
OPTIONS：查询相应URI支持的HTTP方法。



# [HTTP长连接、短连接究竟是什么？](https://www.cnblogs.com/gotodsp/p/6366163.html)

## 1. HTTP协议与TCP/IP协议的关系

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。

## 2.如何理解HTTP协议是无状态的

HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。



## 3. 什么是长连接、短连接？

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

## 4. TCP连接

当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手”，而释放则需要“四次握手”，所以每个连接的建立都是需要资源消耗和时间消耗的。

经典的三次握手建立连接示意图：
![img](https://mccdn.qcloud.com/static/img/da079414fde193f4d790c72a719eba78/image.jpg)

### 3.2. TCP短连接

模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。

短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。

### 3.3. TCP长连接

我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。

如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：

- 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。
- 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。
- 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
- 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。

## 4. 长连接和短连接的优点和缺点

由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。

短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。

长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。

由上可以看出，**长连接**可以**省去较多的TCP建立和关闭的操作，减少浪费，节约时间**。对于频繁请求资源的客户来说，较适用长连接。不过这里**存在一个问题**，**存活功能的探测周期太长**，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，**Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候**，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

**短连接**对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户**请求频繁**，将在**TCP的建立和关闭操作上浪费时间和带宽**。

长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。

## **长连接短连接操作过程**

```
短连接的操作步骤是：
建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接
长连接的操作步骤是：
建立连接——数据传输...（保持连接）...数据传输——关闭连接
```

## **什么时候用长连接，短连接？** 　　

**长连接**多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如**：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费**。 

而像WEB网站的http服务一般都用**短链接**，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。



# 描述下HTTP和HTTPS的区别。
　　HTTP:是互联网上应用最为广泛的一种网络通信协议，基于TCP,可以使浏览器工作更为高效，减少网络传输，HTTPS:是HTTP的加强版，可以认为是HTTP+SSL(Secure Socket Layer')。在HTTP的基础上增加了一系列的安全机制。一方面保证数据传输安全，另一位方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。
　　主要区别：
　　1、HTTP的连接是简单无状态的，HTTPS的数据传输是经过证书加密的，安全性更高2、HTTP是免费的，而HTTPS需要申请证书，而证书通常是需要收费的，并且费用一般不低，3、他们的传输协议不通过，所以他们使用的端口也是不一样的，HTTP默认是80端口，而HTTPS默认是443端口。
　　HTTPS的缺点：
　　
　　1、HTTPS的握手协议比较费时，所以会影响服务的响应速度以及吞吐量 

​      2、https也不是完全安全的，对于ddos攻击完全不起作用

![image-20220210174431894](C:\Users\heziyi6\AppData\Roaming\Typora\typora-user-images\image-20220210174431894.png)

　SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。

　　TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。

# 跨域请求是什么？

有什么问题？怎么解决？
　　
　　跨域是指浏览器在发起网络请求时，会检查该请求所对应的协议、域名、端口和当前网页是否一致，如果不一致则浏览器会进行限制，比如在www.baidu.com的某个网页中，如果使用ajax去访问www.jd.com是不行的，但是如果是img、iframe、script等标签的src属性去访问则是可以的，之所以浏览器要做这层限制，是为了用户信息安全。但是如果开发者想要绕过这层限制也是可以的：
　
　　1.response添动加header,比如resp.setHeader(Access-Control-Allow-Origin”,“"):表示可以访问所有网站，不受是否同源的限制线程
　　2.jsonp的方式，该技术底层就是基于script标签来实现的，因为script标签是可以跨域的
　　3.后台自己控制，先访问同域名下的接口，然后在接口中再去使用HTTPClient等工具去调用目标接口你
　　4.网关，和第三种方式类似，都是交给后台服务来进行跨域访问

　客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。

　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

　　（5）Web服务器利用自己的私钥解密出会话密钥。

　　（6）Web服务器利用会话密钥加密与客户端之间的通信。

# [RPC框架原理与实现](https://www.cnblogs.com/xiaoqi/p/java-rpc.html)

RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。

RPC基本原理，RPC两个核心模块：通讯，序列化。

RPC，即调用远程计算机上的服务，就像调用本地服务一样。那么RPC的原理是什么呢？了解一个技术最好的思路就是寻找一个该类型麻雀虽小五脏俱全的开源项目，不负所期，找到一个[轻量级分布式 RPC 框架](http://git.oschina.net/huangyong/rpc)，本文从这个项目入手来解读RPC的原理及其实现。

其实说到RPC，大家应该不会陌生才是，以往流行的Web Service就是一种RPC，一般来说RPC 可基于 HTTP 或 TCP 协议，因为Web Service 基于HTTP，所以具有良好的跨平台性，但由于HTTP是应用层协议，相比TCP性能有所损耗。

与本地调用不一样，远程调用需要通过网络层传输，因此涉及到的一个问题就是序列化，不同的序列化方式影响调用性能，流行的序列化包括Protobuf、Kryo、Hessian、Jackson、Thrift。

下面，让我们来一关如何从零开始实现分布式RPC框架。

## RPC框架组件[#](https://www.cnblogs.com/xiaoqi/p/java-rpc.html#2809552735)

建设一个框架，一个系统，首先要做的就是分析需要哪些组件，他们的关系是什么？

简单分析下，一个RPC框架需要包括：

- APP ：应用端，调用服务
- Server 服务容器，对外提供服务
- Service Registry 服务注册表

> 我们需要将服务部署在分布式环境下的不同节点上，通过服务注册的方式，让客户端来自动发现当前可用的服务，并调用这些服务。这需要一种服务注册表（Service Registry）的组件，让它来注册分布式环境下所有的服务地址（包括：主机名与端口号）。

![image-20210909205505258](C:\Users\14172\AppData\Roaming\Typora\typora-user-images\image-20210909205505258.png)

每台 Server 上可发布多个 Service，这些 Service 共用一个 host 与 port，在分布式环境下会提供 Server 共同对外提供 Service。此外，为防止 Service Registry 出现单点故障，因此需要将其搭建为集群环境。

## RPC框架实现[#](https://www.cnblogs.com/xiaoqi/p/java-rpc.html#1232181984)

定义服务

首先定义服务接口，接口可以单独放在一个jar包中

```java
Copypublic interface HelloService {

	String hello(String name);

	String hello(Person person);
}
```

### 实现接口

然后，增加一种实现

```java
@RpcService(HelloService.class)
public class HelloServiceImpl implements HelloService {

    @Override
    public String hello(String name) {
        return "Hello! " + name;
    }

    @Override
    public String hello(Person person) {
        return "Hello! " + person.getFirstName() + " " + person.getLastName();
    }
}
```

这里的RpcService注解，定义在服务接口的实现类上，可以让框架通过这个注解找到服务实现类。

更进一步，如果哪天服务版本升级了，但是历史服务还有人在使用，怎么办？解决方案就是服务需要分版本，按版本调用。

```java
@RpcService(value = HelloService.class, version = "sample.hello2")
public class HelloServiceImpl2 implements HelloService {

    @Override
    public String hello(String name) {
        return "你好! " + name;
    }

    @Override
    public String hello(Person person) {
        return "你好! " + person.getFirstName() + " " + person.getLastName();
    }
}
```

RPC服务注解：

```java
/**
 * RPC 服务注解（标注在服务实现类上）
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface RpcService {

    /**
     * 服务接口类
     */
    Class<?> value();

    /**
     * 服务版本号
     */
    String version() default "";
}
```

### 服务端实现

Server端主要基于Netty（一个NIO框架）+Spring

回到开头讲的，RPC关键点之一就是传输序列化，简单来说就是客户端调用service时，需要构建一个请求，然后将这个请求序列化传输到服务端，服务端完成调用后，再将结果 序列化后返回，简单画一下：





